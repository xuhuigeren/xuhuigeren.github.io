<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>桥头打字员</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-03T15:41:01.468Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Henry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序、进程和线程</title>
    <link href="http://example.com/2021/08/03/%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2021/08/03/%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-08-03T14:12:17.000Z</published>
    <updated>2021-08-03T15:41:01.468Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="sleep-和usleep"><a href="#sleep-和usleep" class="headerlink" title="sleep()和usleep()"></a>sleep()和usleep()</h2><p>函数名:<strong>sleep()</strong></p><p>头文件:<code>#include &lt;unistd.h&gt; </code>  // 在<code>gcc</code>编译器中，使用的头文件因<code>gcc</code>版本的不同而不同</p><p>功 能: 执行挂起指定的秒数<br>语 法: <code>unsigned sleep(unsigned seconds);</code></p><p>函数名:*<strong>usleep()</strong><br>头文件:<code> #include &lt;unistd.h&gt;</code><br>功  能:<code> usleep</code>功能把进程挂起一段时间， 单位是微秒（百万分之一秒）<br>语  法:<code> void usleep(int micro_seconds);</code><br>内容说明：本函数可暂时使程序停止执行。参数 <code>micro_seconds </code>为要暂停的微秒数(us)。</p><h2 id="线程间的互斥"><a href="#线程间的互斥" class="headerlink" title="线程间的互斥"></a>线程间的互斥</h2><p>下面是一个线程互斥的例子。代码用线程互斥的方法构建了以哦个生产者和消费者的例子。代码中建立了两个线程，函数<code>producter_f()</code>用于生成，函数<code>consumer_f()</code>用于消费。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* mutex.c</span></span><br><span class="line"><span class="comment">* 线程实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producter_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span>;<span class="comment">/*生产者*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span>;<span class="comment">/*消费者*/</span></span><br><span class="line"><span class="keyword">int</span> buffer_has_item=<span class="number">0</span>;<span class="comment">/*缓冲区计数值*/</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;<span class="comment">/*互斥区*/</span></span><br><span class="line"><span class="keyword">int</span> running =<span class="number">1</span> ;<span class="comment">/*线程运行控制*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">consumer_t</span>;<span class="comment">/*消费者线程参数*/</span></span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">producter_t</span>;<span class="comment">/*生产者线程参数*/</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_init (&amp;mutex,<span class="literal">NULL</span>);<span class="comment">/*初始化互斥*/</span></span><br><span class="line"></span><br><span class="line">pthread_create(&amp;<span class="keyword">producter_t</span>, <span class="literal">NULL</span>,(<span class="keyword">void</span>*)producter_f, <span class="literal">NULL</span> );            <span class="comment">/*建立生产者线程*/</span></span><br><span class="line">pthread_create(&amp;<span class="keyword">consumer_t</span>, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)consumer_f, <span class="literal">NULL</span>);            <span class="comment">/*建立消费者线程*/</span></span><br><span class="line">usleep(<span class="number">1</span>);<span class="comment">/*等待，线程创建完毕*/</span></span><br><span class="line">running =<span class="number">0</span>;<span class="comment">/*设置线程退出值*/</span></span><br><span class="line">pthread_join(<span class="keyword">consumer_t</span>,<span class="literal">NULL</span>);<span class="comment">/*等待消费者线程退出*/</span></span><br><span class="line">pthread_join(<span class="keyword">producter_t</span>,<span class="literal">NULL</span>);    <span class="comment">/*等待生产者线程退出*/</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);<span class="comment">/*销毁互斥*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producter_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">/*生产者线程程序*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(running)<span class="comment">/*没有设置退出值*/</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock (&amp;mutex);<span class="comment">/*进入互斥区*/</span></span><br><span class="line">buffer_has_item++;<span class="comment">/*增加计数值*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产，总数量:%d\n&quot;</span>,buffer_has_item); <span class="comment">/*打印信息*/</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);<span class="comment">/*离开互斥区*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer_f</span><span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">/*消费者线程程序*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(running)<span class="comment">/*没有设置退出值*/</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);<span class="comment">/*进入互斥区*/</span></span><br><span class="line">buffer_has_item--;<span class="comment">/*减小计数值*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;消费，总数量:%d\n&quot;</span>,buffer_has_item);<span class="comment">/*打印信息*/</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);<span class="comment">/*离开互斥区*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生产，总数量:1</span><br><span class="line">消费，总数量:0</span><br></pre></td></tr></table></figure><p>上例中声明了一个线程互斥变量<code>mutex</code>,在线程函数<code>consumer_f()</code>和<code>producter_f()</code>中，用线程互斥锁函数<code>pthread_mutex_lock()</code>和<code>pthread_mutex_ublock()</code>来保护对公共变量<code>buffer_has_item</code>的访问。</p><h2 id="线程中使用信号量"><a href="#线程中使用信号量" class="headerlink" title="线程中使用信号量"></a>线程中使用信号量</h2><p>下面是一个使用信号量的例子。在<code>mutex</code>的例子中，使用了一个全局变量来计数，在这个例子中，使用信号量来做同样的工作，其中一个线程增加信号量来模仿生产者，另一个线程获得信号量来模仿消费者。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* sem.c</span></span><br><span class="line"><span class="comment">* 线程实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producter_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span>;<span class="comment">/*生产者线程函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span>;<span class="comment">/*消费者线程函数*/</span></span><br><span class="line"><span class="keyword">sem_t</span> sem;</span><br><span class="line"><span class="keyword">int</span> running =<span class="number">1</span> ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">consumer_t</span>;<span class="comment">/*消费者线程参数*/</span></span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">producter_t</span>;<span class="comment">/*生产者线程参数*/</span></span><br><span class="line"></span><br><span class="line">sem_init (&amp;sem, <span class="number">0</span>, <span class="number">16</span>);<span class="comment">/*信号量初始化*/</span></span><br><span class="line"></span><br><span class="line">pthread_create(&amp;<span class="keyword">producter_t</span>, <span class="literal">NULL</span>,(<span class="keyword">void</span>*)producter_f, <span class="literal">NULL</span> );             <span class="comment">/*建立生产者线程*/</span></span><br><span class="line">pthread_create(&amp;<span class="keyword">consumer_t</span>, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)consumer_f, <span class="literal">NULL</span>);             <span class="comment">/*建立消费者线程*/</span></span><br><span class="line">sleep(<span class="number">1</span>);<span class="comment">/*等待*/</span></span><br><span class="line">running =<span class="number">0</span>;<span class="comment">/*设置线程退出*/</span></span><br><span class="line">pthread_join(<span class="keyword">consumer_t</span>,<span class="literal">NULL</span>);<span class="comment">/*等待消费者线程退出*/</span></span><br><span class="line">pthread_join(<span class="keyword">producter_t</span>,<span class="literal">NULL</span>);    <span class="comment">/*等待生产者线程退出*/</span></span><br><span class="line">sem_destroy(&amp;sem);<span class="comment">/*销毁信号量*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producter_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">/*生产者处理程序代码*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> semval=<span class="number">0</span>;<span class="comment">/*信号量的初始值为0*/</span></span><br><span class="line"><span class="keyword">while</span>(running)<span class="comment">/*运行状态为可运行*/</span></span><br><span class="line">&#123;</span><br><span class="line">usleep(<span class="number">1</span>);<span class="comment">/*等待*/</span></span><br><span class="line">sem_post (&amp;sem);<span class="comment">/*信号量增加*/</span></span><br><span class="line">sem_getvalue(&amp;sem,&amp;semval);<span class="comment">/*获得信号量的值*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产，总数量:%d\n&quot;</span>,semval);<span class="comment">/*打印信息*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer_f</span><span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">/*消费者处理程序代码*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> semval=<span class="number">0</span>;<span class="comment">/*信号量的初始值为0*/</span></span><br><span class="line"><span class="keyword">while</span>(running)<span class="comment">/*运行状态为可运行*/</span></span><br><span class="line">&#123;</span><br><span class="line">usleep(<span class="number">1</span>);<span class="comment">/*等待*/</span></span><br><span class="line">sem_wait(&amp;sem);<span class="comment">/*等待信号量*/</span></span><br><span class="line">sem_getvalue(&amp;sem,&amp;semval);<span class="comment">/*获得信号量的值*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;消费，总数量:%d\n&quot;</span>,semval);<span class="comment">/*打印信息*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">生产，总数量:56</span><br><span class="line">生产，总数量:57</span><br><span class="line">消费，总数量:56</span><br><span class="line">消费，总数量:55</span><br><span class="line">生产，总数量:56</span><br><span class="line">消费，总数量:55</span><br><span class="line">生产，总数量:56</span><br><span class="line">生产，总数量:57</span><br><span class="line">消费，总数量:56</span><br><span class="line">消费，总数量:55</span><br><span class="line">生产，总数量:56</span><br><span class="line">生产，总数量:57</span><br><span class="line">消费，总数量:56</span><br><span class="line">消费，总数量:55</span><br><span class="line">生产，总数量:56</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从执行结果可以看出，以上程序建立的各个线程间存在竞争关系。而数值并未按产生一个消耗一个的顺序显示出来，而是以交叉的方式进行，有的时候产生多个再消耗多个。造成这种现象的原因是信号量的产生和消耗是对<code>CPU</code>竞争的结果。</p>]]></content>
    
    
    <summary type="html">学习操作系统的核心概念————进程和线程</summary>
    
    
    
    <category term="Tools" scheme="http://example.com/categories/Tools/"/>
    
    
    <category term="pthread" scheme="http://example.com/tags/pthread/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>GStreamer学习笔记--GObject类对象</title>
    <link href="http://example.com/2021/07/17/gstreamer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gobject%E7%B1%BB%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2021/07/17/gstreamer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gobject%E7%B1%BB%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-07-17T08:48:47.000Z</published>
    <updated>2021-07-24T06:25:11.751Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="GStreamer学习笔记–GObject类对象"><a href="#GStreamer学习笔记–GObject类对象" class="headerlink" title="GStreamer学习笔记–GObject类对象"></a>GStreamer学习笔记–GObject类对象</h1><h2 id="Gobject类定义"><a href="#Gobject类定义" class="headerlink" title="Gobject类定义"></a>Gobject类定义</h2><p>维基百科：<strong>GObject</strong>，是一个在<a href="https://zh.wikipedia.org/wiki/LGPL">LGPL</a>下发布的<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6">自由</a><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BA%93">软件库</a>，它提供了一个轻便的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F&action=edit&redlink=1">对象系统</a>并支持透明的多语言互通。GObject被设计为可以直接使用在<a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">C</a>程序中，也可以被封装至其他语言，例如<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a>，<a href="https://zh.wikipedia.org/wiki/Java">Java</a>，<a href="https://zh.wikipedia.org/wiki/Python">Python</a>，以及可以生成C代码的<a href="https://zh.wikipedia.org/wiki/Vala">Vala</a>（由此大大简化了<code>GObject</code>代码的书写）等等。</p><p><code>Gstreamer</code>框架是基于插件的，同时插件是可以动态的注册、创建，<code>gstreamer</code>基于<code>Gobject</code>开发，下面来了解一下<code>gstreamer</code>是如何通过<code>Gobject</code>完成自定义类的注册。</p><p>在每个类的<code>c</code>文件中，都会有以下这样的一个宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G_DEFINE_TYPE (GstV4l2Allocator, gst_v4l2_allocator, GST_TYPE_ALLOCATOR);</span><br></pre></td></tr></table></figure><p><code>G_DEFINE_TYPE</code>是一个宏定义，那么这个<code>G_DEFINE_TYPE</code>宏是如何完成向<code>Gobject</code>系统完成类的注册呢？</p><p>将<code>G_DEFINE_TYPE</code>展开可以看到以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G_DEFINE_TYPE(TN, t_n, T_P)</span></span><br><span class="line"><span class="comment">/******* </span></span><br><span class="line"><span class="comment"> *TN  ---&gt; TypeName</span></span><br><span class="line"><span class="comment"> *t_n ---&gt; type_name</span></span><br><span class="line"><span class="comment"> *T_P ---&gt; TYPE_PARENT</span></span><br><span class="line"><span class="comment"> *_f_ ---&gt; 0</span></span><br><span class="line"><span class="comment"> *_c_ ---&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">******/</span></span><br><span class="line"><span class="comment">/*****   以下为宏展开   *****/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>     type_name##_init              (TypeName        *self); </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>     type_name##_class_init        (TypeName##Class *klass); </span><br><span class="line"><span class="keyword">static</span> gpointer type_name##_parent_class = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> gint     TypeName##_private_offset;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>     type_name##_class_intern_init (gpointer klass)</span><br><span class="line">&#123;</span><br><span class="line">  type_name##_parent_class = g_type_class_peek_parent (klass);</span><br><span class="line">  <span class="keyword">if</span> (TypeName##_private_offset != <span class="number">0</span>)</span><br><span class="line">    g_type_class_adjust_private_offset (klass, &amp;TypeName##_private_offset);</span><br><span class="line">  type_name##_class_init ((TypeName##Class*) klass);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> gpointer</span><br><span class="line">type_name##_get_instance_private (TypeName *self)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (G_STRUCT_MEMBER_P (self, TypeName##_private_offset));</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">GType </span><br><span class="line">type_name##_get_type (<span class="keyword">void</span>) </span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">volatile</span> gsize g_define_type_id__volatile = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Prelude goes here */</span></span><br><span class="line">  <span class="keyword">if</span> (g_once_init_enter (&amp;g_define_type_id__volatile))</span><br><span class="line">    &#123;</span><br><span class="line">      GType g_define_type_id =</span><br><span class="line">        g_type_register_static_simple (TYPE_PARENT,</span><br><span class="line">                                       g_intern_static_string (#TypeName),</span><br><span class="line">                                       <span class="keyword">sizeof</span> (TypeName##Class),</span><br><span class="line">                                       (GClassInitFunc)(<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) type_name##_class_intern_init,</span><br><span class="line">                                       <span class="keyword">sizeof</span> (TypeName),</span><br><span class="line">                                       (GInstanceInitFunc)(<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) type_name##_init,</span><br><span class="line">                                       (GTypeFlags) flags);</span><br><span class="line">      &#123; <span class="comment">/* custom code follows */</span></span><br><span class="line">      &#123;_C_;&#125;</span><br><span class="line">        <span class="comment">/* following custom code */</span></span><br><span class="line">      &#125;</span><br><span class="line">      g_once_init_leave (&amp;g_define_type_id__volatile, g_define_type_id);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> g_define_type_id__volatile;</span><br><span class="line">&#125; <span class="comment">/* closes type_name##_get_type() */</span></span><br></pre></td></tr></table></figure><h2 id="向Gobject系统注册类"><a href="#向Gobject系统注册类" class="headerlink" title="向Gobject系统注册类"></a>向Gobject系统注册类</h2><p><code>G_DEFINE_TYPE</code>定义如上，那么，最终它是如何向<code>Gobject</code>系统注册该类的呢？<br><code>Gobject</code>系统为什么知道你新添加了一个名叫<code>TypeName</code>的类，是因为你通过<code>g_type_register_static_simple()</code>函数告诉它，我这里有一个新类，你登记一下<code>g_type_register_static_simple()</code>函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLIB_AVAILABLE_IN_ALL</span></span><br><span class="line"><span class="function">GType <span class="title">g_type_register_static_simple</span>     <span class="params">(GType                       parent_type,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> gchar                *type_name,</span></span></span><br><span class="line"><span class="params"><span class="function"> guint                       class_size,</span></span></span><br><span class="line"><span class="params"><span class="function"> GClassInitFunc              class_init,</span></span></span><br><span class="line"><span class="params"><span class="function"> guint                       instance_size,</span></span></span><br><span class="line"><span class="params"><span class="function"> GInstanceInitFunc           instance_init,</span></span></span><br><span class="line"><span class="params"><span class="function"> GTypeFlags             flags)</span></span>;</span><br></pre></td></tr></table></figure><p>函数声明的前面<code>GLIB_AVAILABLE_IN_ALL</code>就是一个<code>extern</code>关键词，从函数声明我们可以了解到，向<code>Gobject</code>系统注册一个类，需要告诉<code>Gobject</code>系统，我现在需要注册一个新类，它父类的类型是<code>parent_type</code>，大小是<code>class_size</code>，类的初始化函数是<code>class_init</code>，类的实例大小以及初始化函数，还有这个类有什么<code>flags</code>，通过告诉<code>Gobject</code>，它就会将新类登记在线。</p><p>通过<code>G_DEFINE_TYPE</code>宏的展开可以知道，在<code>type_name##_get_type()</code>函数中调用到<code>g_type_register_static_simple()</code>函数，那么，究竟是什么时候，程序会向<code>Gobject</code>系统注册该新类呢？<br>比如我们是要注册一个名叫<code>TestObject</code>的类，那么就是通过<code>TestObject_get_type()</code>函数完成<code>estObject</code>的注册登记。<br>在我们需要创建一个<code>TestObject</code>的实例时，会通过调用<code>g_object_new()</code>函数完成，在调用<code>g_object_new</code>函数，需要传进相应的参数，这个时候，我们就将<code>TestObject_get_type()</code>函数的返回值传递给它，即演变成以下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestObject *testObject = （TestObject *）g_object_new (TestObject_get_type(), <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>在创建<code>TestObject</code>实例对象的时候，将会调用<code>TestObject_get_type()</code>函数得到相应的类型，而在<code>TestObject_get_type()</code>函数中，将会先通过<code>g_once_init_enter()</code>函数检查<code>TestObject_get_type()</code>中的静态变量<code>g_define_type_id_volatile</code>是否为0，如果是，则通过<code>g_type_register_static_simple()</code>函数向<code>Gobject</code>系统登记<code>TestObject</code>类，同时返回<code>object ID</code>，如果<code>g_define_type_id_volatile</code>不为0，则说明已经向<code>Gobject</code>系统注册<code>TestObjec</code>t类，直接返回<code>object ID</code>，这样，即完成了<code>TestObject</code>的注册登记。</p><h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><p>学习<code>C++</code>我们都知道，类是有构造函数的，在创建类实例的时候，会自动调用该类的构造函数，那么，在<code>Gobject</code>中，又是怎么调用类的构造函数呢？</p><p>以<code>TestObject</code>为例，在上面说到通过<code>g_type_register_static_simple()</code>函数向<code>Gobject</code>系统注册自定义类的时候，就传进了相应的参数，包括类的初始化函数<code>test_object_class_intern_init()</code>以及类实例的初始化函数<code>test_object_init()</code>，它们两个共同的相当于<code>TestObject</code>类的构造函数。从宏定义<code>G_DEFINE_TYPE</code>的展开代码中发现以下函数声明以及<code>test_object_class_intern_init()</code>函数的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>     <span class="title">test_object_init</span>              <span class="params">(TestObject      *self)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>     <span class="title">test_object_class_init</span>        <span class="params">(TestObjectClass *klass)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>     <span class="title">test_object_class_intern_init</span> <span class="params">(gpointer klass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  test_object_parent_class = g_type_class_peek_parent (klass);</span><br><span class="line">  <span class="keyword">if</span> (test_object_private_offset != <span class="number">0</span>)</span><br><span class="line">    g_type_class_adjust_private_offset (klass, &amp;TestObject_private_offset);</span><br><span class="line">  test_object_class_init ((TestObjectClass*) klass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码我们可以知道，在通过<code>G_DEFINE_TYPE</code>向<code>Gobject</code>系统注册类，还需要我们实现<code>test_object_class_init()</code>和<code>test_object_init()</code>函数的定义。<code>test_object_class_init()</code>函数是在第一次创建<code>TestObject</code>类实例对象的时候调用的，该函数只会调用一次，而<code>test_object_init()</code>函数则是每次创建<code>TestObject</code>类实例对象都会调用。</p><h2 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h2><p>在<code>G_DEFINE_TYPE</code>的展开代码中，可以看到以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> gpointer type_name##_parent_class = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>     type_name##_class_intern_init (gpointer klass)</span><br><span class="line">&#123;</span><br><span class="line">  type_name##_parent_class = g_type_class_peek_parent (klass);</span><br><span class="line">  <span class="keyword">if</span> (TypeName##_private_offset != <span class="number">0</span>)</span><br><span class="line">    g_type_class_adjust_private_offset (klass, &amp;TypeName##_private_offset);</span><br><span class="line">  type_name##_class_init ((TypeName##Class*) klass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个宏中，可以看到定义了一个静态的全局指针变量<code>type_name_parent_class</code>，而<code>type_name_parent_class</code>变量是通过<code>g_type_class_peek_parent()</code>函数赋值的，<code>type_name_parent_class</code>变量代表着什么呢，它就是父类。一般的，会在该源文件新增一个宏，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> type_name##_parent_class parent_class</span></span><br></pre></td></tr></table></figure><p>这样就可以通过宏定义<code>parent_class</code>直接调用父类函数，而该父类，就是在通过宏定义<code>G_DEFINE_TYPE</code>向<code>Gobject</code>系统注册类时传进的第三个参数<code>T_P</code>。<code>g_type_class_peek_parent()</code>函数通过传进的子类指针，查找到注册时候的相应信息，得到父类的类型，而后通过父类类型得到父类信息并返回。</p><h2 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h2><p>有了相应的构造函数，在构造函数中申请了内存、硬件等资源，自然的，也会类似<code>C++</code>的，有相应的析构函数负责资源的释放操作。那么，在<code>Gobject</code>系统中，析构函数又是什么回事呢？我们都知道，构造函数是从父类到子类，而析构函数是从子类到父类。在<code>Gobject</code>系统中的析构函数又是如何的呢？</p><p>之前说到，在通过<code>G_DEFINE_TYPE</code>向<code>Gobject</code>系统，注册<code>TestObject</code>类的时候，需要定义<code>test_object_class_init()</code>和<code>test_object_init()</code>函数，而在类实例的初始化函数<code>test_object_init()</code>中，我们可能申请了一些内存等资源，我们需要在析构函数中释放这些资源，这个时候，需要我们在<code>TestObject</code>类初始化函数<code>test_object_class_init()</code>覆盖从父类继承的析构函数，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void</span><br><span class="line">test_object_dispose (GObject * object)</span><br><span class="line">&#123;</span><br><span class="line">TestObject *testobject = TEST_OBJECT (object);</span><br><span class="line"> </span><br><span class="line">/*  资源释放*/</span><br><span class="line"> </span><br><span class="line">/*  调用父类的dispose 函数 */</span><br><span class="line">G_OBJECT_CLASS (parent_class)-&gt;dispose (object);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void</span><br><span class="line">test_object_finalize (TestObject * testobject)</span><br><span class="line">&#123;</span><br><span class="line">g_free(testobject-&gt;mem);</span><br><span class="line"></span><br><span class="line">    /*  调用父类的finalize 函数 */</span><br><span class="line">G_OBJECT_CLASS (parent_class)-&gt;finalize (object);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void test_object_init(TestObject * self)</span><br><span class="line">&#123;</span><br><span class="line">self-&gt;mem = g_malloc (1);</span><br><span class="line">&#125;</span><br><span class="line">static void test_object_class_init(TestObjectClass *klass)</span><br><span class="line">&#123;</span><br><span class="line">GObjectClass *object_class = G_OBJECT_CLASS (klass);</span><br><span class="line"> </span><br><span class="line">object_class-&gt;dispose = test_object_dispose;</span><br><span class="line">object_class-&gt;finalize = test_object_finalize;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述代码我们可以知道，在<code>TestObject</code>的初始化的时候，将会覆盖从父类继承而来的析构函数，同时在析构函数中释放类实例初始化时占用的资源，同时还有递归调用父类的析构函数。<code>dispose</code>函数主要是将在类中占用的资源释放，而<code>finalize</code>函数则是有点类似真正的析构函数，将构造函数申请的资源进行释放回收。</p><p>既然析构函数也已经有了，析构函数又会是什么时候调用呢？</p><p><code> JAVA</code>使用的是垃圾回收的机制，而<code>Gobjec</code>t则是使用引用计数的方式。当每个对象创建的时候，将会对其引用计数加一，如果期间被其他对象进行引用，也都会将它的引用计数增加；而当对象被解除引用的时候，引用计数将会减一，当引用计数减为0的时候，将会调用对象的析构函数，进行资源的回收。</p><p><code>Gobject</code>的引用计数方式大致如下：</p><ul><li>使用<code>g_object_new()</code>函数进行实例化的时候，对象的引用计数为1；</li><li>使用<code>g_object_ref()</code>函数进行引用对象的时候，对象的引用计数加1；</li><li>使用<code>g_object_unref()</code>函数解除引用的时候，对象的引用计数减1；</li><li>调用<code>g_object_unref()</code>函数进行解引用的时候，如果发现对象的引用计数为0，将会先后调用该对象的<code>dispose()</code>函数和<code>finalize()</code>函数。</li></ul><p>而为什么在<code>test_object_class_init()</code>函数中覆盖从父类继承过来的析构函数呢？<br>因为在<code>g_object_unref()</code>函数中调用<code>dispose()</code>函数和<code>finalize()</code>函数是通过宏定义<code>G_OBJECT_GET_CLASS取得OBJECT_CLASS</code>类之后，再调用它的<code>dispose()</code>函数和<code>finalize()</code>函数，所以需要在<code>TestObject</code>的类初始化函数对这两个函数指针进行覆盖，而在<code>TestObject</code>类的<code>dispose()</code>函数和<code>finalize()</code>函数再通过<code>G_OBJECT_CLASS (parent_class)</code>取得父类指针，调用父类的析构函数。</p><h2 id="类的其他设置"><a href="#类的其他设置" class="headerlink" title="类的其他设置"></a>类的其他设置</h2><p>在<code>Gobject</code>系统中，设置了很多方便的宏，使在使用对象的时候可以更加的方便，在相应的头文件，一般会有如下宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GstTestObject</span> <span class="title">TestObject</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GstTestObjectClass</span> <span class="title">GstTestObjectClass</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 获取类型 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TYPE_TEST_OBJECT      (test_object_get_type())</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 类实例类型判断 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_IS_TEST_OBJECT(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_TEST_OBJECT))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 类结构判定 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_IS_TEST_OBJECT_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_TEST_OBJECT))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 获取obj的类型，同时将其转换为GST_TYPE_TEST_OBJECT，并返回指向GstTestObjectClass的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TEST_OBJECT_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_TEST_OBJECT, GstTestObjectClass))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 检查obj是否是GST_TYPE_TEST_OBJECT类型，如果是，则将返回指向obj成员变量TestObject的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TEST_OBJECT(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_TEST_OBJECT, TestObject))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 检查klass是不是GST_TYPE_TEST_OBJECT类型，如果是，则将返回指向klass成员变量GstTestObjectClass的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TEST_OBJECT_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_TEST_OBJECT, GstTestObjectClass))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 实例结构转换 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TEST_OBJECT_CAST(obj) ((TestObject*)(obj))</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GstTestObject</span> &#123;</span></span><br><span class="line">  GstObject            object;</span><br><span class="line">  gchar *mem;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 类定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GstTestObjectClass</span> &#123;</span></span><br><span class="line">  GstObjectClass    object_class;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是通过上述的宏定义，可以方便的将各种类以及对象进行转换，在子类中可以调用父类的函数等操作，同时，在<code>gstreamer</code>中，还有一些属性设置函数等，进行多样化的类管理。</p><p>另外的，宏定义<code>G_DEFINE_TYPE_WITH_CODE</code>也是实现与<code>G_DEFINE_TYP</code>类似的功能，只不过是可以将一些函数内置在<code>type_name##_get_type()</code>函数中。</p>]]></content>
    
    
    <summary type="html">GObject 设计用于直接在C程序中使用以提供面向对象的基于C的API，并通过与其他语言的绑定来提供透明的跨语言互操作性，例如PyGObject。</summary>
    
    
    
    <category term="Internship" scheme="http://example.com/categories/Internship/"/>
    
    
    <category term="GStreamer" scheme="http://example.com/tags/GStreamer/"/>
    
    <category term="GObject" scheme="http://example.com/tags/GObject/"/>
    
  </entry>
  
  <entry>
    <title>Deepstream 检测安全帽👷</title>
    <link href="http://example.com/2021/07/10/week-2-2/"/>
    <id>http://example.com/2021/07/10/week-2-2/</id>
    <published>2021-07-10T05:32:29.000Z</published>
    <updated>2021-07-24T06:26:21.233Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Yolov3-检测安全帽"><a href="#Yolov3-检测安全帽" class="headerlink" title="Yolov3 检测安全帽"></a>Yolov3 检测安全帽</h1><h2 id="运行自带yolov3示例"><a href="#运行自带yolov3示例" class="headerlink" title="运行自带yolov3示例"></a>运行自带yolov3示例</h2><h3 id="环境和示例说明"><a href="#环境和示例说明" class="headerlink" title="环境和示例说明"></a>环境和示例说明</h3><p><strong>该示例是Deepstream-5.0在Jetson Xavier NX上运行，具体环境部署可以参见<a href="https://xuhuigeren.github.io/2021/07/02/week-1/">这里</a>.</strong></p><p>示例文件在<code>deepstram-5.0\sources\objectDetector_Yolo</code>目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">|-- objectDetector_Yolo</span><br><span class="line">|   |-- config_infer_primary_yoloV2.txt</span><br><span class="line">|   |-- config_infer_primary_yoloV2_tiny.txt</span><br><span class="line">|   |-- config_infer_primary_yoloV3.txt</span><br><span class="line">|   |-- config_infer_primary_yoloV3_tiny.txt</span><br><span class="line">|   |-- deepstream_app_config_yoloV2.txt</span><br><span class="line">|   |-- deepstream_app_config_yoloV2_tiny.txt</span><br><span class="line">|   |-- deepstream_app_config_yoloV3.txt</span><br><span class="line">|   |-- deepstream_app_config_yoloV3_tiny.txt</span><br><span class="line">|   |-- labels.txt</span><br><span class="line">|   |-- prebuild.sh</span><br><span class="line">|   |-- README</span><br><span class="line">|   |-- yolov3-calibration.table.trt7.0</span><br><span class="line">|   |-- nvdsinfer_custom_impl_Yolo             </span><br><span class="line">|       |-- Makefile</span><br><span class="line">|       |-- kernels.cu</span><br><span class="line">|       |-- nvdsinfer_yolo_engine.cpp</span><br><span class="line">|       |-- nvdsparsebbox_Yolo.cpp</span><br><span class="line">|       |-- trt_utils.cpp</span><br><span class="line">|       |-- trt_utils.h</span><br><span class="line">|       |-- yolo.cpp</span><br><span class="line">|       |-- yolo.h</span><br><span class="line">|       |-- yoloPlugins.cpp</span><br><span class="line">|       |-- yoloPlugins.h</span><br></pre></td></tr></table></figure><p><strong>当然是先康康<code>README</code>，果然写的非常细致详尽，介绍了文件目录中每个文件的含义</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Sample contents:</span><br><span class="line">- deepstream_app_config_yolo[V3,V3_tiny,V2,V2_tiny,tlt].txt - DeepStream reference</span><br><span class="line">  app configuration file for using YoloV2/yoloV2-tiny/yolo/yolo-tiny/tlt model</span><br><span class="line">  as the primary detector.</span><br><span class="line">- config_infer_primary_yolo[V3,V3_tiny,V2,V2_tiny,tlt].txt - Configuration file for the GStreamer</span><br><span class="line">  nvinfer plugin for the Yolo detector model.</span><br><span class="line">- yolov3-calibration.table.trt7.0 - yoloV3 INT8 calibration binary on TensorRT 7.0+</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/nvdsinfer_yolo_engine.cpp -</span><br><span class="line">  Implementation of &#x27;NvDsInferCreateModelParser&#x27;/IModelParser for nvdsinfer to</span><br><span class="line">  parse custom models. Alternatively, also contains implementation of</span><br><span class="line">  &#x27;NvDsInferYoloCudaEngineGet&#x27; for nvdsinfer to directly create cuda engine.</span><br><span class="line">  To use the &#x27;NvDsInferYoloCudaEngineGet&#x27; interface, enable the macro</span><br><span class="line">  USE_CUDA_ENGINE_GET_API in nvdsinfer_yolo_engine.cpp</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/nvdsparsebbox_Yolo.cpp - Output layer</span><br><span class="line">  parsing function for detected objects for the Yolo model.</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/yoloPlugins.h -</span><br><span class="line">  Declaration of YoloLayerV3 and YoloLayerV3PluginCreator.</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/yoloPlugins.cpp -</span><br><span class="line">  Implementation of YoloLayerV3 and YoloLayerV3PluginCreator.</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/kernels.cu - Implementation of cuda kernels for</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/trt_utils.h - Utilities to setup tensorRT networks</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/trt_utils.cpp - Implementation of Utilities to setup</span><br><span class="line">   tensorRT networks</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/yolo.h - Interface to create Yolo Cuda-Engine</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/yolo.cpp - Implementation to create Yolo Cuda-Engine</span><br></pre></td></tr></table></figure><p><strong>下载权重和配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Pre-requisites:</span><br><span class="line">- Download yolo config and weights files</span><br><span class="line">  $ ./prebuild.sh         # 可以把脚本里的不需要的部分注释掉，提高下载速度。</span><br><span class="line">- Set correct yolo config/weights file in config_infer_primary_yolo[...].txt.</span><br><span class="line">    custom-network-config # path to yolo config</span><br><span class="line">    model-file # path to yolo weights</span><br><span class="line">- Enable INT8 precision detection if there is a calibration cache file, update</span><br><span class="line">  config_infer_primary_yolo[...].txt.</span><br><span class="line">    int8-calib-file=yolo[...]-calibration.table.trt5.1</span><br><span class="line">- Other INT8 precision calibration table need to be calibrated by user.</span><br><span class="line">- The yolo-tlt sample makes use of a few TensorRT OSS plugins. Download the</span><br><span class="line">  TensorRT OSS repo (https://github.com/NVIDIA/TensorRT/) and checkout the</span><br><span class="line">  &#x27;release/7.0&#x27; branch. Follow the instructions in the README to build the</span><br><span class="line">  plugin library &#x27;libnvinfer_plugin.so.7.0.0&#x27; corresponding to your dGPU/Jetson</span><br><span class="line">  platform. This library needs to be used with LD_PRELOAD to let nvinfer plugin</span><br><span class="line">  access the TRT OSS plugin layers.</span><br><span class="line">- Set the path of the etlt model (tlt-encoded-model) and the tlt model key</span><br><span class="line">  (tlt-model-key) in config_infer_primary_yolo_tlt.txt before running the sample.</span><br></pre></td></tr></table></figure><p><strong>编译工程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Compile the custom library:</span><br><span class="line">  # Based on the API to use &#x27;NvDsInferCreateModelParser&#x27; or &#x27;NvDsInferCudaEngineGet&#x27;</span><br><span class="line">  # set the macro USE_CUDA_ENGINE_GET_API to 0 or 1 in</span><br><span class="line">  # nvdsinfer_custom_impl_Yolo/nvdsinfer_yolo_engine.cpp</span><br><span class="line"></span><br><span class="line">  # Export correct CUDA version (e.g. 10.2, 10.1)</span><br><span class="line">  $ export CUDA_VER=10.2</span><br><span class="line">  $ make -C nvdsinfer_custom_impl_Yolo</span><br><span class="line">  这时候会在nvdsinfer_custom_impl_Yolo文件夹里生成.so文件</span><br></pre></td></tr></table></figure><p><strong>运行示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Run the sample:</span><br><span class="line">The &quot;nvinfer&quot; config file config_infer_primary_yolo.txt specifies the path to</span><br><span class="line">the custom library and the custom output parsing function through the properties</span><br><span class="line">&quot;custom-lib-path&quot; and &quot;parse-bbox-func-name&quot; respectively.</span><br><span class="line">The first-time a &quot;model_b1_int8.engine&quot; would be generated as the engine-file</span><br><span class="line"></span><br><span class="line">- With deepstream-app</span><br><span class="line">  $ deepstream-app -c deepstream_app_config_yoloV3.txt</span><br><span class="line">  $ deepstream-app -c deepstream_app_config_yoloV3_tiny.txt</span><br><span class="line">  $ deepstream-app -c deepstream_app_config_yoloV2.txt</span><br><span class="line">  $ deepstream-app -c deepstream_app_config_yoloV2_tiny.txt</span><br><span class="line">  $ LD_PRELOAD=&lt;path-to-TRT-OSS-libnvinfer_plugin.so.7.0.0&gt; deepstream-app -c deepstream_app_config_yolo_tlt.txt</span><br></pre></td></tr></table></figure><p><strong>检测结果</strong></p><p><img src="/2021/07/10/week-2-2/2-1.png" alt="1"></p><h3 id="程序注释和理解"><a href="#程序注释和理解" class="headerlink" title="程序注释和理解"></a>程序注释和理解</h3><p>该程序分为两个部分：</p><ul><li><p>一部分是<code>tensorRT</code>部分 就是<code>sources\objectDetector_Yolo</code>文件夹里的，编译后会生产动态库文件。也就是<code>libnvdsinfer_custom_impl_Yolo.so</code></p></li><li><p>另一部分是<code>deepstream</code>的文件，在<code>sources\apps\sample_apps\deepstream-app</code>文件夹里。</p></li></ul><p>首先说明下<code>tensorRT</code>几个文件的关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- kernels.cucuda核最底层的实现</span><br><span class="line">|-- nvdsinfer_yolo_engine.cpp根据网络类型创建引擎,生成tensorrt engine</span><br><span class="line">|-- nvdsparsebbox_Yolo.cppyolo目标检测结果的输出,推理后的后处理部分</span><br><span class="line">|-- trt_utils.cpp建立tensorRT网络的部分</span><br><span class="line">|-- trt_utils.h</span><br><span class="line">|-- yolo.cpp创建引擎、创建网络等的具体实现</span><br><span class="line">|-- yolo.h</span><br><span class="line">|-- yoloPlugins.cpp模型搭建的一些组件以及相应的实现</span><br><span class="line">|-- yoloPlugins.h</span><br></pre></td></tr></table></figure><p><img src="/2021/07/10/week-2-2/2-2.png" alt="1"></p><p>其中yolo.cpp实现了网络层的搭建，是核心代码部分,下面代码实现了卷积层的搭建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是卷积层</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_ConfigBlocks.at(i).at(<span class="string">&quot;type&quot;</span>) == <span class="string">&quot;convolutional&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">//获取tensor的大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> inputVol = dimsToString(previous-&gt;getDimensions());</span><br><span class="line">    nvinfer1::ILayer* out;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> layerType;<span class="comment">//保存网络类型</span></span><br><span class="line">    <span class="comment">// check if batch_norm enabled</span></span><br><span class="line">    <span class="keyword">if</span> (m_ConfigBlocks.at(i).find(<span class="string">&quot;batch_normalize&quot;</span>) !=</span><br><span class="line">    m_ConfigBlocks.at(i).end()) &#123;</span><br><span class="line">    <span class="comment">//有BN的卷积层</span></span><br><span class="line">    out = netAddConvBNLeaky(i, m_ConfigBlocks.at(i), weights,</span><br><span class="line">    m_TrtWeights, weightPtr, channels, previous, &amp;network);</span><br><span class="line">    layerType = <span class="string">&quot;conv-bn-leaky&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    out = netAddConvLinear(i, m_ConfigBlocks.at(i), weights,</span><br><span class="line">    m_TrtWeights, weightPtr, channels, previous, &amp;network);</span><br><span class="line">    layerType = <span class="string">&quot;conv-linear&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    previous = out-&gt;getOutput(<span class="number">0</span>);<span class="comment">//获取该层的输出</span></span><br><span class="line">    assert(previous != <span class="literal">nullptr</span>);</span><br><span class="line">    channels = getNumChannels(previous);</span><br><span class="line">    <span class="comment">//获取tensor的大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> outputVol = dimsToString(previous-&gt;getDimensions());</span><br><span class="line">    <span class="comment">//保存相应的层输出</span></span><br><span class="line">    tensorOutputs.push_back(out-&gt;getOutput(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//打印参数</span></span><br><span class="line">    printLayerInfo(layerIndex, layerType, inputVol, outputVol, <span class="built_in">std</span>::to_string(weightPtr));</span><br></pre></td></tr></table></figure><p>下面说明一下deepstream部分代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- deepstream-app</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- README</span><br><span class="line">|   |-- deepstream_app.cpipeline的一些操作在这里</span><br><span class="line">|   |-- deepstream_app.h</span><br><span class="line">|   |-- deepstream_app_config_parser.c 配置文件的解析</span><br><span class="line">|   |-- deepstream_app_main.c deepstream主函数</span><br><span class="line"></span><br><span class="line">deepstream会调用动态库文件libnvdsinfer_custom_impl_Yolo.so实现网络层的搭建等功能</span><br></pre></td></tr></table></figure><p>再来看下deepstream_app_main.c主函数部分的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GOptionContext *ctx = <span class="literal">NULL</span>;</span><br><span class="line">  GOptionGroup *group = <span class="literal">NULL</span>;</span><br><span class="line">  GError *error = <span class="literal">NULL</span>;</span><br><span class="line">  guint i;</span><br><span class="line">  ctx = g_option_context_new (<span class="string">&quot;Nvidia DeepStream Demo&quot;</span>);</span><br><span class="line">  group = g_option_group_new (<span class="string">&quot;abc&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  g_option_group_add_entries (group, entries);  <span class="comment">//把entries添加到group</span></span><br><span class="line">  g_option_context_set_main_group (ctx, group); <span class="comment">//group添加到ctx</span></span><br><span class="line">  g_option_context_add_group (ctx, gst_init_get_option_group ());</span><br><span class="line">  GST_DEBUG_CATEGORY_INIT (NVDS_APP, <span class="string">&quot;NVDS_APP&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);   </span><br><span class="line">  <span class="comment">// 解析命令行参数，识别已添加到上下文的选项</span></span><br><span class="line">  <span class="keyword">if</span> (!g_option_context_parse (ctx, &amp;argc, &amp;argv, &amp;error)) &#123;</span><br><span class="line">    NVGSTDS_ERR_MSG_V (<span class="string">&quot;%s&quot;</span>, error-&gt;message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (print_version) &#123;</span><br><span class="line">    g_print (<span class="string">&quot;deepstream-app version %d.%d.%d\n&quot;</span>,</span><br><span class="line">        NVDS_APP_VERSION_MAJOR, NVDS_APP_VERSION_MINOR, NVDS_APP_VERSION_MICRO);</span><br><span class="line">    nvds_version_print ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (print_dependencies_version) &#123;</span><br><span class="line">    g_print (<span class="string">&quot;deepstream-app version %d.%d.%d\n&quot;</span>,</span><br><span class="line">        NVDS_APP_VERSION_MAJOR, NVDS_APP_VERSION_MINOR, NVDS_APP_VERSION_MICRO);</span><br><span class="line">    nvds_version_print ();</span><br><span class="line">    nvds_dependencies_version_print ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cfg_files) &#123;<span class="comment">//一般执行这项</span></span><br><span class="line">    num_instances = g_strv_length (cfg_files);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (input_files) &#123;</span><br><span class="line">    num_input_files = g_strv_length (input_files);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!cfg_files || num_instances == <span class="number">0</span>) &#123;</span><br><span class="line">    NVGSTDS_ERR_MSG_V (<span class="string">&quot;Specify config file with -c option&quot;</span>);</span><br><span class="line">    return_value = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">    appCtx[i] = g_malloc0 (<span class="keyword">sizeof</span> (AppCtx));</span><br><span class="line">    appCtx[i]-&gt;person_class_id = <span class="number">-1</span>;</span><br><span class="line">    appCtx[i]-&gt;car_class_id = <span class="number">-1</span>;</span><br><span class="line">    appCtx[i]-&gt;index = i;</span><br><span class="line">    appCtx[i]-&gt;active_source_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (show_bbox_text) &#123;</span><br><span class="line">      appCtx[i]-&gt;show_bbox_text = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (input_files &amp;&amp; input_files[i]) &#123;</span><br><span class="line">      appCtx[i]-&gt;config.multi_source_config[<span class="number">0</span>].uri =</span><br><span class="line">          g_strdup_printf (<span class="string">&quot;file://%s&quot;</span>, input_files[i]);</span><br><span class="line">      g_free (input_files[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 解析配置文件内容，这是个重点函数</span></span><br><span class="line">    <span class="keyword">if</span> (!parse_config_file (&amp;appCtx[i]-&gt;config, cfg_files[i])) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;Failed to parse config file &#x27;%s&#x27;&quot;</span>, cfg_files[i]);</span><br><span class="line">      appCtx[i]-&gt;return_value = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 针对配置进行创建pipeline，这里是关键部分deepstream部分</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!create_pipeline (appCtx[i], <span class="literal">NULL</span>,</span><br><span class="line">            all_bbox_generated, perf_cb, overlay_graphics)) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;Failed to create pipeline&quot;</span>);</span><br><span class="line">      return_value = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  main_loop = g_main_loop_new (<span class="literal">NULL</span>, FALSE);</span><br><span class="line">  _intr_setup ();</span><br><span class="line">  g_timeout_add (<span class="number">400</span>, check_for_interrupt, <span class="literal">NULL</span>);</span><br><span class="line">  g_mutex_init (&amp;disp_lock);</span><br><span class="line">  <span class="comment">// 这部分是显示相关的内容</span></span><br><span class="line">  display = XOpenDisplay (<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">    guint j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gst_element_set_state (appCtx[i]-&gt;pipeline.pipeline,</span><br><span class="line">            GST_STATE_PAUSED) == GST_STATE_CHANGE_FAILURE) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;Failed to set pipeline to PAUSED&quot;</span>);</span><br><span class="line">      return_value = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!appCtx[i]-&gt;config.tiled_display_config.enable)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; appCtx[i]-&gt;config.num_sink_sub_bins; j++) &#123;</span><br><span class="line">      XTextProperty xproperty;</span><br><span class="line">      gchar *title;</span><br><span class="line">      guint width, height;</span><br><span class="line">      XSizeHints hints = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="keyword">if</span> (!GST_IS_VIDEO_OVERLAY (appCtx[i]-&gt;pipeline.instance_bins[<span class="number">0</span>].</span><br><span class="line">              sink_bin.sub_bins[j].sink)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!display) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;Could not open X Display&quot;</span>);</span><br><span class="line">        return_value = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">// 显示设置</span></span><br><span class="line">      <span class="keyword">if</span> (appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.width)</span><br><span class="line">        width =</span><br><span class="line">            appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.width;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        width = appCtx[i]-&gt;config.tiled_display_config.width;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.height)</span><br><span class="line">        height =</span><br><span class="line">            appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.height;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        height = appCtx[i]-&gt;config.tiled_display_config.height;</span><br><span class="line">      width = (width) ? width : DEFAULT_X_WINDOW_WIDTH;</span><br><span class="line">      height = (height) ? height : DEFAULT_X_WINDOW_HEIGHT;</span><br><span class="line">      hints.flags = PPosition | PSize;</span><br><span class="line">      hints.x = appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.offset_x;</span><br><span class="line">      hints.y = appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.offset_y;</span><br><span class="line">      hints.width = width;</span><br><span class="line">      hints.height = height;</span><br><span class="line">      windows[i] =</span><br><span class="line">          XCreateSimpleWindow (display, RootWindow (display,</span><br><span class="line">              DefaultScreen (display)), hints.x, hints.y, width, height, <span class="number">2</span>,</span><br><span class="line">              <span class="number">0x00000000</span>, <span class="number">0x00000000</span>);</span><br><span class="line">      XSetNormalHints(display, windows[i], &amp;hints);</span><br><span class="line">      <span class="keyword">if</span> (num_instances &gt; <span class="number">1</span>)</span><br><span class="line">        title = g_strdup_printf (APP_TITLE <span class="string">&quot;-%d&quot;</span>, i);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        title = g_strdup (APP_TITLE);</span><br><span class="line">      <span class="keyword">if</span> (XStringListToTextProperty ((<span class="keyword">char</span> **) &amp;title, <span class="number">1</span>, &amp;xproperty) != <span class="number">0</span>) &#123;</span><br><span class="line">        XSetWMName (display, windows[i], &amp;xproperty);</span><br><span class="line">        XFree (xproperty.value);</span><br><span class="line">      &#125;</span><br><span class="line">      XSetWindowAttributes attr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">      <span class="keyword">if</span> ((appCtx[i]-&gt;config.tiled_display_config.enable &amp;&amp;</span><br><span class="line">              appCtx[i]-&gt;config.tiled_display_config.rows *</span><br><span class="line">              appCtx[i]-&gt;config.tiled_display_config.columns == <span class="number">1</span>) ||</span><br><span class="line">          (appCtx[i]-&gt;config.tiled_display_config.enable == <span class="number">0</span> &amp;&amp;</span><br><span class="line">              appCtx[i]-&gt;config.num_source_sub_bins == <span class="number">1</span>)) &#123;</span><br><span class="line">        attr.event_mask = KeyPress;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        attr.event_mask = ButtonPress | KeyRelease;</span><br><span class="line">      &#125;</span><br><span class="line">      XChangeWindowAttributes (display, windows[i], CWEventMask, &amp;attr);</span><br><span class="line"></span><br><span class="line">      Atom wmDeleteMessage = XInternAtom (display, <span class="string">&quot;WM_DELETE_WINDOW&quot;</span>, False);</span><br><span class="line">      <span class="keyword">if</span> (wmDeleteMessage != None) &#123;</span><br><span class="line">        XSetWMProtocols (display, windows[i], &amp;wmDeleteMessage, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      XMapRaised (display, windows[i]);</span><br><span class="line">      XSync (display, <span class="number">1</span>);       <span class="comment">//discard the events for now</span></span><br><span class="line">      gst_video_overlay_set_window_handle (GST_VIDEO_OVERLAY (appCtx</span><br><span class="line">              [i]-&gt;pipeline.instance_bins[<span class="number">0</span>].sink_bin.sub_bins[j].sink),</span><br><span class="line">          (gulong) windows[i]);</span><br><span class="line">      gst_video_overlay_expose (GST_VIDEO_OVERLAY (appCtx[i]-&gt;</span><br><span class="line">              pipeline.instance_bins[<span class="number">0</span>].sink_bin.sub_bins[j].sink));</span><br><span class="line">      <span class="keyword">if</span> (!x_event_thread)</span><br><span class="line">        x_event_thread = g_thread_new (<span class="string">&quot;nvds-window-event-thread&quot;</span>,</span><br><span class="line">            nvds_x_event_thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Dont try to set playing state if error is observed */</span> </span><br><span class="line">  <span class="comment">// 发生错误的处理</span></span><br><span class="line">  <span class="keyword">if</span> (return_value != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (gst_element_set_state (appCtx[i]-&gt;pipeline.pipeline,</span><br><span class="line">              GST_STATE_PLAYING) == GST_STATE_CHANGE_FAILURE) &#123;</span><br><span class="line"></span><br><span class="line">        g_print (<span class="string">&quot;\ncan&#x27;t set pipeline to playing state.\n&quot;</span>);</span><br><span class="line">        return_value = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  print_runtime_commands ();</span><br><span class="line">  changemode (<span class="number">1</span>);</span><br><span class="line">  g_timeout_add (<span class="number">40</span>, event_thread_func, <span class="literal">NULL</span>);</span><br><span class="line">  g_main_loop_run (main_loop);</span><br><span class="line">  changemode (<span class="number">0</span>);</span><br><span class="line">done:</span><br><span class="line">  g_print (<span class="string">&quot;Quitting\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 下面是释放资源</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (appCtx[i]-&gt;return_value == <span class="number">-1</span>)</span><br><span class="line">      return_value = <span class="number">-1</span>;</span><br><span class="line">    destroy_pipeline (appCtx[i]);</span><br><span class="line"></span><br><span class="line">    g_mutex_lock (&amp;disp_lock);</span><br><span class="line">    <span class="keyword">if</span> (windows[i])</span><br><span class="line">      XDestroyWindow (display, windows[i]);</span><br><span class="line">    windows[i] = <span class="number">0</span>;</span><br><span class="line">    g_mutex_unlock (&amp;disp_lock);</span><br><span class="line">    g_free (appCtx[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  g_mutex_lock (&amp;disp_lock);</span><br><span class="line">  <span class="keyword">if</span> (display)</span><br><span class="line">    XCloseDisplay (display);</span><br><span class="line">  display = <span class="literal">NULL</span>;</span><br><span class="line">  g_mutex_unlock (&amp;disp_lock);</span><br><span class="line">  g_mutex_clear (&amp;disp_lock);</span><br><span class="line">  <span class="keyword">if</span> (main_loop) &#123;</span><br><span class="line">    g_main_loop_unref (main_loop);<span class="comment">//执行循环推理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ctx) &#123;</span><br><span class="line">    g_option_context_free (ctx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (return_value == <span class="number">0</span>) &#123;</span><br><span class="line">    g_print (<span class="string">&quot;App run successful\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    g_print (<span class="string">&quot;App run failed\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  gst_deinit ();</span><br><span class="line">  <span class="keyword">return</span> return_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>deepstream_app_config_parser.c</code>解析配置文件的代码，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">gboolean</span></span><br><span class="line"><span class="function"><span class="title">parse_config_file</span> <span class="params">(NvDsConfig *config, gchar *cfg_file_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GKeyFile *cfg_file = g_key_file_new ();</span><br><span class="line">  GError *error = <span class="literal">NULL</span>;</span><br><span class="line">  gboolean ret = FALSE;</span><br><span class="line">  gchar **groups = <span class="literal">NULL</span>;</span><br><span class="line">  gchar **group;</span><br><span class="line">  guint i, j;</span><br><span class="line"></span><br><span class="line">  config-&gt;source_list_enabled = FALSE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!APP_CFG_PARSER_CAT) &#123;</span><br><span class="line">    GST_DEBUG_CATEGORY_INIT (APP_CFG_PARSER_CAT, <span class="string">&quot;NVDS_CFG_PARSER&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!g_key_file_load_from_file (cfg_file, cfg_file_path, G_KEY_FILE_NONE,</span><br><span class="line">          &amp;error)) &#123;</span><br><span class="line">    GST_CAT_ERROR (APP_CFG_PARSER_CAT, <span class="string">&quot;Failed to load uri file: %s&quot;</span>,</span><br><span class="line">        error-&gt;message);</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (g_key_file_has_group (cfg_file, CONFIG_GROUP_SOURCE_LIST)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!parse_source_list (config, cfg_file, cfg_file_path)) &#123;</span><br><span class="line">      GST_CAT_ERROR (APP_CFG_PARSER_CAT, <span class="string">&quot;Failed to parse &#x27;%s&#x27; group&quot;</span>,</span><br><span class="line">          CONFIG_GROUP_SOURCE_LIST);</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    config-&gt;num_source_sub_bins = config-&gt;total_num_sources;</span><br><span class="line">    config-&gt;source_list_enabled = TRUE;</span><br><span class="line">    <span class="keyword">if</span> (!g_key_file_has_group (cfg_file, CONFIG_GROUP_SOURCE_ALL)) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;[source-attr-all] group not present.&quot;</span>);</span><br><span class="line">      ret = FALSE;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    g_key_file_remove_group (cfg_file, CONFIG_GROUP_SOURCE_LIST, &amp;error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (g_key_file_has_group (cfg_file, CONFIG_GROUP_SOURCE_ALL)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!parse_source (&amp;global_source_config,</span><br><span class="line">            cfg_file, CONFIG_GROUP_SOURCE_ALL, cfg_file_path)) &#123;</span><br><span class="line">      GST_CAT_ERROR (APP_CFG_PARSER_CAT, <span class="string">&quot;Failed to parse &#x27;%s&#x27; group&quot;</span>,</span><br><span class="line">          CONFIG_GROUP_SOURCE_LIST);</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!set_source_all_configs (config, cfg_file_path)) &#123;</span><br><span class="line">      ret = FALSE;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    g_key_file_remove_group (cfg_file, CONFIG_GROUP_SOURCE_ALL, &amp;error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 信息存储在里cfg_file里面</span></span><br><span class="line">  groups = g_key_file_get_groups (cfg_file, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//这里对应的是8项  </span></span><br><span class="line">  <span class="comment">//group[0]=application</span></span><br><span class="line">  <span class="comment">//group[1]=tiled-display</span></span><br><span class="line">  <span class="comment">//group[2]=source0</span></span><br><span class="line">  <span class="comment">//group[3]=sink0</span></span><br><span class="line">  <span class="comment">//group[4]=osd</span></span><br><span class="line">  <span class="comment">//group[5]=streammux</span></span><br><span class="line">  <span class="comment">//group[6]=primary-gie</span></span><br><span class="line">  <span class="comment">//group[7]=tracker</span></span><br><span class="line">  <span class="comment">//group[8]=tests</span></span><br><span class="line">  <span class="keyword">for</span> (group = groups; *group; group++) &#123;</span><br><span class="line">    gboolean parse_err = FALSE;</span><br><span class="line">    GST_CAT_DEBUG (APP_CFG_PARSER_CAT, <span class="string">&quot;Parsing group: %s&quot;</span>, *group);</span><br><span class="line">    <span class="comment">// application </span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_APP)) &#123;</span><br><span class="line">      parse_err = !parse_app (config, cfg_file, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// source0  </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*group, CONFIG_GROUP_SOURCE,</span><br><span class="line">            <span class="keyword">sizeof</span> (CONFIG_GROUP_SOURCE) - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;num_source_sub_bins == MAX_SOURCE_BINS) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d sources&quot;</span>, MAX_SOURCE_BINS);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      gchar *source_id_start_ptr = *group + <span class="built_in">strlen</span> (CONFIG_GROUP_SOURCE);</span><br><span class="line">      gchar *source_id_end_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      guint index =</span><br><span class="line">          g_ascii_strtoull (source_id_start_ptr, &amp;source_id_end_ptr, <span class="number">10</span>);</span><br><span class="line">      <span class="keyword">if</span> (source_id_start_ptr == source_id_end_ptr</span><br><span class="line">          || *source_id_end_ptr != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V</span><br><span class="line">            (<span class="string">&quot;Source group \&quot;[%s]\&quot; is not in the form \&quot;[source&lt;%%d&gt;]\&quot;&quot;</span>,</span><br><span class="line">            *group);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      guint source_id = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;source_list_enabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= config-&gt;total_num_sources) &#123;</span><br><span class="line">          NVGSTDS_ERR_MSG_V</span><br><span class="line">              (<span class="string">&quot;Invalid source group index %d, index cannot exceed %d&quot;</span>, index,</span><br><span class="line">              config-&gt;total_num_sources);</span><br><span class="line">          ret = FALSE;</span><br><span class="line">          <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        source_id = index;</span><br><span class="line">        NVGSTDS_INFO_MSG_V (<span class="string">&quot;Some parameters to be overwritten for group [%s]&quot;</span>,</span><br><span class="line">            *group);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        source_id = config-&gt;num_source_sub_bins;</span><br><span class="line">      &#125;</span><br><span class="line">      parse_err = !parse_source (&amp;config-&gt;multi_source_config[source_id],</span><br><span class="line">          cfg_file, *group, cfg_file_path);</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;source_list_enabled</span><br><span class="line">          &amp;&amp; config-&gt;multi_source_config[source_id].type ==</span><br><span class="line">          NV_DS_SOURCE_URI_MULTIPLE) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V</span><br><span class="line">            (<span class="string">&quot;MultiURI support not available if [source-list] is provided&quot;</span>);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;multi_source_config[source_id].enable</span><br><span class="line">          &amp;&amp; !config-&gt;source_list_enabled) &#123;</span><br><span class="line">        config-&gt;num_source_sub_bins++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// streammux</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_STREAMMUX)) &#123;</span><br><span class="line">      <span class="comment">// 存储到config-&gt;streammux_config中</span></span><br><span class="line">      parse_err = !parse_streammux (&amp;config-&gt;streammux_config, cfg_file, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// osd</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_OSD)) &#123;</span><br><span class="line">      parse_err = !parse_osd (&amp;config-&gt;osd_config, cfg_file);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// primary_gie</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_PRIMARY_GIE)) &#123;</span><br><span class="line">      parse_err =</span><br><span class="line">          !parse_gie (&amp;config-&gt;primary_gie_config, cfg_file,</span><br><span class="line">          CONFIG_GROUP_PRIMARY_GIE, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_TRACKER)) &#123;</span><br><span class="line">      parse_err = !parse_tracker (&amp;config-&gt;tracker_config, cfg_file, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*group, CONFIG_GROUP_SECONDARY_GIE,</span><br><span class="line">                  <span class="keyword">sizeof</span> (CONFIG_GROUP_SECONDARY_GIE) - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;num_secondary_gie_sub_bins == MAX_SECONDARY_GIE_BINS) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d secondary GIEs&quot;</span>, MAX_SECONDARY_GIE_BINS);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      parse_err =</span><br><span class="line">          !parse_gie (&amp;config-&gt;secondary_gie_sub_bin_config[config-&gt;</span><br><span class="line">                                  num_secondary_gie_sub_bins],</span><br><span class="line">                                  cfg_file, *group, cfg_file_path);</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;secondary_gie_sub_bin_config[config-&gt;num_secondary_gie_sub_bins].enable)&#123;</span><br><span class="line">        config-&gt;num_secondary_gie_sub_bins++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*group, CONFIG_GROUP_SINK, <span class="keyword">sizeof</span> (CONFIG_GROUP_SINK) - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;num_sink_sub_bins == MAX_SINK_BINS) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d sinks&quot;</span>, MAX_SINK_BINS);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      parse_err =</span><br><span class="line">          !parse_sink (&amp;config-&gt;</span><br><span class="line">          sink_bin_sub_bin_config[config-&gt;num_sink_sub_bins], cfg_file, *group,</span><br><span class="line">          cfg_file_path);</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;</span><br><span class="line">          sink_bin_sub_bin_config[config-&gt;num_sink_sub_bins].enable)&#123;</span><br><span class="line">        config-&gt;num_sink_sub_bins++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*group, CONFIG_GROUP_MSG_CONSUMER,</span><br><span class="line">        <span class="keyword">sizeof</span> (CONFIG_GROUP_MSG_CONSUMER) - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;num_message_consumers == MAX_MESSAGE_CONSUMERS) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d consumers&quot;</span>, MAX_MESSAGE_CONSUMERS);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      parse_err = !parse_msgconsumer (</span><br><span class="line">                    &amp;config-&gt;message_consumer_config[config-&gt;num_message_consumers],</span><br><span class="line">                    cfg_file, *group, cfg_file_path);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (config-&gt;message_consumer_config[config-&gt;num_message_consumers].enable) &#123;</span><br><span class="line">        config-&gt;num_message_consumers++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tiled-display</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_TILED_DISPLAY)) &#123;</span><br><span class="line">      parse_err = !parse_tiled_display (&amp;config-&gt;tiled_display_config, cfg_file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_IMG_SAVE)) &#123;</span><br><span class="line">      parse_err = !parse_image_save (&amp;config-&gt;image_save_config , cfg_file, *group, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_DSANALYTICS)) &#123;</span><br><span class="line">      parse_err = !parse_dsanalytics (&amp;config-&gt;dsanalytics_config, cfg_file, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_DSEXAMPLE)) &#123;</span><br><span class="line">      parse_err = !parse_dsexample (&amp;config-&gt;dsexample_config, cfg_file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_MSG_CONVERTER)) &#123;</span><br><span class="line">      parse_err = !parse_msgconv (&amp;config-&gt;msg_conv_config, cfg_file, *group, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// tests</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_TESTS)) &#123;</span><br><span class="line">      parse_err = !parse_tests (config, cfg_file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parse_err) &#123;</span><br><span class="line">      GST_CAT_ERROR (APP_CFG_PARSER_CAT, <span class="string">&quot;Failed to parse &#x27;%s&#x27; group&quot;</span>, *group);</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 二级网络处理</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; config-&gt;num_secondary_gie_sub_bins; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (config-&gt;secondary_gie_sub_bin_config[i].unique_id ==</span><br><span class="line">        config-&gt;primary_gie_config.unique_id) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;Non unique gie ids found&quot;</span>);</span><br><span class="line">      ret = FALSE;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; config-&gt;num_secondary_gie_sub_bins; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; config-&gt;num_secondary_gie_sub_bins; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;secondary_gie_sub_bin_config[i].unique_id ==</span><br><span class="line">          config-&gt;secondary_gie_sub_bin_config[j].unique_id) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;Non unique gie id %d found&quot;</span>,</span><br><span class="line">                            config-&gt;secondary_gie_sub_bin_config[i].unique_id);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 多输入源处理</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; config-&gt;num_source_sub_bins; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (config-&gt;multi_source_config[i].type == NV_DS_SOURCE_URI_MULTIPLE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;multi_source_config[i].num_sources &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        config-&gt;multi_source_config[i].num_sources = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; config-&gt;multi_source_config[i].num_sources; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (config-&gt;num_source_sub_bins == MAX_SOURCE_BINS) &#123;</span><br><span class="line">          NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d sources&quot;</span>, MAX_SOURCE_BINS);</span><br><span class="line">          ret = FALSE;</span><br><span class="line">          <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span> (&amp;config-&gt;multi_source_config[config-&gt;num_source_sub_bins],</span><br><span class="line">            &amp;config-&gt;multi_source_config[i],</span><br><span class="line">            <span class="keyword">sizeof</span> (config-&gt;multi_source_config[i]));</span><br><span class="line">        config-&gt;multi_source_config[config-&gt;num_source_sub_bins].type =</span><br><span class="line">            NV_DS_SOURCE_URI;</span><br><span class="line">        config-&gt;multi_source_config[config-&gt;num_source_sub_bins].uri =</span><br><span class="line">            g_strdup_printf (config-&gt;multi_source_config[config-&gt;</span><br><span class="line">                num_source_sub_bins].uri, j);</span><br><span class="line">        config-&gt;num_source_sub_bins++;</span><br><span class="line">      &#125;</span><br><span class="line">      config-&gt;multi_source_config[i].type = NV_DS_SOURCE_URI;</span><br><span class="line">      config-&gt;multi_source_config[i].uri =</span><br><span class="line">          g_strdup_printf (config-&gt;multi_source_config[i].uri, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = TRUE;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">  <span class="keyword">if</span> (cfg_file) &#123;</span><br><span class="line">    g_key_file_free (cfg_file);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (groups) &#123;</span><br><span class="line">    g_strfreev (groups);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    g_error_free (error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">    NVGSTDS_ERR_MSG_V (<span class="string">&quot;%s failed&quot;</span>, __func__);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是建立<code>pipeline</code>的代码，建立<code>pipeline</code>是属于<code>deepstream</code>的部分，里面包含了<code>tensorRT</code>的调用。配置文件当中的<code>[primary-gie]</code>是对推理引擎的相关配置。修改配置文件可以对模型参数进行设置。</p><h2 id="使用yolov3检测安全帽👷"><a href="#使用yolov3检测安全帽👷" class="headerlink" title="使用yolov3检测安全帽👷"></a>使用yolov3检测安全帽👷</h2><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>模型配置文件：<code>yolov3_half_helmet.cfg</code><br>模型权重文件：<code>yolov3_half_helmet.weights</code><br>模型类别：3  ， 0-正常头肩，1-保安头肩，2-安全帽头肩 见<code>helmet.names</code><br>测试视频文件：<code>test_helmet_1.mp4</code>    <code> test_personcount.mp4</code></p><h3 id="检测任务"><a href="#检测任务" class="headerlink" title="检测任务"></a>检测任务</h3><p>①使用<code>deepstream</code>构建一个<code>pipeline</code>，检测<code>test_helmet_1.mp4</code>，输出画面中正常头肩画红框，保安头肩画蓝框，安全帽头肩画绿框<br>②测试安全帽检测 前处理，推理，后处理所用的时间<br>③使用<code>deepstream</code>构建多线程<code>pipeline</code>，使用安全帽检测模型同时检测2个视频文件</p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>对于自定义数据的检测，需根据自己检测的类别修改如下文件</p><p>修改<code>nvdsinfer_custom_impl_Yolo/nvdsparsebbox_Yolo.cpp</code>文件中检测类别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 默认检测coco数据集80个类别，修改为你自己检测的类别</span><br><span class="line">static const int NUM_CLASSES_YOLO = 3;</span><br></pre></td></tr></table></figure><p>注意，修改完需要重新编译和运行生成链接的<code>.so</code>文件</p><p>修改<code>config_infer_primary_yoloV3.txt</code>文件，修改<code>cfg</code>和<code>weights</code>等文件，根据自己检测的类别设置<code>num-detected-classes</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[property]</span><br><span class="line">gpu-id=0</span><br><span class="line">net-scale-factor=0.0039215697906911373</span><br><span class="line">#0=RGB, 1=BGR</span><br><span class="line">model-color-format=0</span><br><span class="line">#修改cfg文件</span><br><span class="line">custom-network-config=yolov3_half_helmet_20200607.cfg</span><br><span class="line">#修改weights文件</span><br><span class="line">model-file=yolov3_half_helmet_20200607.weights</span><br><span class="line">#model-engine-file=yolov3_b1_gpu0_int8.engine</span><br><span class="line">#修改label文件</span><br><span class="line">labelfile-path=helmet_names.txt</span><br><span class="line">int8-calib-file=yolov3-calibration.table.trt7.0</span><br><span class="line">## 0=FP32, 1=INT8, 2=FP16 mode</span><br><span class="line">network-mode=1</span><br><span class="line">#模型类别:3 0-正常头肩，1-保安头肩，2-安全帽头肩</span><br><span class="line">num-detected-classes=3</span><br><span class="line">gie-unique-id=1</span><br><span class="line">network-type=0</span><br><span class="line">is-classifier=0</span><br><span class="line">## 0=Group Rectangles, 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering)</span><br><span class="line">cluster-mode=2</span><br><span class="line">maintain-aspect-ratio=1</span><br><span class="line">parse-bbox-func-name=NvDsInferParseCustomYoloV3</span><br><span class="line"># 编译的动态库路径</span><br><span class="line">custom-lib-path=nvdsinfer_custom_impl_Yolo/libnvdsinfer_custom_impl_Yolo.so</span><br><span class="line">engine-create-func-name=NvDsInferYoloCudaEngineGet</span><br><span class="line">#scaling-filter=0</span><br><span class="line">#scaling-compute-hw=0</span><br><span class="line"></span><br><span class="line">[class-attrs-all]</span><br><span class="line">nms-iou-threshold=0.3# NMS的阈值</span><br><span class="line">#threshold=0.7</span><br><span class="line">pre-cluster-threshold=0.7   # 检测框的过滤阈值</span><br></pre></td></tr></table></figure><p>修改<code>deepstream_app_config_yoloV3.txt</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">[application]</span><br><span class="line">enable-perf-measurement=1</span><br><span class="line">perf-measurement-interval-sec=5</span><br><span class="line">#gie-kitti-output-dir=streamscl</span><br><span class="line"></span><br><span class="line">[tiled-display]</span><br><span class="line">enable=1</span><br><span class="line">rows=1</span><br><span class="line">columns=1</span><br><span class="line">width=1280</span><br><span class="line">height=720</span><br><span class="line">gpu-id=0</span><br><span class="line">#(0): nvbuf-mem-default - Default memory allocated, specific to particular platform</span><br><span class="line">#(1): nvbuf-mem-cuda-pinned - Allocate Pinned/Host cuda memory, applicable for Tesla</span><br><span class="line">#(2): nvbuf-mem-cuda-device - Allocate Device cuda memory, applicable for Tesla</span><br><span class="line">#(3): nvbuf-mem-cuda-unified - Allocate Unified cuda memory, applicable for Tesla</span><br><span class="line">#(4): nvbuf-mem-surface-array - Allocate Surface Array memory, applicable for Jetson</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"></span><br><span class="line">[source0]</span><br><span class="line">enable=1</span><br><span class="line">#Type - 1=CameraV4L2 2=URI 3=MultiURI</span><br><span class="line">type=3</span><br><span class="line"># 修改文件位置</span><br><span class="line">uri=file://../../samples/streams/test_helmet_1.mp4</span><br><span class="line">num-sources=1</span><br><span class="line">gpu-id=0</span><br><span class="line"># (0): memtype_device   - Memory type Device</span><br><span class="line"># (1): memtype_pinned   - Memory type Host Pinned</span><br><span class="line"># (2): memtype_unified  - Memory type Unified</span><br><span class="line">cudadec-memtype=0</span><br><span class="line"></span><br><span class="line">[sink0]</span><br><span class="line">enable=1</span><br><span class="line">#Type - 1=FakeSink 2=EglSink 3=File</span><br><span class="line">type=2</span><br><span class="line">sync=0</span><br><span class="line">source-id=0</span><br><span class="line">gpu-id=0</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"></span><br><span class="line">[osd]</span><br><span class="line">enable=1</span><br><span class="line">gpu-id=0</span><br><span class="line">border-width=1</span><br><span class="line">text-size=15</span><br><span class="line">text-color=1;1;1;1;</span><br><span class="line">text-bg-color=0.3;0.3;0.3;1</span><br><span class="line">font=Serif</span><br><span class="line">show-clock=0</span><br><span class="line">clock-x-offset=800</span><br><span class="line">clock-y-offset=820</span><br><span class="line">clock-text-size=12</span><br><span class="line">clock-color=1;0;0;0</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"></span><br><span class="line">[streammux]</span><br><span class="line">gpu-id=0</span><br><span class="line">##Boolean property to inform muxer that sources are live</span><br><span class="line">live-source=0</span><br><span class="line">batch-size=1</span><br><span class="line">##time out in usec, to wait after the first buffer is available</span><br><span class="line">##to push the batch even if the complete batch is not formed</span><br><span class="line">batched-push-timeout=40000</span><br><span class="line">## Set muxer output width and height</span><br><span class="line">width=1920</span><br><span class="line">height=1080</span><br><span class="line">##Enable to maintain aspect ratio wrt source, and allow black borders, works</span><br><span class="line">##along with width, height properties</span><br><span class="line">enable-padding=0</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"></span><br><span class="line"># config-file property is mandatory for any gie section.</span><br><span class="line"># Other properties are optional and if set will override the properties set in</span><br><span class="line"># the infer config file.</span><br><span class="line">[primary-gie]</span><br><span class="line">enable=1</span><br><span class="line">gpu-id=0</span><br><span class="line">#model-engine-file=model_b1_gpu0_int8.engine</span><br><span class="line"># 修改标签文件</span><br><span class="line">labelfile-path=helmet_names.txt</span><br><span class="line">batch-size=1</span><br><span class="line">#Required by the app for OSD, not a plugin property</span><br><span class="line">bbox-border-color0=1;0;0;1</span><br><span class="line">bbox-border-color1=0;1;1;1</span><br><span class="line">bbox-border-color2=0;0;1;1</span><br><span class="line">bbox-border-color3=0;1;0;1</span><br><span class="line">interval=2</span><br><span class="line">gie-unique-id=1</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"># 修改config文件</span><br><span class="line">config-file=config_infer_helmet_yoloV3.txt</span><br><span class="line"></span><br><span class="line">[tracker]</span><br><span class="line">enable=1</span><br><span class="line">tracker-width=640</span><br><span class="line">tracker-height=384</span><br><span class="line">ll-lib-file=/opt/nvidia/deepstream/deepstream-5.0/lib/libnvds_mot_klt.so</span><br><span class="line"></span><br><span class="line">[tests]</span><br><span class="line">file-loop=0</span><br></pre></td></tr></table></figure><p>如果要检测多个视频，只要在<code>deepstream_app_config_yoloV3.txt</code>文件中添加<code>source</code>和<code>sink</code>并且一一对应即可。</p><h3 id="检测结果"><a href="#检测结果" class="headerlink" title="检测结果"></a>检测结果</h3><p>安全帽检测</p><p><img src="/2021/07/10/week-2-2/2-3.png" alt="18"></p><p>使用安全帽检测模型同时检测2个视频文件</p><p><img src="/2021/07/10/week-2-2/2-4.png" alt="18"></p><p>第一次运行生成<code>engine</code>，这是最耗时的地方，<code>engine</code>只在第一次运行生成，然后可以把<code>config_infer_primary_yoloV3.txt</code>文件中配置打开，多次运行时不必再生成<code>engine</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当这项配置打开时，这样只会在第一次生成引擎，后续启动会很快。</span><br><span class="line">model-engine-file=yolov3_b1_gpu0_int8.engine</span><br></pre></td></tr></table></figure><h2 id="测试时间"><a href="#测试时间" class="headerlink" title="测试时间"></a>测试时间</h2><p>测试安全帽检测 前处理，推理，后处理所用的时间这部分还没有完成。。。</p><p>尽量尽快补充完成！</p>]]></content>
    
    
    <summary type="html">Deepstream YoloV3检测安全帽</summary>
    
    
    
    <category term="Internship" scheme="http://example.com/categories/Internship/"/>
    
    
    <category term="Jetson" scheme="http://example.com/tags/Jetson/"/>
    
    <category term="Deepstreeam" scheme="http://example.com/tags/Deepstreeam/"/>
    
  </entry>
  
  <entry>
    <title>Installing  GStreamer</title>
    <link href="http://example.com/2021/07/09/week-2-1/"/>
    <id>http://example.com/2021/07/09/week-2-1/</id>
    <published>2021-07-09T13:01:50.000Z</published>
    <updated>2021-07-24T06:26:12.464Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Installing-GStreamer"><a href="#Installing-GStreamer" class="headerlink" title="Installing  GStreamer"></a>Installing  GStreamer</h1><h2 id="Installing-on-Linux"><a href="#Installing-on-Linux" class="headerlink" title="Installing on Linux"></a>Installing on Linux</h2><p><strong>系统：Ubuntu 16.04</strong></p><p>参照<a href="https://gstreamer.freedesktop.org/documentation/installing/on-linux.html?gi-language=c">官方文档</a>，运行以下命令，但是在我的笔记本和公司的台式机上似乎不太ok…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libgstreamer-plugins-bad1.0-dev gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio</span><br></pre></td></tr></table></figure><p><a href="https://samwhelp.github.io/note-ubuntu-18.04/read/howto/install-tool/gstreamer/">参考</a>了一位湾湾网友，运行以下命令成功安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools</span><br></pre></td></tr></table></figure><p><strong>Package</strong></p><ul><li><a href="https://packages.ubuntu.com/bionic/libgstreamer1.0-0">libgstreamer1.0-0</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-plugins-base">gstreamer1.0-plugins-base</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-plugins-good">gstreamer1.0-plugins-good</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-plugins-bad">gstreamer1.0-plugins-bad</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-plugins-ugly">gstreamer1.0-plugins-ugly</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-libav">gstreamer1.0-libav</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-doc">gstreamer1.0-doc</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-tools">gstreamer1.0-tools</a></li></ul><p><strong>验证安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep gstreamer</span><br></pre></td></tr></table></figure><p><strong>使用 GStreamer 构建应用程序</strong></p><p>为了编译 GStreamer 并使用 GStreamer 核心库的代码，需在<code>gcc</code>后添加以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --cflags --libs gstreamer-1.0</span><br></pre></td></tr></table></figure><p>如果使用其他 GStreamer 库，例如视频库，则必须在上述 gstreamer-1.0 之后添加其他包（例如，视频库的 gstreamer-video-1.0）</p><p><strong>获取tutorial’s source code</strong></p><p>可以使用以下命令git到本地，可以在文件目录<code>gst/examples/tutorials</code>中找到例程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.freedesktop.org/gstreamer/gst-docs</span><br></pre></td></tr></table></figure><p><strong>Building the tutorials</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc basic-tutorial-1.c -o basic-tutorial-1 `pkg-config --cflags --libs gstreamer-1.0`</span><br></pre></td></tr></table></figure><p><strong>Running the tutorials</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./basic-tutorial-1</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="/2021/07/09/week-2-1/2_1.png" alt="1"></p><p><strong>nice</strong>！</p><h2 id="Installing-on-Windows"><a href="#Installing-on-Windows" class="headerlink" title="Installing on Windows"></a>Installing on Windows</h2><p>首先参照<a href="https://gstreamer.freedesktop.org/documentation/installing/on-windows.html?gi-language=c">官方文档</a>安装，真的蛮心累的，英文我都能看懂，但就是搞不定。记录一下GStreamer on Windows的崎岖之路。</p><p><strong>环境：Win 10 + VS2017</strong></p><p><strong>1. 下载GStreamer</strong></p><p>选择MSVC 64-bit(有mingw可选)</p><p><a href="https://gstreamer.freedesktop.org/data/pkg/windows/1.18.4/msvc/gstreamer-1.0-msvc-x86_64-1.18.4.msi">gstreamer-1.0-msvc-x86_64-1.18.4.msi</a>               先装</p><p><a href="https://gstreamer.freedesktop.org/data/pkg/windows/1.18.4/msvc/gstreamer-1.0-devel-msvc-x86_64-1.18.4.msi">gstreamer-1.0-devel-msvc-x86_64-1.18.4.msi</a>    后装</p><p>安装的时候都选择<code>Complete</code>完整安装，默认会安装在剩余空间最大的盘符</p><p><strong>2. 配置系统变量</strong></p><p>首先将<code>glibconfig.h</code>文件拷贝到<code>include/glib-2.0</code>以及<code>include/glib-2.0/glib</code>目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|-- lib</span><br><span class="line">|   |-- glib-2.0</span><br><span class="line">|   |    -- include</span><br><span class="line">|   |        -- glibconfig.h 此文件拷贝到</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- include</span><br><span class="line">|     --glib-2.0 此目录下</span><br><span class="line">|        -- glib 以及此目录下</span><br></pre></td></tr></table></figure><p>添加用户变量</p><p><img src="/2021/07/09/week-2-1/2_3.png" alt="3"></p><p>添加系统变量</p><p><img src="/2021/07/09/week-2-1/2_4.png" alt="4"></p><p>Path中添加路径</p><p><img src="/2021/07/09/week-2-1/2_5.png" alt="5"></p><p><strong>3. 环境测试</strong></p><ul><li><p>影像测试，打开cmd运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-launch-1.0 videotestsrc ! videoconvert ! autovideosink</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/07/09/week-2-1/2_6.png" alt="6"></p><ul><li><p>撞球测试，打开cmd运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-launch-1.0 -v videotestsrc pattern=ball ! video/x-raw,width=320,height=240 ! videoconvert ! tee ! autovideosink device=0</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_7.png" alt="7"></p></li></ul><p>至此，GStreamer的MSCV环境ok，接下来在VS2017配置GStreamer</p><p><strong>4. VS2017配置GStreamer</strong></p><p>还是之前下载的<a href="https://medium.com/r/?url=https://gitlab.freedesktop.org/gstreamer/gst-docs/">gst-docs</a>，用VS打开，双击<code>tutorials.sln</code></p><p><img src="/2021/07/09/week-2-1/2_8.png" alt="8"></p><p><code>tutorials</code>给的是<code>VS2010</code>的例程，当然要升级一下啦</p><p><img src="/2021/07/09/week-2-1/2_9.png" alt="9"></p><p>打开后是这样滴</p><p><img src="/2021/07/09/week-2-1/2_9_1.png" alt="9_1"></p><p>站起来活动一下，直直腰可以开始啦，一上来全是<code>Errors</code>，能运行才奇怪捏。。。</p><p><img src="/2021/07/09/week-2-1/2_10.png" alt="10"></p><p>重点来了，第一次给<code>VS2017</code>配置第三方库</p><p>① 解决方案资源管理器里选择项目名，右键项目，选择属性</p><p>在配置属性——调试——工作目录 增加如下目录(选择活动(x64)平台哦，接下来都是)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\gstreamer\1.0\msvc_x86_64\bin</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_11.png" alt="11"></p><p>②在C/C++ —— 常规——附加包含目录 增加如下目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\gstreamer\1.0\msvc_x86_64\include\gstreamer-1.0</span><br><span class="line">D:\gstreamer\1.0\msvc_x86_64\include\glib-2.0</span><br><span class="line">D:\gstreamer\1.0\msvc_x86_64\include\libxml2</span><br><span class="line">D:\gstreamer\1.0\msvc_x86_64\include</span><br><span class="line">D:\gstreamer\1.0\msvc_x86_64\lib\glib-2.0\include</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_12.png" alt="12"></p><p>③在链接器—-常规—-附加库目录，增加 如下目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\gstreamer\1.0\msvc_x86_64\lib</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_13.png" alt="13"></p><p>④在链接器—-输入—–附加依赖性 增加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gobject-2.0.lib</span><br><span class="line">glib-2.0.lib</span><br><span class="line">gstreamer-1.0.lib</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_14.png" alt="14"></p><p>测试一下，运行一下<code>basic-tutorial-1.c</code>，没有报错了，撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> </p><p><img src="/2021/07/09/week-2-1/2_15.png" alt="15"></p><p>运行结果</p><p><img src="/2021/07/09/week-2-1/2_17.png" alt="17"></p><p><code>basic-tutorial-1.c</code>的代码就先不解读啦，里面注释很清晰了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GstElement *pipeline;</span><br><span class="line">GstBus *bus;</span><br><span class="line">GstMessage *msg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize GStreamer */</span></span><br><span class="line">gst_init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Build the pipeline */</span></span><br><span class="line">pipeline =</span><br><span class="line">gst_parse_launch</span><br><span class="line">(<span class="string">&quot;playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm&quot;</span>,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Start playing */</span></span><br><span class="line">gst_element_set_state(pipeline, GST_STATE_PLAYING);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait until error or EOS */</span></span><br><span class="line">bus = gst_element_get_bus(pipeline);</span><br><span class="line">msg =</span><br><span class="line">gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE,</span><br><span class="line">GST_MESSAGE_ERROR | GST_MESSAGE_EOS);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free resources */</span></span><br><span class="line"><span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">gst_message_unref(msg);</span><br><span class="line">gst_object_unref(bus);</span><br><span class="line">gst_element_set_state(pipeline, GST_STATE_NULL);</span><br><span class="line">gst_object_unref(pipeline);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>GStreamer on Windows的安装至此算是搞定了，还是有花蛮多精力的！No pains, no gains. 接下来还要学写GStreamer插件，能写好的再记录一下！</p><p><strong>参考</strong></p><p><a href="https://gstreamer.freedesktop.org/data/pkg/windows/1.18.4/msvc/">https://gstreamer.freedesktop.org/data/pkg/windows/1.18.4/msvc/</a></p><p><a href="https://gstreamer.freedesktop.org/documentation/installing/index.html?gi-language=c">https://gstreamer.freedesktop.org/documentation/installing/index.html?gi-language=c</a></p><p><a href="https://www.cnblogs.com/0-lingdu/p/12718613.html">https://www.cnblogs.com/0-lingdu/p/12718613.html</a></p><p><a href="https://blog.csdn.net/kongxingxing/article/details/104270463">https://blog.csdn.net/kongxingxing/article/details/104270463</a></p><p><a href="https://blog.csdn.net/fly_bear_unknown/article/details/113917633">https://blog.csdn.net/fly_bear_unknown/article/details/113917633</a></p>]]></content>
    
    
    <summary type="html">GStreamer在Ubuntu和Windows上安装</summary>
    
    
    
    <category term="Internship" scheme="http://example.com/categories/Internship/"/>
    
    
    <category term="GStreamer" scheme="http://example.com/tags/GStreamer/"/>
    
  </entry>
  
  <entry>
    <title>Jetson 部署 Deepstream</title>
    <link href="http://example.com/2021/07/02/week-1/"/>
    <id>http://example.com/2021/07/02/week-1/</id>
    <published>2021-07-02T12:13:16.000Z</published>
    <updated>2021-07-24T06:25:56.273Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Jetson-部署-Deep-stream"><a href="#Jetson-部署-Deep-stream" class="headerlink" title="Jetson 部署 Deep stream"></a>Jetson 部署 Deep stream</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="查看Jetson信息"><a href="#查看Jetson信息" class="headerlink" title="查看Jetson信息"></a><strong>查看Jetson信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo pip3 install jetson-stats</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jtop</span></span><br></pre></td></tr></table></figure><p><img src="/2021/07/02/week-1/01.png" alt="01"></p><h3 id="Jetson-Setup"><a href="#Jetson-Setup" class="headerlink" title="Jetson Setup"></a><strong>Jetson Setup</strong></h3><p>如果是 Jetson Nano 或者 Jetson Xavier NX developer kit, 从<a href="https://developer.nvidia.com/embedded/jetpack">JetPack SDK</a>下载 SD card image，这其中包含了 CUDA, TensorRT and cuDNN.</p><h3 id="命令行工具nvpmodel"><a href="#命令行工具nvpmodel" class="headerlink" title="命令行工具nvpmodel"></a><strong>命令行工具nvpmodel</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo nvpmodel --query</span></span><br><span class="line">NV Fan Mode:cool</span><br><span class="line">NV Power Mode: MODE_15W_2CORE</span><br><span class="line">0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到模式2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo nvpmodel -m 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最大化Xavier性能</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo jetson_clocks</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前设置：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo jetson_clocks --show</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复以前的设置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo jetson_clocks --restore</span></span><br></pre></td></tr></table></figure><h3 id="查看操作系统信息"><a href="#查看操作系统信息" class="headerlink" title="查看操作系统信息"></a><strong>查看操作系统信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux查看版本当前操作系统 内核信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> uname --a</span></span><br><span class="line">Linux name-desktop 4.9.140-tegra #1 SMP PREEMPT Thu Jun 25 21:22:12 PDT 2020 aarch64 aarch64 aarch64 GNU/Linux</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux查看当前操作系统 版本信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/version</span></span><br><span class="line">Linux version 4.9.140-tegra (buildbrain@mobile-u64-3357) (gcc version 7.3.1 20180425 [linaro-7.3-2018.05 revision d29120a424ecfbc167ef90065c0eeb7f91977701] (Linaro GCC 7.3-2018.05) ) #1 SMP PREEMPT Thu Jun 25 21:22:12 PDT 2020</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux查看版本当前操作系统 发行版信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/issue</span></span><br><span class="line">Ubuntu 18.04.5 LTS \n \l</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看cpu的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/cpuinfo</span></span><br><span class="line">processor: 0</span><br><span class="line">model name: ARMv8 Processor rev 0 (v8l)</span><br><span class="line">BogoMIPS: 62.50</span><br><span class="line">Features: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp</span><br><span class="line">CPU implementer: 0x4e</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant: 0x0</span><br><span class="line">CPU part: 0x004</span><br><span class="line">CPU revision: 0</span><br><span class="line">MTS version: 50168445</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line">processor: 5</span><br><span class="line">model name: ARMv8 Processor rev 0 (v8l)</span><br><span class="line">BogoMIPS: 62.50</span><br><span class="line">Features: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp</span><br><span class="line">CPU implementer: 0x4e</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant: 0x0</span><br><span class="line">CPU part: 0x004</span><br><span class="line">CPU revision: 0</span><br><span class="line">MTS version: 50168445</span><br></pre></td></tr></table></figure><h3 id="DeepStream-Setup"><a href="#DeepStream-Setup" class="headerlink" title="DeepStream Setup"></a>DeepStream Setup</h3><ol><li><p><a href="https://developer.nvidia.com/deepstream-sdk">NVIDIA DeepStream SDK</a>官网下载 <code>deepstream_sdk_v5.0.1_jetson.tbz2</code></p></li><li><p>命令行执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tar -xvf deepstream_sdk_v5.0.1_jetson.tbz2 -C /</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/nvidia/deepstream/deepstream-5.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ./install.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ldconfig</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/2021/07/02/week-1/02.png" alt="02"></p><h3 id="Run-deepstream-app"><a href="#Run-deepstream-app" class="headerlink" title="Run deepstream-app"></a>Run deepstream-app</h3><ol><li><p>导航到示例目录(samples)。</p></li><li><p>输入以下命令以运行参考应用程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> deepstream-app -c &lt;path_to_config_file&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;path_to_config_file&gt;</code>可以在<code>configs/deepstream-app/</code>中找到</p></li><li><p>在源文件目录中找到源码，编译并运行demo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 源文件目录（deepstream-test1）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 都需要make编译，具体请参阅其中的README文档</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/nvidia/deepstream/deepstream-5.0/sources/apps/sample_apps/deepstream-test1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">deepstream_test1_app.c  dstest1_pgie_config.txt  Makefile  README</span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">deepstream-test1-app    deepstream_test1_app.o   Makefile</span><br><span class="line">deepstream_test1_app.c  dstest1_pgie_config.txt  README</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行deepstream-test1-app</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./deepstream-test1-app /opt/nvidia/deepstream/deepstream-5.0/samples/streams/sample_720p.h264</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Reference test application</th><th align="center">Path inside sources directory</th><th>Description</th></tr></thead><tbody><tr><td align="center">Sample test application 1</td><td align="center">apps/sample_apps/deepstream-test1</td><td>Sample of how to use DeepStream elements for a single H.264 stream: filesrc → decode → nvstreammuH264 containerized streamx → nvinfer (primary detector) → nvdsosd → renderer.</td></tr><tr><td align="center">Sample test application 2</td><td align="center">apps/sample_apps/deepstream-test2</td><td>Sample of how to use DeepStream elements for a single H.264 stream: filesrc → decode → nvstreammux → nvinfer (primary detector) → nvtracker → nvinfer (secondary classifier) → nvdsosd → renderer.</td></tr><tr><td align="center">Sample test application 3</td><td align="center">apps/sample_apps/deepstream-test3</td><td>Builds on deepstream-test1 (simple test application 1) to demonstrate how to:Use multiple sources in the pipelineUse a uridecodebin to accept any type of input (e.g. RTSP/File), any GStreamer supported container format, and any codecConfigure Gst-nvstreammux to generate a batch of frames and infer on it for better resource utilizationExtract the stream metadata, which contains useful information about the frames in the batched buffer</td></tr><tr><td align="center">Sample test application 4</td><td align="center">apps/sample_apps/deepstream-test4</td><td>Builds on deepstream-test1 for a single H.264 stream: filesrc, decode, nvstreammux, nvinfer, nvdsosd, renderer to demonstrate how to:Use the Gst-nvmsgconv and Gst-nvmsgbroker plugins in the pipelineCreate NVDS_META_EVENT_MSG type metadata and attach it to the bufferUse NVDS_META_EVENT_MSG for different types of objects, e.g. vehicle and personImplement “copy” and “free” functions for use if metadata is extended through the extMsg field</td></tr><tr><td align="center">Sample test application 5</td><td align="center">apps/sample_apps/deepstream-test5</td><td>Builds on top of deepstream-app. Demonstrates:Use of Gst-nvmsgconv and Gst-nvmsgbroker plugins in the pipeline for multistreamHow to configure Gst-nvmsgbroker plugin from the config file as a sink plugin (for KAFKA, Azure, etc.)How to handle the RTCP sender reports from RTSP servers or cameras and translate the Gst Buffer PTS to a UTC timestamp.For more details refer the RTCP Sender Report callback function <code>test5_rtcp_sender_report_callback()</code> registration and usage in <code>deepstream_test5_app_main.c</code>. GStreamer callback registration with rtpmanager element’s “handle-sync” signal is documented in <code>apps-common/src/deepstream_source_bin.c</code>.</td></tr></tbody></table></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">|-- opt</span><br><span class="line">    |-- nvidia</span><br><span class="line">        |-- deepstream</span><br><span class="line">            |-- deepstream</span><br><span class="line">            |-- deepstream-5.0</span><br><span class="line">                |-- bin</span><br><span class="line">                |-- doc</span><br><span class="line">                |-- lib</span><br><span class="line">                |-- samples</span><br><span class="line">                |   |-- configs</span><br><span class="line">                |   |   |-- deepstream-app</span><br><span class="line">                |   |   |   |-- config_infer_primary.txt#将nvinfer配置为主要检测器</span><br><span class="line">                |   |   |   |-- config_infer_primary_nano.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_carcolor.txt#将nvinfer配置为辅助分类器</span><br><span class="line">                |   |   |   |-- config_infer_secondary_carmake.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_vehicletypes.txt</span><br><span class="line">                |   |   |   |-- iou_config.txt#配置一个低级的IOU跟踪器。</span><br><span class="line">                |   |   |   |-- source12_1080p_dec_infer-resnet_tracker_tiled_display_fp16_tx2.txt</span><br><span class="line">                |   |   |   |-- source1_csi_dec_infer_resnet_int8.txt   #演示一个CSI摄像机作为输入；仅适用于Jetson</span><br><span class="line">                |   |   |   |-- source1_usb_dec_infer_resnet_int8.txt#演示一个USB摄像机作为输入</span><br><span class="line">                |   |   |   |-- source2_csi_usb_dec_infer_resnet_int8.txt</span><br><span class="line">                                #演示30个具有主要推理功能的流解码（仅适用于dGPU和Jetson AGX Xavier平台）</span><br><span class="line">                |   |   |   |-- source30_1080p_dec_infer-resnet_tiled_display_int8.txt </span><br><span class="line">                #演示具有主要推理，对象跟踪和三个不同辅助分类器的四个流解码（仅适用于dGPU和Jetson AGX Xavier平台）</span><br><span class="line">                |   |   |   |-- source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt</span><br><span class="line">                |   |   |   |-- source6_csi_dec_infer_resnet_int8.txt</span><br><span class="line">                |   |   |   |-- source8_1080p_dec_infer-resnet_tracker_tiled_display_fp16_nano.txt</span><br><span class="line">                |   |   |   |-- source8_1080p_dec_infer-resnet_tracker_tiled_display_fp16_tx1.txt</span><br><span class="line">                |   |   |   |-- tracker_config.yml#配置NvDCF跟踪器</span><br><span class="line">                |   |   |-- deepstream-app-trtis</span><br><span class="line">                |   |   |-- tlt_pretrained_models</span><br><span class="line">                |   |-- models</span><br><span class="line">                |   |-- streams</span><br><span class="line">                |   |   |-- sample_1080p_h264.mp4#H264 containerized stream</span><br><span class="line">                |   |   |-- sample_1080p_h265.mp4#H265 containerized stream</span><br><span class="line">                |   |   |-- sample_720p.h264#H264 elementary stream</span><br><span class="line">                |   |   |-- sample_720p.jpg#JPEG image</span><br><span class="line">                |   |   |-- sample_720p.mjpeg#MJPEG stream</span><br><span class="line">                |   |   |-- sample_720p.mp4</span><br><span class="line">                |   |   |-- sample_cam6.mp4#H264 containerized stream(360D camera stream)</span><br><span class="line">                |   |   |-- sample_industrial.jpg</span><br><span class="line">                |   |   |-- sample_qHD.h264</span><br><span class="line">                |   |   |-- sample_qHD.mp4</span><br><span class="line">                |   |   |-- yoga.jpg</span><br><span class="line">                |   |   |-- yoga.mp4</span><br><span class="line">                |   |-- trtis_model_repo</span><br><span class="line">                |-- sources</span><br><span class="line">                    |-- apps</span><br><span class="line">                    |   |-- apps-common</span><br><span class="line">                    |   |   |-- includes</span><br><span class="line">                    |   |-- sample_apps</span><br><span class="line">                    |       |-- deepstream-app#端到端示例演示了4级联神经网络(1个一级检测器和3个二级分类器)的多相机流，并显示平铺输出。</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- deepstream_app.c</span><br><span class="line">                    |       |   |-- deepstream_app.h</span><br><span class="line">                    |       |   |-- deepstream_app_config_parser.c</span><br><span class="line">                    |       |   |-- deepstream_app_main.c</span><br><span class="line">                    |       |-- deepstream-test1#对单一H264视频流，应用filesrc→decode→nvstreammuH264 containerized streamx→nvinfer(主检测器)→nvdsosd→renderer</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                 Builds on deepstream-test1 (simple test application 1) to demonstrate how to:Use multiple sources in the pipelineUse a uridecodebin to accept any type of input (e.g. RTSP/File), any GStreamer supported container format, and any codecConfigure Gst-nvstreammux to generate a batch of frames and infer on it for better resource utilizationExtract the stream metadata, which contains useful information about the frames in the batched buffer   |       |   |-- deepstream-test1-app</span><br><span class="line">                    |       |   |-- deepstream_test1_app.c</span><br><span class="line">                    |       |   |-- deepstream_test1_app.o</span><br><span class="line">                    |       |   |-- dstest1_pgie_config.txt</span><br><span class="line">                    |       |-- deepstream-test2#建立在test1之上，显示额外的属性，如跟踪和二级分类属性。</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- deepstream_test2_app.c</span><br><span class="line">                    |       |   |-- dstest2_pgie_config.txt</span><br><span class="line">                    |       |   |-- dstest2_sgie1_config.txt</span><br><span class="line">                    |       |   |-- dstest2_sgie2_config.txt</span><br><span class="line">                    |       |   |-- dstest2_sgie3_config.txt</span><br><span class="line">                    |       |   |-- dstest2_tracker_config.txt</span><br><span class="line">                    |       |   |-- tracker_config.yml</span><br><span class="line">                    |       |-- deepstream-test3#建立在test1的基础上，显示多个输入源和批处理使用nvstreammuxer。</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- deepstream_test3_app.c</span><br><span class="line">                    |       |   |-- dstest3_pgie_config.txt</span><br><span class="line">                    |       |-nfer_primary.txt</span><br><span class="line">                |   |   |   |-- config_infer_primary_nano.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_carcolor.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_carmake.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_vehicletypes.txt</span><br><span class="line">                |   |   |   |-- iou_config.txt</span><br><span class="line">                |   |   |   |-- source12_1080p_dec_infer-resnet_tracker_tiled_display_fp16_tx2.txt</span><br><span class="line">                |   |   |   |-- source1_csi_dec_infer_resnet_int8.txt</span><br><span class="line">                |   |   |   |-- source1_usb_dec_infer_resnet_int8.txt</span><br><span class="line">                |   |   |   |-- source2_cs- deepstream-test4</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- cfg_amqp.txt</span><br><span class="line">                    |       |   |-- cfg_azure.txt</span><br><span class="line">                    |       |   |-- cfg_kafka.txt</span><br><span class="line">                    |       |   |-- deepstream_test4_app.c</span><br><span class="line">                    |       |   |-- dstest4_msgconv_config.txt</span><br><span class="line">                    |       |   |-- dstest4_pgie_config.txt</span><br><span class="line">                    |       |-- deepstream-test5</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- deepstream_test5_app.h</span><br><span class="line">                    |       |   |-- deepstream_test5_app_main.c</span><br><span class="line">                    |       |   |-- deepstream_utc.c</span><br><span class="line">                    |       |   |-- configs</span><br><span class="line">                    |       |       |-- dstest5_msgconv_sample_config.txt</span><br><span class="line">                    |       |       |-- test5_config_file_src_infer.txt</span><br><span class="line">                    |       |       |-- test5_config_file_src_infer_azure_iotedge.txt</span><br><span class="line">                    |       |       |-- test5_config_file_src_infer_tiler_demux.txt</span><br><span class="line">                    |       |       |-- test5_config_file_src_infer_tracker_sgie.txt</span><br><span class="line">                    |       |       |-- test5_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt</span><br><span class="line">                    |       |       |-- test5_ota_override_config.txt</span><br><span class="line">                    |-- gst-plugins</span><br><span class="line">                    |-- includes</span><br><span class="line">                    |-- libs</span><br><span class="line">                    |-- objectDetector_FasterRCNN</span><br><span class="line">                    |-- objectDetector_SSD</span><br><span class="line">                    |-- objectDetector_Yolo</span><br><span class="line">                    |-- tools</span><br></pre></td></tr></table></figure><p>日志信息：</p><p><img src="/2021/07/02/week-1/04.png" alt="04"><br>结果显示：</p><p><img src="/2021/07/02/week-1/05.png" alt="05"></p><p><img src="/2021/07/02/week-1/08.png" alt="08"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.nvidia.com/metropolis/deepstream/dev-guide/index.html">NVIDIA DeepStream SDK开发指南</a></p><p><a href="https://docs.nvidia.com/metropolis/deepstream/plugin-manual/index.html">NVIDIA DeepStream插件手册</a></p><p><a href="https://docs.nvidia.com/metropolis/deepstream/dev-guide/">NVIDIA DeepStream SDK API参考文档</a></p>]]></content>
    
    
    <summary type="html">Jetson Xavier NX部署 Deepstream</summary>
    
    
    
    <category term="Internship" scheme="http://example.com/categories/Internship/"/>
    
    
    <category term="Jetson" scheme="http://example.com/tags/Jetson/"/>
    
    <category term="Deepstreeam" scheme="http://example.com/tags/Deepstreeam/"/>
    
  </entry>
  
  <entry>
    <title>CMake&amp;Meson 边学边记</title>
    <link href="http://example.com/2021/04/10/cmake-notes/"/>
    <id>http://example.com/2021/04/10/cmake-notes/</id>
    <published>2021-04-10T12:32:42.000Z</published>
    <updated>2021-07-24T06:24:58.207Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="CMake笔记"><a href="#CMake笔记" class="headerlink" title="CMake笔记"></a>CMake笔记</h1><p><strong>一开始是记录CMake的学习，7月份实习用到了Meson，故也记录在了这篇文章中。</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><ul><li>网址：<a href="https://cmake.org/download/">https://cmake.org/download/</a></li></ul><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><ul><li><p>直接安装 <code>apt install cmake</code></p></li><li><p>网址：<a href="https://cmake.org/download/">https://cmake.org/download/</a>     下载对应版本的CMake（32位或者64位）</p></li><li><p>输入以下命令进行解压</p><p><code>    tar -zxvf cmake-3.10.0-rc4-Linux-x86_64.tar.gz</code></p></li><li><p>把解压后的目录改名为：cmake</p><p><code>mv cmake-3.10.0-rc4-Linux-x86_64 cmake</code></p></li><li><p>安装完毕，命令行输入：<code>cmake --version</code>检测是否安装成功</p></li></ul><h2 id="CMake初探"><a href="#CMake初探" class="headerlink" title="CMake初探"></a>CMake初探</h2><p><strong>基本都在我的阿里云服务器上倒腾，环境为Ubuntu 16.04</strong></p><h3 id="CMake基础知识"><a href="#CMake基础知识" class="headerlink" title="CMake基础知识"></a>CMake基础知识</h3><ul><li><p>最低版本</p><ul><li><p><code>CMakeLists.txt</code>的第一行都会写：<code>cmake_minimum_required(VERSION 3.1)</code>，该命令指定了CMake的最低版本是3.1</p></li><li><p>命令名称<code>cmake_minimum_required</code>不区分大小写</p></li><li><p>设置版本范围：<code>cmake_minimum_required(VERSION 3.1...3.12)</code></p></li><li><p>判断CMake版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#该命令表示：如果CMake版本小于3.12，则if块将为true，然后将设置为当前CMake版本</span><br><span class="line">#如果CMake版本高于3.12，if块为假，cmake_minimum_required将被正确执行</span><br><span class="line">if($&#123;CMAKE_VERSION&#125; VERSION_LESS 3.12)     </span><br><span class="line">    cmake_policy(VERSION $&#123;CMAKE_MAJOR_VERSION&#125;.$&#123;CMAKE_MINOR_VERSION&#125;) </span><br><span class="line">endif() </span><br></pre></td></tr></table></figure></li><li><p>注意：如果需要支持非命令行Windows版本则需在上面的if判断加上else分支，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.1)</span><br><span class="line">if($&#123;CMAKE_VERSION&#125; VERSION_LESS 3.12)</span><br><span class="line">    cmake_policy(VERSION $&#123;CMAKE_MAJOR_VERSION&#125;.$&#123;CMAKE_MINOR_VERSION&#125;)</span><br><span class="line">else()</span><br><span class="line">    cmake_policy(VERSION 3.12)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置生成项目名称</p><ul><li><p>命令：<code>project（MyProject）</code>,表示生成的工程名字叫做：<code>MyProject</code></p></li><li><p>命令还可以标识项目支持的语言，写法：<code>project（MyProject[C] [C++]）</code>,不过通常将后面的参数省掉，因为默认支持所有语言</p></li><li><p>使用该指令之后系统会自动创建两个变量：<code>&lt;projectname&gt;_BINARY_DIR</code>  二进制文件保存路径、<code>&lt;projectname&gt;_SOURCE_DIR</code>  源代码路径</p></li><li><p>执行<code>project(MyProject)</code>，就是定义了一个项目的名称为<code>MyProject</code>，对应的就会生成两个变量：<code>_BINARY_DIR</code>和<code>_SOURCE_DIR</code>，但是<code>cmake</code>中其实已经有两个预定义的变量：<code>PROJECT_BINARY_DIR</code> 和 <code>PROJECT_SOURCR_DIR</code></p></li><li><p>关于两个变量是否相同，涉及到是内部构建还是外部构建</p><ul><li><p>内部构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake ./</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>外部构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd ./build</span><br><span class="line">cmake ../</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>内部构建和外部构建的不同在于：<code>cmake </code>的工作目录不同。内部构建会将<code>cmake</code>生成的中间文件和可执行文件放在和项目同一目录；外部构建的话，中间文件和可执行文件会放在<code>build</code>目录</p></li><li><p><code>PROJECT_SOURCE_DIR</code>和<code>_SOURCE_DIR</code>无论内部构建还是外部构建，指向的内容都是一样的，都指向工程的根目录</p></li><li><p><code>PROJECT_BINARY_DIR</code>和<code>_BINARY_DIR</code>指向的相同内容，内部构建的时候指向<code>CMakeLists.txt</code>文件的目录，外部构建指向<code>target</code>编译的目录</p></li></ul></li></ul></li><li><p>生成可执行文件</p><ul><li><p>语法：<code>add_executable(exename srcname)</code></p><blockquote><ul><li>exename:生成的可执行文件的名字</li><li>srcname:原来的源文件</li></ul></blockquote></li><li><p>该命令指定生成可执行文件的名字以及指出需要依赖的源文件的文件名</p></li><li><p>获取文件路径中的所有源文件</p><ul><li>命令：<code>aux_sourcr_directory(&lt;dir&gt; &lt;variable&gt;)</code></li><li>例子：<code>aux_sourcr_directory(. DIR_SRCS)</code>，将当前目录下的源文件名字存放到变量<code>DIR_SRCS</code>里面 ，如果源文件比较多，直接用<code>DIR_SRCS</code>变量即可</li></ul></li><li><p>生成可执行文件：<code>add_executable(Demo $&#123;DIR_SRCS&#125;)</code>，将生成的可执行文件命名为：<code>Demo</code></p></li></ul></li><li><p>生成<code>lib</code>库</p><ul><li><p>命令：<code>add_library(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)</code></p><blockquote><ul><li><code>libname</code>:生成的库文件的名字</li><li><code>[SHARED|STATIC|MODULE]</code>：生成库文件的类型（动态库|静态库|模块）</li><li><code>[EXCLUDE_FROM_ALL]</code>：有这个参数表示该库不会被默认构建</li><li><code>source2 ... sourceN</code>：生成库依赖的源文件，如果源文件比较多，可以使用</li><li><code>aux_sourcr_directory</code>命令获取路径下所有源文件，具体章节参见：<code>CMake</code>初探-&gt;生成可执行文件-&gt;获取路径中所有源文件</li></ul></blockquote></li><li><p>例子：<code>add_library(ALib SHARE alib.cpp)</code></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_executable(demo demo.cpp) # 生成可执行文件</span><br><span class="line">add_library(common STATIC util.cpp) # 生成静态库</span><br><span class="line">add_library(common SHARED util.cpp) # 生成动态库或共享库</span><br></pre></td></tr></table></figure><blockquote><p><code>add_library</code> 默认生成是静态库，通过以上命令生成文件名字，</p><ul><li>在 Linux 下是：<br>demo<br>libcommon.a<br>libcommon.so</li><li>在 Windows 下是：<br>demo.exe<br>common.lib<br>common.dll</li></ul></blockquote><ul><li><p>添加头文件目录</p><ul><li><p>命令1：<code>target_include_directories(&lt;target&gt; [SYSTEM] [BEFORE]   &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]   [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</code></p><blockquote><p>当我们添加子项目之后还需要设置一个<code>include</code>路径，例子：<br>eg:<code>target_include_directories(RigelEditor PUBLIC ./include/rgeditor)</code>，表示给<code>RigelEditor</code> 这个子项目添加一个库文件的路径</p></blockquote></li><li><p>命令2：<code>include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 …])</code></p><blockquote><p>参数解析：</p><ul><li>[AFTER|BEFORE]：指定了要添加路径是添加到原有列表之前还是之后</li><li>[SYSTEM]：若指定了<code>system</code>参数，则把被包含的路径当做系统包含路径来处理</li><li>dir1 [dir2 …]把这些路径添加到<code>CMakeLists</code>及其子目录的<code>CMakeLists</code>的头文件包含项目中<br>相当于<code>g++</code>选项中的-l的参数的作用</li><li>举例：<code>include_directories(&quot;/opt/MATLAB/R2012a/extern/include&quot;)</code></li></ul></blockquote></li></ul><ul><li>两条指令的作用都是讲将<code>include</code>的目录添加到目标区别在于<code>include_directorie</code>s是<code>CMake</code>编译所有目标的目录进行添加，<code>target_include_directories</code>是将<code>CMake</code>编译的指定的特定目标的包含目录进行添加</li></ul></li><li><p>添加需要链接的库文件路径</p><ul><li><p>命令1:<code>target_link_libraries(&lt;target&gt; [item1 [item2 [...]]] [[debug|optimized|general] &lt;item&gt;] ...)</code></p><blockquote><ul><li>作用：为给定的目标设置链接时使用的库（设置要链接的库文件的名称）</li><li>eg:target_link_libraries(MyProject a b.a <a href="http://c.so/">c.so</a>)    //将若干库文件链接到hello中，target_link_libraries里的库文件的顺序符合gcc/g++链接顺序规则，即：被依赖的库放在依赖他的库的后面，如果顺序有错，链接将会报错</li><li>关键字：debug对应于调试配置</li><li>关键字：optimized对应于所有其他的配置类型</li><li>关键字：general对应于所有的配置（该属性是默认值）</li></ul></blockquote></li><li><p>命令2：<code>link_libraries</code></p><blockquote><ul><li>作用：给当前工程链接需要的库文件（全路径）</li><li>eg:<code>link_libraries((&quot;/opt/MATLAB/R2012a/bin/glnxa64/libeng.so&quot;)</code>//必须添加带名字的全路径</li></ul></blockquote></li><li><p>区别：<code>target_link_libraries</code>可以给工程或者库文件设置其需要链接的库文件，而且不需要填写全路径，但是<code>link_libraries</code>只能给工程添加依赖的库，而且必须添加全路径</p></li><li><p>添加需要链接的库文件目录</p><blockquote><ul><li><p>命令：link_directories（添加需要链接的库文件目录）</p></li><li><p>语法：link_directories(directory1 directory2 …)</p></li><li><p>例子：link_directories(“/opt/MATLAB/R2012a/bin/glnxa64”)</p></li></ul></blockquote></li><li><p>指令的区别：指令的前缀带<code>target</code>，表示针对某一个目标进行设置，必须指明设置的目标；<code>include_directories</code>是在编译时用，指明<code>.h</code>文件的路径；<code>link_directoeies</code>是在链接时用的，指明链接库的路径；<code>target_link_libraries</code>是指明链接库的名字，也就是具体谁链接到哪个库。<code>link_libraries</code>不常用，因为必须指明带文件名全路径</p></li></ul></li><li><p>控制目标属性</p><ul><li><p>以上的几条命令的区分都是：是否带<code>target</code>前缀，在<code>CMake</code>里面，一个<code>target</code>有自己的属性集，如果我们没有显示的设置这些<code>target</code>的属性的话，<code>CMake</code>默认是由相关的全局属性来填充<code>target</code>的属性，我们如果需要单独的设置<code>target</code>的属性，需要使用命令：<code>set_target_properties()</code></p></li><li><p>命令格式:</p><blockquote><p>set_target_properties(target1 target2 …<br>PROPERTIES<br>属性名称1  值<br>属性名称2  值<br>…<br>)</p></blockquote></li><li><p>控制编译选项的属性是：<code>COMPILE_FLAGS</code></p></li><li><p>控制链接选项的属性是：<code>LINK_FLAGS</code></p></li><li><p>控制输出路径的属性：<code>EXECUTABLE_OUTPUT_PATH</code>（exe的输出路径）、<code>LIBRARY_OUTPUT_PATH</code>（库文件的输出路径）</p></li><li><p>举例：</p><blockquote><p>set_target_properties(exe<br>PROPERTIES<br>LINK_FLAGS          -static<br>LINK_FLAGS_RELEASE  -s<br>)</p></blockquote><p>这条指令会使得<code>exe</code>这个目标在所有的情况下都采用<code>-static</code>选项，而且在<code>release build</code>的时候<code>-static -s</code>选项。但是这个属性仅仅在<code>exe</code>这个<code>target</code>上面有效</p></li></ul></li></ul><h3 id="Cmake构建示例"><a href="#Cmake构建示例" class="headerlink" title="Cmake构建示例"></a>Cmake构建示例</h3><p>经典的<code>helloworld</code>必须出现啊，首先创建一个<code>main.cpp</code>包含源的文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> parameter_size, <span class="keyword">char</span> **parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = a + <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello word  &quot;</span> &lt;&lt; parameter_size &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们创建一个 <code>CMakeLists.txt</code>同一个目录中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.5)</span><br><span class="line">#项目名称</span><br><span class="line">project(test_cmaka)</span><br><span class="line">#代码路径</span><br><span class="line">aux_source_directory(. DIR_TOOT_SRCS)</span><br><span class="line">#dubug 模式</span><br><span class="line">set (CMAKE_CXX_FLAGS  &quot;$&#123;CMAKE_CXX_FLAGS&#125; -g&quot;)</span><br><span class="line">#将可执行文件放入bin目录</span><br><span class="line">set( EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line">#生成可执行的文件</span><br><span class="line">add_executable(main $&#123;DIR_TOOT_SRCS&#125;)</span><br></pre></td></tr></table></figure><p>文件目录 如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- test_cmake</span><br><span class="line">    |-- main.cpp</span><br><span class="line">    |-- CMakeLists.txt</span><br></pre></td></tr></table></figure><p>现在准备构建我们的应用程序，导航到文件目录下，创建<code>build</code>文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build</span><br></pre></td></tr></table></figure><p>进入<code>build</code>目录，执行外部构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd build</span><br><span class="line"># cmake ../</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- The C compiler identification is GNU 7.5.0</span><br><span class="line">-- The CXX compiler identification is GNU 7.5.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /root/share/C++/test_cmake/build</span><br></pre></td></tr></table></figure><p>再看看目录下的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMakeCache.txt  CMakeFiles  cmake_install.cmake  Makefile</span><br></pre></td></tr></table></figure><p>可以看到成功生成了Makefile，还有一些cmake运行时自动生成的文件<br>然后在终端下输入make并回车,输出以下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanning dependencies of target main</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/main.dir/main.cpp.o</span><br><span class="line">[100%] Linking CXX executable ../bin/main</span><br><span class="line">[100%] Built target main</span><br></pre></td></tr></table></figure><p>此时，文件目录如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-- test_cmake</span><br><span class="line">    |-- bin</span><br><span class="line">    |-- build</span><br><span class="line">    |-- main.cpp</span><br><span class="line">    |-- CMakeLists.txt</span><br></pre></td></tr></table></figure><p>生成的可执行文件在<code>bin</code>目录下，导航到该目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ../bin</span><br><span class="line">./main</span><br></pre></td></tr></table></figure><p>产生预期的输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello word  1 </span><br></pre></td></tr></table></figure><p><code>github</code>上有不错的<code>CMake——examples</code>  链接：<a href="https://github.com/ttroy50/cmake-examples">https://github.com/ttroy50/cmake-examples</a></p><h1 id="Meson笔记"><a href="#Meson笔记" class="headerlink" title="Meson笔记"></a>Meson笔记</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux安装-1"><a href="#Linux安装-1" class="headerlink" title="Linux安装"></a>Linux安装</h3><ul><li><p>Meson基于Python3运行，要求Python版本3.5以上</p></li><li><p>安装依赖 <code>ninja-build</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ninja-build</span><br></pre></td></tr></table></figure></li><li><p>安装<code>Meson</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install meson #root      </span><br><span class="line"></span><br><span class="line">pip3 install --user meson #user 官方推荐</span><br></pre></td></tr></table></figure></li><li><p>也从<code>git</code>下载安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/mesonbuild/meson.git /path/to/sourcedir</span><br></pre></td></tr></table></figure></li></ul><h3 id="Meson构建示例"><a href="#Meson构建示例" class="headerlink" title="Meson构建示例"></a>Meson构建示例</h3><p>依然经典的<code>helloworld</code>，首先创建一个<code>main.c</code>包含源的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello there.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们创建一个 <code>meson.build</code>同一个目录中调用的文中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">project(&#x27;tutorial&#x27;, &#x27;c&#x27;)</span><br><span class="line">executable(&#x27;main&#x27;, &#x27;main.c&#x27;)</span><br></pre></td></tr></table></figure><p>文件目录如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- test_meson</span><br><span class="line">    |-- main.c</span><br><span class="line">    |-- meson.build</span><br></pre></td></tr></table></figure><p>现在准备构建我们的应用程序，导航到文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#构建程序</span><br><span class="line">$ meson build</span><br></pre></td></tr></table></figure><p>创建一个单独的构建目录<code>build</code>来保存所有编译器输出。<code>Meson</code> 与其他一些构建系统的不同之处在于它不允许源代码构建。您必须始终创建一个单独的构建目录。常见的约定是将默认构建目录放在顶级源目录的子目录中</p><p>当 <code>Meson</code> 运行时，它会打印以下输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">The Meson build system</span><br><span class="line">Version: 0.58.1</span><br><span class="line">Source dir: /root/share/C++/test_meson</span><br><span class="line">Build dir: /root/share/C++/test_meson/build</span><br><span class="line">Build type: native build</span><br><span class="line">Project name: tutorial</span><br><span class="line">Project version: undefined</span><br><span class="line">C compiler for the host machine: cc (gcc 7.5.0 &quot;cc (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;)</span><br><span class="line">C linker for the host machine: cc ld.bfd 2.30</span><br><span class="line">Host machine cpu family: x86_64</span><br><span class="line">Host machine cpu: x86_64</span><br><span class="line">Build targets in project: 1</span><br></pre></td></tr></table></figure><p>现在已经准备好构建我们的代码了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd buildd</span><br><span class="line">$ ninja</span><br></pre></td></tr></table></figure><p>如果您的 <code>Meson</code> 版本高于 <code>0.55.0</code>，您可以使用新的后端不可知构建命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd build</span><br><span class="line">$ meson compile</span><br></pre></td></tr></table></figure><p>一旦构建了可执行文件，我们就可以运行它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure><p>这会产生预期的输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello there.</span><br></pre></td></tr></table></figure><p>​    </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mubu.com/doc/t1VDCEn4O0#o-17f166a665726b18d">https://mubu.com/doc/t1VDCEn4O0#o-17f166a665726b18d</a></p><p><a href="https://cmake.org/documentation">https://cmake.org/documentation</a></p><p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">https://cmake.org/cmake/help/latest/guide/tutorial/index.html</a></p><p><a href="https://mesonbuild.com/">https://mesonbuild.com/</a></p>]]></content>
    
    
    <summary type="html">学习生产力工具CMake、Meson</summary>
    
    
    
    <category term="Tools" scheme="http://example.com/categories/Tools/"/>
    
    
    <category term="CMake" scheme="http://example.com/tags/CMake/"/>
    
    <category term="Meson" scheme="http://example.com/tags/Meson/"/>
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="http://example.com/2021/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2021-02-24T12:16:44.000Z</published>
    <updated>2021-07-23T12:23:45.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bind-函数重难点解析"><a href="#bind-函数重难点解析" class="headerlink" title="bind 函数重难点解析"></a>bind 函数重难点解析</h1><h2 id="bind-函数如何选择绑定地址"><a href="#bind-函数如何选择绑定地址" class="headerlink" title="bind 函数如何选择绑定地址"></a>bind 函数如何选择绑定地址</h2><p>bind 函数的基本用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bindaddr</span>;</span></span><br><span class="line">bindaddr.sin_family = AF_INET;</span><br><span class="line">bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">bindaddr.sin_port = htons(<span class="number">3000</span>);</span><br><span class="line"><span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;bindaddr, <span class="keyword">sizeof</span>(bindaddr)) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind listen socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 bind 的地址我们使用了一个宏叫 <strong>INADDR_ANY</strong> ，关于这个宏的解释如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">If an application does <span class="keyword">not</span> care what local address is assigned, </span><br><span class="line">specify the constant value INADDR_ANY <span class="keyword">for</span> an IPv4 local address</span><br><span class="line"><span class="keyword">or</span> the constant value in6addr_any <span class="keyword">for</span> an IPv6 local address </span><br><span class="line">in the sa_data member of the name parameter. This allows the </span><br><span class="line">underlying service provider to use any appropriate network address,</span><br><span class="line"><span class="function">potentially simplifying application programming in the presence of </span></span><br><span class="line"><span class="function">multihomed <span class="title">hosts</span> <span class="params">(that is, hosts that have more than one network </span></span></span><br><span class="line"><span class="params"><span class="function">interface <span class="keyword">and</span> address)</span>.</span></span><br></pre></td></tr></table></figure><p>意译一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果应用程序不关心bind绑定的ip地址，可以使用INADDR_ANY(如果是IPv6，</span><br><span class="line">则对应in6addr_any)，这样底层的（协议栈）服务会自动选择一个合适的ip地址，</span><br><span class="line">这样使在一个有多个网卡机器上选择ip地址问题变得简单。</span><br></pre></td></tr></table></figure><p>也就是说 <strong>INADDR_ANY</strong> 相当于地址 <strong>0.0.0.0</strong>。可能读者还是不太明白我想表达什么。这里我举个例子，假设我们在一台机器上开发一个服务器程序，使用 bind 函数时，我们有多个ip 地址可以选择。首先，这台机器对外访问的ip地址是<strong>120.55.94.78</strong>，这台机器在当前局域网的地址是<strong>192.168.1.104</strong>；同时这台机器有本地回环地址<strong>127.0.0.1</strong>。</p><p>如果你指向本机上可以访问，那么你 bind 函数中的地址就可以使用<strong>127.0.0.1</strong>; 如果你的服务只想被局域网内部机器访问，bind 函数的地址可以使用<strong>192.168.1.104</strong>；如果 希望这个服务可以被公网访问，你就可以使用地址<strong>0.0.0.0</strong>或 <strong>INADDR_ANY</strong>。</p><h2 id="bind-函数端口号问题"><a href="#bind-函数端口号问题" class="headerlink" title="bind 函数端口号问题"></a>bind 函数端口号问题</h2><p>网络通信程序的基本逻辑是客户端连接服务器，即从客户端的<strong>地址:端口</strong>连接到服务器<strong>地址:端口</strong>上，以 4.2 小节中的示例程序为例，服务器端的端口号使用 3000，那客户端连接时的端口号是多少呢？TCP 通信双方中一般服务器端端口号是固定的，而客户端端口号是连接发起时由操作系统随机分配的（不会分配已经被占用的端口）。端口号是一个 C short 类型的值，其范围是0～65535，知道这点很重要，所以我们在编写压力测试程序时，由于端口数量的限制，在某台机器上网卡地址不变的情况下压力测试程序理论上最多只能发起六万五千多个连接。注意我说的是理论上，在实际情况下，由于当时的操作系统很多端口可能已经被占用，实际可以使用的端口比这个更少，例如，一般规定端口号在1024以下的端口是保留端口，不建议用户程序使用。而对于 Windows 系统，MSDN 甚至明确地说：</p><blockquote><p>On Windows Vista and later, the dynamic client port range is a value between 49152 and 65535. This is a change from Windows Server 2003 and earlier where the dynamic client port range was a value between 1025 and 5000. Vista 及以后的Windows，可用的动态端口范围是49152～65535，而 Windows Server及更早的系统，可以的动态端口范围是1025~5000。（你可以通过修改注册表来改变这一设置，参考网址：<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-bind%EF%BC%89">https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-bind）</a></p></blockquote><p>如果将 bind 函数中的端口号设置成0，那么操作系统会随机给程序分配一个可用的侦听端口，当然服务器程序一般不会这么做，因为服务器程序是要对外服务的，必须让客户端知道确切的ip地址和端口号。</p><p>很多人觉得只有服务器程序可以调用 bind 函数绑定一个端口号，其实不然，在一些特殊的应用中，我们需要客户端程序以指定的端口号去连接服务器，此时我们就可以在客户端程序中调用 bind 函数绑定一个具体的端口。</p><p>我们用代码来实际验证一下上路所说的，为了能看到连接状态，我们将客户端和服务器关闭socket的代码注释掉，这样连接会保持一段时间。</p><ul><li><strong>情形一：客户端代码不绑定端口</strong></li></ul><p>修改后的服务器代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP服务器通信基本流程</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个侦听socket</span></span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create listen socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化服务器地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bindaddr</span>;</span></span><br><span class="line">    bindaddr.sin_family = AF_INET;</span><br><span class="line">    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    bindaddr.sin_port = htons(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;bindaddr, <span class="keyword">sizeof</span>(bindaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind listen socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.启动侦听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, SOMAXCONN) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;listen error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录所有客户端连接的容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; clientfds;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clientaddrlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="comment">//4. 接受客户端连接</span></span><br><span class="line">        <span class="keyword">int</span> clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);</span><br><span class="line">        <span class="keyword">if</span> (clientfd != <span class="number">-1</span>)</span><br><span class="line">        &#123;             </span><br><span class="line">            <span class="keyword">char</span> recvBuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="comment">//5. 从客户端接受数据</span></span><br><span class="line">            <span class="keyword">int</span> ret = recv(clientfd, recvBuf, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data from client, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">//6. 将收到的数据原封不动地发给客户端</span></span><br><span class="line">                ret = send(clientfd, recvBuf, <span class="built_in">strlen</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret != <span class="built_in">strlen</span>(recvBuf))</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data to client successfully, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//close(clientfd);</span></span><br><span class="line">            clientfds.push_back(clientfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.关闭侦听socket</span></span><br><span class="line">    close(listenfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的客户端代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP客户端通信基本流程</span></span><br><span class="line"><span class="comment"> * zhangyl 2018.12.13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_ADDRESS <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT     3000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEND_DATA       <span class="meta-string">&quot;helloworld&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个socket</span></span><br><span class="line">    <span class="keyword">int</span> clientfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (clientfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create client socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class="line">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    <span class="keyword">if</span> (connect(clientfd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;connect socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 向服务器发送数据</span></span><br><span class="line">    <span class="keyword">int</span> ret = send(clientfd, SEND_DATA, <span class="built_in">strlen</span>(SEND_DATA), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="built_in">strlen</span>(SEND_DATA))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data successfully, data: &quot;</span> &lt;&lt; SEND_DATA &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 从客户端收取数据</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ret = recv(clientfd, recvBuf, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data successfully, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data error, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 关闭socket</span></span><br><span class="line">    <span class="comment">//close(clientfd);</span></span><br><span class="line">    <span class="comment">//这里仅仅是为了让客户端程序不退出</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将程序编译好后（编译方法和上文一样），我们先启动server，再启动三个客户端。然后通过 <strong>lsof</strong> 命令查看当前机器上的 TCP 连接信息，为了更清楚地显示结果，已经将不相关的连接信息去掉了，结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsof -i -Pn</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">server   1445 root    3u  IPv4  21568      0t0  TCP *:3000 (LISTEN)</span><br><span class="line">server   1445 root    4u  IPv4  21569      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40818 (ESTABLISHED)</span><br><span class="line">server   1445 root    5u  IPv4  21570      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40820 (ESTABLISHED)</span><br><span class="line">server   1445 root    6u  IPv4  21038      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40822 (ESTABLISHED)</span><br><span class="line">client   1447 root    3u  IPv4  21037      0t0  TCP 127.0.0.1:40818-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class="line">client   1448 root    3u  IPv4  21571      0t0  TCP 127.0.0.1:40820-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class="line">client   1449 root    3u  IPv4  21572      0t0  TCP 127.0.0.1:40822-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>上面的结果显示，<strong>server</strong> 进程（进程 ID 是 <strong>1445</strong>）在 <strong>3000</strong> 端口开启侦听，有三个 <strong>client</strong> 进程（进程 ID 分别是<strong>1447</strong>、<strong>1448</strong>、<strong>1449</strong>）分别通过端口号 <strong>40818</strong>、<strong>40820</strong>、<strong>40822</strong> 连到 <strong>server</strong> 进程上的，作为客户端的一方，端口号是系统随机分配的。</p><ul><li><p><strong>情形二：客户端绑定端口号 0</strong></p><p>服务器端代码保持不变，我们修改下客户端代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP服务器通信基本流程</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_ADDRESS <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT     3000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEND_DATA       <span class="meta-string">&quot;helloworld&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//1.创建一个socket</span></span><br><span class="line">  <span class="keyword">int</span> clientfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (clientfd == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create client socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bindaddr</span>;</span></span><br><span class="line">  bindaddr.sin_family = AF_INET;</span><br><span class="line">  bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  <span class="comment">//将socket绑定到0号端口上去</span></span><br><span class="line">  bindaddr.sin_port = htons(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bind(clientfd, (struct sockaddr *)&amp;bindaddr, <span class="keyword">sizeof</span>(bindaddr)) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.连接服务器</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">  serveraddr.sin_family = AF_INET;</span><br><span class="line">  serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class="line">  serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">  <span class="keyword">if</span> (connect(clientfd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr)) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;connect socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3. 向服务器发送数据</span></span><br><span class="line">  <span class="keyword">int</span> ret = send(clientfd, SEND_DATA, <span class="built_in">strlen</span>(SEND_DATA), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret != <span class="built_in">strlen</span>(SEND_DATA))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data successfully, data: &quot;</span> &lt;&lt; SEND_DATA &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4. 从客户端收取数据</span></span><br><span class="line">  <span class="keyword">char</span> recvBuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  ret = recv(clientfd, recvBuf, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data successfully, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data error, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5. 关闭socket</span></span><br><span class="line">  <span class="comment">//close(clientfd);</span></span><br><span class="line">  <span class="comment">//这里仅仅是为了让客户端程序不退出</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      sleep(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们再次编译客户端程序，并启动三个 <strong>client</strong> 进程，然后用 <strong>lsof</strong> 命令查看机器上的 TCP 连接情况，结果如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># lsof -i -Pn</span></span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">server   1593 root    3u  IPv4  21807      0t0  TCP *:3000 (LISTEN)</span><br><span class="line">server   1593 root    4u  IPv4  21808      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:44220 (ESTABLISHED)</span><br><span class="line">server   1593 root    5u  IPv4  19311      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:38990 (ESTABLISHED)</span><br><span class="line">server   1593 root    6u  IPv4  21234      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:42365 (ESTABLISHED)</span><br><span class="line">client   1595 root    3u  IPv4  22626      0t0  TCP 127.0.0.1:44220-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class="line">client   1611 root    3u  IPv4  21835      0t0  TCP 127.0.0.1:38990-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class="line">client   1627 root    3u  IPv4  21239      0t0  TCP 127.0.0.1:42365-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>通过上面的结果，我们发现三个 <strong>client</strong> 进程使用的端口号仍然是系统随机分配的，也就是说绑定 <strong>0</strong> 号端口和没有绑定效果是一样的。</p><ul><li><p><strong>情形三：客户端绑定一个固定端口</strong></p><p>我们这里使用 <strong>20000</strong> 端口，当然读者可以根据自己的喜好选择，只要保证所选择的端口号当前没有被其他程序占用即可，服务器代码保持不变，客户端绑定代码中的端口号从 <strong>0</strong> 改成 <strong>20000</strong>。这里为了节省篇幅，只贴出修改处的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bindaddr</span>;</span></span><br><span class="line">bindaddr.sin_family = AF_INET;</span><br><span class="line">bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"><span class="comment">//将socket绑定到20000号端口上去</span></span><br><span class="line">bindaddr.sin_port = htons(<span class="number">20000</span>);</span><br><span class="line"><span class="keyword">if</span> (bind(clientfd, (struct sockaddr *)&amp;bindaddr, <span class="keyword">sizeof</span>(bindaddr)) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次重新编译程序，先启动一个客户端后，我们看到此时的 TCP 连接状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# lsof -i -Pn</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">server   1676 root    3u  IPv4  21933      0t0  TCP *:3000 (LISTEN)</span><br><span class="line">server   1676 root    4u  IPv4  21934      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:20000 (ESTABLISHED)</span><br><span class="line">client   1678 root    3u  IPv4  21336      0t0  TCP 127.0.0.1:20000-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>通过上面的结果，我们发现 <strong>client</strong> 进程确实使用 <strong>20000</strong> 号端口连接到 <strong>server</strong> 进程上去了。这个时候如果我们再开启一个 <strong>client</strong> 进程，我们猜想由于端口号 <strong>20000</strong> 已经被占用，新启动的 <strong>client</strong> 会由于调用 <strong>bind</strong> 函数出错而退出，我们实际验证一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# ./client </span><br><span class="line">bind socket error.</span><br><span class="line">[root@localhost testsocket]#</span><br></pre></td></tr></table></figure><p>结果确实和我们预想的一样。</p></li></ul><p>在技术面试的时候，有时候面试官会问 TCP 网络通信的客户端程序中的 socket 是否可以调用 bind 函数，相信读到这里，聪明的读者已经有答案了。</p><p>另外，Linux 的 <strong>nc</strong> 命令有个 <strong>-p</strong> 选项（字母 <strong>p</strong> 是小写），这个选项的作用就是 <strong>nc</strong> 在模拟客户端程序时，可以使用指定端口号连接到服务器程序上去，实现原理相信读者也明白了。我们还是以上面的服务器程序为例，这个我们不用我们的 <strong>client</strong> 程序，改用 <strong>nc</strong> 命令来模拟客户端。在 <strong>shell</strong> 终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# nc -v -p 9999 127.0.0.1 3000</span><br><span class="line">Ncat: Version 6.40 ( http://nmap.org/ncat )</span><br><span class="line">Ncat: Connected to 127.0.0.1:3000.</span><br><span class="line">My name is zhangxf</span><br><span class="line">My name is zhangxf</span><br></pre></td></tr></table></figure><p><strong>-v</strong> 选项表示输出 <strong>nc</strong> 命令连接的详细信息，这里连接成功以后，会输出“**Ncat: Connected to 127.0.0.1:3000.**” 提示已经连接到服务器的 <strong>3000</strong> 端口上去了。</p><p><strong>-p</strong> 选项的参数值是 <strong>9999</strong> 表示，我们要求 <strong>nc</strong> 命令本地以端口号 <strong>9999</strong> 连接服务器，注意不要与端口号 <strong>3000</strong> 混淆，<strong>3000</strong> 是服务器的侦听端口号，也就是我们的连接的目标端口号，<strong>9999</strong> 是我们客户端使用的端口号。我们用 <strong>lsof</strong> 命令来验证一下我们的 <strong>nc</strong> 命令是否确实以 <strong>9999</strong> 端口号连接到 <strong>server</strong> 进程上去了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# lsof -i -Pn</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">server   1676 root    3u  IPv4  21933      0t0  TCP *:3000 (LISTEN)</span><br><span class="line">server   1676 root    7u  IPv4  22405      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:9999 (ESTABLISHED)</span><br><span class="line">nc       2005 root    3u  IPv4  22408      0t0  TCP 127.0.0.1:9999-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>结果确实如我们期望的一致。</p><p>当然，我们用 <strong>nc</strong> 命令连接上 <strong>server</strong> 进程以后，我们还给服务器发了一条消息”<strong>My name is zhangxf</strong>“，<strong>server</strong> 程序收到消息后把这条消息原封不动地返还给我们，以下是 <strong>server</strong> 端运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# ./server   </span><br><span class="line">recv data from client, data: My name is zhangxf</span><br><span class="line"></span><br><span class="line">send data to client successfully, data: My name is zhangxf</span><br></pre></td></tr></table></figure><p>关于 <strong>lsof</strong> 和 <strong>nc</strong> 命令我们会在后面的系列文章中详细讲解。</p><p>参考：<a href="https://balloonwj.github.io/cpp-guide-web/articles/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/bind%E5%87%BD%E6%95%B0%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90.html">https://balloonwj.github.io/cpp-guide-web/articles/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/bind%E5%87%BD%E6%95%B0%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90.html</a></p>]]></content>
    
    
    <summary type="html">学习Socket网络编程</summary>
    
    
    
    <category term="Tools" scheme="http://example.com/categories/Tools/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Socket" scheme="http://example.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm</title>
    <link href="http://example.com/2021/02/21/Algorithm/"/>
    <id>http://example.com/2021/02/21/Algorithm/</id>
    <published>2021-02-21T13:32:33.000Z</published>
    <updated>2021-08-02T14:12:29.474Z</updated>
    
    <content type="html"><![CDATA[<p>整理分类做过的 <code>leetcode</code>，好记性不如烂笔头啊~</p><p>[TOC]</p><h1 id="滑动窗口-双指针"><a href="#滑动窗口-双指针" class="headerlink" title="滑动窗口/双指针"></a>滑动窗口/双指针</h1><p><strong>最短或最长的子串  最多可变k次</strong></p><h2 id="LC-3-无重复字符的最长子串"><a href="#LC-3-无重复字符的最长子串" class="headerlink" title="LC-3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LC-3. 无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li><li></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （一）</span></span><br><span class="line"><span class="comment"> * 这里可以建立一个 HashMap，建立每个字符和其最后出现位置之间的映射</span></span><br><span class="line"><span class="comment"> * 然后定义两个变量 res 和 left，其中 res 用来记录最长无重复子串的长度</span></span><br><span class="line"><span class="comment"> * left 指向该无重复子串左边的起始位置的前一个，所以初始化就是 -1</span></span><br><span class="line"><span class="comment"> * 然后遍历整个字符串，对于每一个遍历到的字符，如果该字符已经在 HashMap 中存在了，</span></span><br><span class="line"><span class="comment"> * 并且如果其映射值大于 left 的话，那么更新 left 为当前映射值。然后映射值更新为当前坐标i，</span></span><br><span class="line"><span class="comment"> * 这样保证了 left 始终为当前边界的前一个位置，然后计算窗口长度的时候，直接用 i-left 即可，</span></span><br><span class="line"><span class="comment"> * 用来更新结果 res。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">-1</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(s[i]) &amp;&amp; m[s[i]] &gt; left) &#123;</span><br><span class="line">                left = m[s[i]];  </span><br><span class="line">            &#125;</span><br><span class="line">            m[s[i]] = i;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - left);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面这种解法使用了 <code>HashSet</code>，核心算法和上面的很类似，把出现过的字符都放入<code>HashSet</code>中，遇到 <code>HashSet </code>中没有的字符就加入<code> HashSet</code> 中并更新结果 <code>res</code>，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （二）</span></span><br><span class="line"><span class="comment"> * 下面这种解法使用了 HashSet，核心算法和上面的很类似，</span></span><br><span class="line"><span class="comment"> * 把出现过的字符都放入 HashSet 中，遇到 HashSet 中没有的字符就加入 HashSet</span></span><br><span class="line"><span class="comment"> * 并更新结果 res，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, res=<span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">find</span>(s[i])!=st.<span class="built_in">end</span>())&#123;</span><br><span class="line">                st.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">            res=<span class="built_in">max</span>(res,i-left+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-76-最小覆盖子串"><a href="#LC-76-最小覆盖子串" class="headerlink" title="LC-76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">LC-76. 最小覆盖子串</a></h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p> <strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p>这道题给了我们一个原字符串<code>s</code>，还有一个目标字符串<code>t</code>，让在<code>s</code>中找到一个最短的子串，使得其包含了<code>t</code>中的所有的字母，并且限制了时间复杂度为<code> O(n)</code>。这道题的要求是要在<code>O(n) </code>的时间度里实现找到这个最小窗口字串，暴力搜索 <code>Brute Force </code>肯定是不能用的，因为遍历所有的子串的时间复杂度是平方级的。那么来想一下，时间复杂度卡的这么严，说明必须在一次遍历中完成任务，当然遍历若干次也是<code> O(n)</code>，但不一定有这个必要，尝试就一次遍历拿下！那么再来想，既然要包含T中所有的字母，那么对于T中的每个字母，肯定要快速查找是否在子串中，既然总时间都卡在了<code> O(n)</code>，肯定不想在这里还浪费时间，就用空间换时间（也就算法题中可以这么干了，七老八十的富翁就算用大别野也换不来时间啊。依依东望，望的就是时间呐），使用<code> HashMap</code>，建立T中每个字母与其出现次数之间的映射。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * step1: 确定右边界</span></span><br><span class="line"><span class="comment"> * 先用 HashMap 统计好 t 串中字母的，再遍历 s 串，对于 s 中的每个字母</span></span><br><span class="line"><span class="comment"> * 都将 HashMap 中的映射值减1，如果减1后的映射值仍大于等于0，说明当前遍历到的字母是 t 串中的字母</span></span><br><span class="line"><span class="comment"> * 使用 cnt++ 记录。当cnt 和 t 串字母个数相等时，说明此时的窗口已经包含了 t 串中的所有字母</span></span><br><span class="line"><span class="comment"> * step2: 收缩左边界</span></span><br><span class="line"><span class="comment"> * 由于遍历的时候，映射值减了1，所以此时去除字母的时候，就要把减去的1加回来，</span></span><br><span class="line"><span class="comment"> * 此时如果加1后的值大于0了，说明当前遍历到的字母是 t 串中的字母，</span></span><br><span class="line"><span class="comment"> * 那么 cnt 值就要减1了，然后移动左边界left</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; letterCnt;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++letterCnt[c];         <span class="comment">//遍历t</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--letterCnt[s[i]] &gt;= <span class="number">0</span>) ++cnt;   <span class="comment">//--letterCnt[s[i]] &gt;= 0，s[i]在t中</span></span><br><span class="line">            <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                    res = s.<span class="built_in">substr</span>(left, minLen); <span class="comment">//从left开始，长度为minLen的字符串</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收缩左边界 ++letterCnt[s[left]] &gt; 0， 0-&gt;1 该元素在t中，</span></span><br><span class="line">                <span class="keyword">if</span> (++letterCnt[s[left]] &gt; <span class="number">0</span>) --cnt;   </span><br><span class="line">                <span class="comment">//因为不在t中的本来为0，先减去，现在再增加，最终还是0.</span></span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="pa-3-寻找最靠左的匹配子串"><a href="#pa-3-寻找最靠左的匹配子串" class="headerlink" title="pa-3.寻找最靠左的匹配子串"></a><a href="https://www.papamelon.com/problem/3">pa-3.寻找最靠左的匹配子串</a></h2><p>给定一个字符串$ A,$ 长度为 $N$，$1 \leq N \leq 2*10^5$，下标从 0 开始标号，仅包含 0 到 9 这十种字符。</p><p>再给定另一个字符串 $B$，长度为 M，$1 \leq M \leq 2*10^5$，下标从 0 开始标号，也是仅包含 0 到 9 这十种字符。</p><p>例如以下字符串就是一个合法的 A或 B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">066465353473034515</span><br></pre></td></tr></table></figure><p>现在我们要在 A寻找一个连续的子串 s，使得 s包含 B中出现的所有字符，且要保证 s的<strong>长度尽可能短</strong>。如果存在多个符合上述条件的 s，<strong>返回最靠左</strong>的那个。</p><p>例如:</p><ul><li>B串：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3314</span><br></pre></td></tr></table></figure><ul><li>A串：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">563145633</span><br></pre></td></tr></table></figure><p>子串 A[2:7]为 <code>314563</code>，包含了 B串中出现的 <code>3</code>, <code>3</code>, <code>1</code>, <code>4</code>。</p><p>子串 A[3:8]为 <code>145633</code>，也包含了 B串中出现的 <code>3</code>, <code>3</code>, <code>1</code>, <code>4</code>。</p><p>两个子串长度一样，而前者更靠左，因此前者就是我们要找的答案。</p><p><strong>输入</strong></p><ul><li>每组测试数据的第一行是整数 T，$1 \leq T \leq 1000$，表示接下来有 T对 A, B串</li><li>接下来有 $2*T$行，每两行分别表示一对 A串和 B串</li><li>A<em>A</em> 串长度为 N，$1 \leq N \leq 2*10^5  $</li><li>B<em>B</em> 串长度为 M，$1 \leq M \leq 2*10^5  $</li><li>一组测试数据中字符总数为 C，$2*T \leq C \leq 10^6$</li></ul><p><strong>输出</strong></p><ul><li>输出 T行，每行两个整数，用空格分割，表示 A的子串下标</li><li>如果不存在这样的合法子串，输出 <code>-1 -1</code></li></ul><p>样例 1</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">563145633</span><br><span class="line">3314</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>样例 2</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">678</span><br><span class="line">123</span><br><span class="line">12345</span><br><span class="line">1233</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 -1</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （一）</span></span><br><span class="line"><span class="comment"> * 核心算法继承LC-76，先确定右边界再收缩左边界</span></span><br><span class="line"><span class="comment"> * 需要注意输入输出的练习</span></span><br><span class="line"><span class="comment"> * if else规范书写，一个小bug调式了好久</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s, t;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++mp[c];        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--mp[s[i]] &gt;= <span class="number">0</span>) ++cnt;   </span><br><span class="line">            <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                    res.<span class="built_in">clear</span>();</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;left,left+minLen<span class="number">-1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++mp[s[left]] &gt; <span class="number">0</span>) --cnt;   </span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-1</span> &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; res[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>  &lt;&lt; res[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">Solution</span>().<span class="built_in">minWindow</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （二）</span></span><br><span class="line"><span class="comment"> * 核心算法继承LC-76，</span></span><br><span class="line"><span class="comment"> * 代码稍微简洁，逻辑不变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s, t;</span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++mp[c];         </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--mp[s[i]] &gt;= <span class="number">0</span>) ++cnt;   </span><br><span class="line">        <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                res.<span class="built_in">clear</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;left,left+minLen<span class="number">-1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++mp[s[left]] &gt; <span class="number">0</span>) --cnt;   </span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return res;</span></span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-1</span> &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; res[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>  &lt;&lt; res[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LC-1-两数之和"><a href="#LC-1-两数之和" class="headerlink" title="LC-1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">LC-1. 两数之和</a></h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em>target</em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （一）</span></span><br><span class="line"><span class="comment"> * 笨方法</span></span><br><span class="line"><span class="comment"> * 最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</span></span><br><span class="line"><span class="comment"> * 当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，</span></span><br><span class="line"><span class="comment"> * 因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(target== nums[i]+nums[j])&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （二）</span></span><br><span class="line"><span class="comment"> * 注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，</span></span><br><span class="line"><span class="comment"> * 能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</span></span><br><span class="line"><span class="comment"> * 使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)。</span></span><br><span class="line"><span class="comment"> * 这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，</span></span><br><span class="line"><span class="comment"> * 即可保证不会让 x 和自己匹配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(target-nums[i])!=mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(mp.<span class="built_in">find</span>(target-nums[i])-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mp.insert(pair&lt;int, int&gt;(nums[i], i));</span></span><br><span class="line">            mp[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （三）再精简一下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, m[target - nums[i]]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-15-三数之和"><a href="#LC-15-三数之和" class="headerlink" title="LC-15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">LC-15. 三数之和</a></h2><p>难度中等3545收藏分享切换为英文接收动态反馈</p><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序+双指针</span></span><br><span class="line"><span class="comment"> * 固定第一个数，转化为求两数之和</span></span><br><span class="line"><span class="comment"> * 特别注意相邻元素去重</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">3</span>)   <span class="keyword">return</span> &#123;&#125;;          <span class="comment">// 特判</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;res;            <span class="comment">// 保存结果（所有不重复的三元组）</span></span><br><span class="line">        std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// 排序（默认递增）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)      <span class="comment">// 固定第一个数，转化为求两数之和</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)  <span class="keyword">return</span> res; <span class="comment">// 第一个数大于 0，后面都是递增正数，不可能相加为零</span></span><br><span class="line">            <span class="comment">// 去重：如果此数已经选取过，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 双指针在nums[i]后面的区间中寻找和为0-nums[i]的另外两个数</span></span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] &gt; -nums[i])</span><br><span class="line">                    right--;    <span class="comment">// 两数之和太大，右指针左移</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; -nums[i])</span><br><span class="line">                    left++;     <span class="comment">// 两数之和太小，左指针右移</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 找到一个和为零的三元组，添加到结果中，左右指针内缩，继续寻找</span></span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="comment">// 去重：第二个数和第三个数也不重复选取</span></span><br><span class="line">                    <span class="comment">// 例如：[-4,1,1,1,2,3,3,3], i=0, left=1, right=5</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">-1</span>])  left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>])    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-40-组合总和-II"><a href="#LC-40-组合总和-II" class="headerlink" title="LC-40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">LC-40. 组合总和 II</a></h2><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,2,2],</span><br><span class="line">[5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回溯+剪枝</span></span><br><span class="line"><span class="comment"> * 特别注意相邻元素去重</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; target-candidates[i] &gt;= <span class="number">0</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; index &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//处理节点</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            <span class="built_in">backtrack</span>(candidates, target-candidates[i], i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯，撤销处理结果</span></span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//对candidates先排序</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="LC-122-买卖股票的最佳时机-II"><a href="#LC-122-买卖股票的最佳时机-II" class="headerlink" title="LC-122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LC-122. 买卖股票的最佳时机 II</a></h2><p>难度简单1290收藏分享切换为英文接收动态反馈</p><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= prices[i] &lt;= 10^4</code></li></ul><h2 id="pa-9-套娃"><a href="#pa-9-套娃" class="headerlink" title="pa-9.套娃"></a><a href="https://www.papamelon.com/problem/9">pa-9.套娃</a></h2><p>小棒瓜瓜有 n个套娃，设第 i个套娃的体积为$ v_i$，大套娃可以套住小套娃，同时要满足以下条件：</p><ul><li>一个大套娃想要套住另一个小套娃，体积至少是其 3 倍；例如大套娃体积为 10，小套娃体积为 3，前者是后者的 3.333… 倍，可以套住</li><li>一个大套娃只能套住一个小套娃，一旦套住后，小套娃不能再套其他更小的套娃，也就是说不能继续嵌套下去</li><li>当大套娃套住小套娃后，小套娃不再可见</li></ul><p>现在我们要帮小棒瓜瓜选择一种最优的套娃方案，使得最终可见的套娃数量最少。</p><p>输入</p><ul><li>第一行输入整数 T, $1 \leq T \leq 1000$，表示接下来有 T组数据</li><li>接下来有 T行，每行表示一组套娃的信息</li><li>对于每组套娃，第一个整数是 n，表示套娃数量，$1 \leq n \leq 600$；后面跟着 n个正整数，用空格分隔，表示每个套娃的体积，第 i个整数为$ v_i$, $1 \leq v_i \leq 10000$</li></ul><p>输出</p><ul><li>输出 T行，每行一个整数，表示 T组套娃经过操作，可见套娃的最小数量</li></ul><p>样例 1</p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 1 3 7</span><br><span class="line">3 1 2 3</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits.stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS/BFS"></a>DFS/BFS</h1><h1 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h1><h2 id="LC-5-最长回文子串"><a href="#LC-5-最长回文子串" class="headerlink" title="LC-5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">LC-5. 最长回文子串</a></h2><p>难度中等3874收藏分享切换为英文接收动态反馈</p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= s.length &lt;= 1000</code></p></li><li><p><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （一）中心扩展法</span></span><br><span class="line"><span class="comment"> * 由于回文串的长度可奇可偶，比如 “bob” 是奇数形式的回文，”noon” 就是偶数形式的回文，</span></span><br><span class="line"><span class="comment"> * 两种形式的回文都要搜索，对于奇数形式的，我们就从遍历到的位置为中心，向两边进行扩散，</span></span><br><span class="line"><span class="comment"> * 对于偶数情况，我们就把当前位置和下一个位置当作偶数行回文的最中间两个字符，然后向两边进行搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;    <span class="comment">//记录回文子串起始位置</span></span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>;      <span class="comment">//记录回文子串终止位置</span></span><br><span class="line">        <span class="keyword">int</span> mlen=<span class="number">0</span>;     <span class="comment">//记录最大回文子串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len1=<span class="built_in">expendaroundcenter</span>(s,i,i);     <span class="comment">//一个元素为中心</span></span><br><span class="line">            <span class="keyword">int</span> len2=<span class="built_in">expendaroundcenter</span>(s,i,i+<span class="number">1</span>);   <span class="comment">//两个元素为中心</span></span><br><span class="line">            mlen=<span class="built_in">max</span>(<span class="built_in">max</span>(len1,len2),mlen);</span><br><span class="line">            <span class="keyword">if</span>(mlen&gt;end-start+<span class="number">1</span>)&#123;</span><br><span class="line">                start=i-(mlen<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                end=i+mlen/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,mlen);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expendaroundcenter</span><span class="params">(string s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//计算以left和right为中心的回文串长度</span></span><br><span class="line">        <span class="keyword">int</span> L=left;</span><br><span class="line">        <span class="keyword">int</span> R=right;</span><br><span class="line">        <span class="keyword">while</span>(L&gt;=<span class="number">0</span> &amp;&amp; R&lt;s.<span class="built_in">length</span>() &amp;&amp; s[R]==s[L])&#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R-L<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （一）中心扩展法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//以 s[left] s[right] 为中心向两端扩散的回文串</span></span><br><span class="line">    <span class="function">string <span class="title">expendaroundcenter</span><span class="params">(string &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//防止索引越界</span></span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.<span class="built_in">size</span>()&amp;&amp;s[left]==s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left+<span class="number">1</span>,right-left<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string s1=<span class="built_in">expendaroundcenter</span>(s,i,i);</span><br><span class="line">            string s2=<span class="built_in">expendaroundcenter</span>(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//res=longest(res,s1,s1)</span></span><br><span class="line">            res=res.<span class="built_in">size</span>()&gt;s1.<span class="built_in">size</span>()?res:s1;</span><br><span class="line">            res=res.<span class="built_in">size</span>()&gt;s2.<span class="built_in">size</span>()?res:s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （二）动态规划</span></span><br><span class="line"><span class="comment"> * 1.确定dp数组（dp table）以及下标的含义</span></span><br><span class="line"><span class="comment"> * 2.确定递推公式</span></span><br><span class="line"><span class="comment"> * 3.dp数组如何初始化</span></span><br><span class="line"><span class="comment"> * 4.确定遍历顺序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在确定递推公式时，就要分析如下几种情况。</span></span><br><span class="line"><span class="comment"> * 整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</span></span><br><span class="line"><span class="comment"> * 当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</span></span><br><span class="line"><span class="comment"> * 当s[i]与s[j]相等时，这就复杂一些了，又有如下三种情况</span></span><br><span class="line"><span class="comment"> *  情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</span></span><br><span class="line"><span class="comment"> *  情况二：下标i 与 j相差为1，例如aa，也是回文子串</span></span><br><span class="line"><span class="comment"> *  情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，</span></span><br><span class="line"><span class="comment"> *  我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，</span></span><br><span class="line"><span class="comment"> *  这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *     —— —— —— ——   —— —— —— ——</span></span><br><span class="line"><span class="comment"> *    |            |            |</span></span><br><span class="line"><span class="comment"> *    |            |  dp[i][j]  |</span></span><br><span class="line"><span class="comment"> *    |            |            |</span></span><br><span class="line"><span class="comment"> *    |            |            |</span></span><br><span class="line"><span class="comment"> *     —— —— —— ——  —— —— —— ——</span></span><br><span class="line"><span class="comment"> *    |            |            |</span></span><br><span class="line"><span class="comment"> *    |dp[i+1][j-1]|            |</span></span><br><span class="line"><span class="comment"> *    |            |            |</span></span><br><span class="line"><span class="comment"> *    |            |            |</span></span><br><span class="line"><span class="comment"> *     —— —— —— ——   —— —— —— ——</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本题目是少有的动态规划非最优解的问题 （时间 O(n^2) ！空间O(n^2)）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，</span></span><br><span class="line">        <span class="comment">// 如果是dp[i][j]为true，否则为false。</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxlenth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j]由dp[i+1][j-1]确定，因此从左下向右上遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;    <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlenth) &#123;</span><br><span class="line">                    maxlenth = j - i + <span class="number">1</span>;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以上代码是为了凸显情况一二三，当然是可以简洁一下的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxlenth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlenth) &#123;</span><br><span class="line">                    maxlenth = j - i + <span class="number">1</span>;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left, maxlenth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><strong>寻找连通分量和最大集合数量</strong></p><h1 id="堆-栈"><a href="#堆-栈" class="headerlink" title="堆/栈"></a>堆/栈</h1><h1 id="棋盘-最短路径"><a href="#棋盘-最短路径" class="headerlink" title="棋盘 最短路径"></a>棋盘 最短路径</h1>]]></content>
    
    
    <summary type="html">整理记录刷的算法题，好记性不如烂笔头啊！题解参考了Grand Yang(https://github.com/grandyang)</summary>
    
    
    
    <category term="code" scheme="http://example.com/categories/code/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/02/14/hello-world/"/>
    <id>http://example.com/2021/02/14/hello-world/</id>
    <published>2021-02-13T16:00:00.000Z</published>
    <updated>2021-07-24T06:25:23.797Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><p>[TOC]</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-hexo"><a href="#Install-hexo" class="headerlink" title="Install hexo"></a>Install hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="Create-myblog"><a href="#Create-myblog" class="headerlink" title="Create myblog"></a>Create myblog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init myblog</span><br></pre></td></tr></table></figure><p><strong>出现 hexo init 失败问题，<a href="https://blog.csdn.net/qq_43580193/article/details/117341489?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">解决方法</a>替换Github连接</strong></p><h3 id="将Hexo部署到GitHub"><a href="#将Hexo部署到GitHub" class="headerlink" title="将Hexo部署到GitHub"></a>将Hexo部署到GitHub</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git #冒号后面有空格</span><br><span class="line">  repository: git@github.com:xuhuigeren/xuhuigeren.github.io.git  #ssh/https仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><strong>回到 myblog 文件夹中，打开 Git Bash，安装Git部署插件，输入命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><strong>然后分别输入以下三条命令：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   <span class="comment">#清除缓存文件 db.json 和已生成的静态文件 public</span></span><br><span class="line">hexo g       <span class="comment">#生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span></span><br><span class="line">hexo d       <span class="comment">#自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span></span><br></pre></td></tr></table></figure><p><strong>完成以后，打开浏览器，输入 <a href="https://xuhuigeren.github.io/">https://xuhuigeren.github.io</a>  就可以打开你的网页了</strong></p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">Welcome to Hexo</summary>
    
    
    
    <category term="我的博客" scheme="http://example.com/categories/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
