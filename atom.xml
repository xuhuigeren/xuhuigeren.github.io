<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>桥头打字员</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-02-08T04:29:23.078Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Henry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HCSA</title>
    <link href="http://example.com/2024/01/21/HCSA/"/>
    <id>http://example.com/2024/01/21/HCSA/</id>
    <published>2024-01-21T15:26:14.000Z</published>
    <updated>2024-02-08T04:29:23.078Z</updated>
    
    <content type="html"><![CDATA[<p>ACL: access comtrol list 访问控制列表是一种基于包过滤的访问控制技术，它可以根据设定的条件对接口上的数据包进行过滤，允许其通过或丢弃。<br>五元组: 源IP、源端口,目的IP、目的端口、协议号<br>DPI: 深度报文检测（Deep Packet Inspection）是一种网络流量分析技术，用于检测和过滤网络数据包中的内容。它可以对数据包的头部和有效载荷进行深入分析，以识别特定的应用程序、协议或行为模式。</p><p>二层 vswitch1<br>三层 trust-vr</p><p>StoneOS系统架构<br>● Zones<br>  ○ L2 Zone<br>  ○ L3 Zone<br>● Interfaces  绑定到安全域<br>  ○ 一个接口只能绑定到一个安全域<br>  ○ 一个安全域可以包含一个或多个接口<br>  ○ 绑定到三层安全域的接口才可以配置IP地址及管理服务<br>● Virtual Switch  转发二层数据<br>● Virtual Router  转发三层数据<br>  ○ 以上均可创建多个,相互独立,各自维护自己的MAC表、路由表<br>  ○ 设备默认关闭多VRouter功能,开启此功能需要设备重启生效<br>● Policy<br>  ○ 经过FW的流量,都需要做安全策略的放行<br>    ■ 通过直连访问FW接口的不需要经过安全策略<br>    ■ 二层arp报文,虽然是经过FW的流量,不需要经过安全策略<br>  ○ 安全策略仅限于二层之间、三层之间,没有二三层之间的!<br>  ○ FW自身产生的流量不需要进行安全策略的放行</p><p>FW部署:路由模式、透明模式、旁路模式、混合模式<br>CLI常用命令<br>show命令<br>show version<br>show interface<br>show ip route<br>show snat<br>show dnet<br>show policy<br>show configuration<br>save                    //保存当前配置信息 webui是自动保存 重启设备配置仍存在<br>unset all                             //恢复出厂设置</p><p>接口配置<br>configure                                  //进入全局配置视图<br>interface ethernet0/1     //进入0/1口<br>zone trust                                //配置三层安全域<br>ip address 192.168.10.12    //配置ip</p><p>路由基本配置<br>configure<br>ip vrouter trust-vr                //进入policy配置视图<br>ip router 10.18.0.0/16 10.1.1.1<br>exit</p><p>配置安全策略<br>configure<br>policy-global                //进入ploicy配置shitu<br>rule from any to any service any permit</p><p>shutdown      // 关闭接口–》down<br>no shutdown   // 开启接口–》up</p><p>数据转发</p><p>为了达到上网访问Internet<br>● 接口<br>● 路由<br>● NAT<br>● 策略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ACL: access comtrol list 访问控制列表是一种基于包过滤的访问控制技术，它可以根据设定的条件对接口上的数据包进行过滤，允许其通过或丢弃。&lt;br&gt;五元组: 源IP、源端口,目的IP、目的端口、协议号&lt;br&gt;DPI: 深度报文检测（Deep Packet </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2024/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2024/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-01-18T14:39:29.000Z</published>
    <updated>2024-02-03T07:58:37.156Z</updated>
    
    <content type="html"><![CDATA[<p>《设计模式》</p><p>创建型模式</p><p>结构型模式</p><p>行为型模式</p><p>…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《设计模式》&lt;/p&gt;
&lt;p&gt;创建型模式&lt;/p&gt;
&lt;p&gt;结构型模式&lt;/p&gt;
&lt;p&gt;行为型模式&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>记性不好</title>
    <link href="http://example.com/2024/01/14/%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A5%BD/"/>
    <id>http://example.com/2024/01/14/%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A5%BD/</id>
    <published>2024-01-14T14:22:06.000Z</published>
    <updated>2024-01-17T11:58:40.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><blockquote><p>（gdb）help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h<br>（gdb）run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r<br>（gdb）start：单步执行，运行程序，停在第一执行语句<br>（gdb）attach：调试外部进程<br>（gdb）stop：暂停调试，可进行设置断点和watch<br>（gdb）list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l<br>（gdb）set：设置变量的值<br>（gdb）next：单步调试（逐过程，函数直接执行）,简写n<br>（gdb）step：单步调试（逐语句：跳入自定义函数内部执行）,简写s<br>（gdb）backtrace：查看函数的调用的栈帧和层级关系,简写bt<br>（gdb）frame：切换函数的栈帧,简写f<br>（gdb）info：查看函数内部局部变量的数值,简写i<br>（gdb）finish：结束当前函数，返回到函数调用点<br>（gdb）continue：继续运行到下个断点,简写c<br>（gdb）print：打印值及地址,简写p<br>（gdb）quit：退出gdb,简写q<br>（gdb）break+文件.c:num：在文件.c的第num行设置断点,简写b<br>（gdb）info breakpoints：查看当前设置的所有断点<br>（gdb）delete breakpoints num：删除第num个断点,简写d<br>（gdb）display：追踪查看具体变量值，eg：display e，程序断住时显示该变量内容<br>（gdb）undisplay：取消追踪观察变量<br>（gdb）watch：被设置观察点的变量发生修改时，打印显示，eg：watch a，观察变量变化<br>（gdb）i watch：显示观察点<br>（gdb）enable breakpoints：启用断点<br>（gdb）disable breakpoints：禁用断点<br>（gdb）x：查看内存，eg：x/20xw 显示20个单元，16进制，4字节每单元<br>（gdb）run argv[1] argv[2]：调试时命令行传参</p></blockquote><h2 id="shell-输出定制"><a href="#shell-输出定制" class="headerlink" title="shell 输出定制"></a>shell 输出定制</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加在 .bashrc 最后面</span></span><br><span class="line"><span class="comment"># Parses out the branch name from .git/HEAD:</span></span><br><span class="line"><span class="function"><span class="title">find_git_branch</span></span> () &#123;</span><br><span class="line">    <span class="built_in">local</span> dir=. head</span><br><span class="line">    until [ <span class="string">&quot;<span class="variable">$dir</span>&quot;</span> -ef / ]; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$dir</span>/.git/HEAD&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            head=$(&lt; <span class="string">&quot;<span class="variable">$dir</span>/.git/HEAD&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> [[ <span class="variable">$head</span> = ref:\ refs/heads/* ]]; <span class="keyword">then</span></span><br><span class="line">                git_branch=<span class="string">&quot; (<span class="variable">$&#123;head#*/*/&#125;</span>)&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> [[ <span class="variable">$head</span> != <span class="string">&#x27;&#x27;</span> ]]; <span class="keyword">then</span></span><br><span class="line">                git_branch=<span class="string">&quot; ((detached))&quot;</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                git_branch=<span class="string">&quot; ((unknow))&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        dir=<span class="string">&quot;../<span class="variable">$dir</span>&quot;</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    git_branch=<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROMPT_COMMAND=<span class="string">&quot;find_git_branch; <span class="variable">$PROMPT_COMMAND</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Here is bash color codes you can use</span></span><br><span class="line">  black=$<span class="string">&#x27;\[\e[1;30m\]&#x27;</span></span><br><span class="line">    red=$<span class="string">&#x27;\[\e[1;31m\]&#x27;</span></span><br><span class="line">  green=$<span class="string">&#x27;\[\e[1;32m\]&#x27;</span></span><br><span class="line"> yellow=$<span class="string">&#x27;\[\e[1;33m\]&#x27;</span></span><br><span class="line">   blue=$<span class="string">&#x27;\[\e[1;34m\]&#x27;</span></span><br><span class="line">magenta=$<span class="string">&#x27;\[\e[1;35m\]&#x27;</span></span><br><span class="line">   cyan=$<span class="string">&#x27;\[\e[1;36m\]&#x27;</span></span><br><span class="line">  white=$<span class="string">&#x27;\[\e[1;37m\]&#x27;</span></span><br><span class="line"> normal=$<span class="string">&#x27;\[\e[m\]&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 重新定义一个PS1,这里的“\u表示root,\h表示host，颜色什么的完全可以自定义” </span></span><br><span class="line">PS1=<span class="string">&quot;<span class="variable">$magenta</span>\u<span class="variable">$magenta</span>@<span class="variable">$magenta</span>\h<span class="variable">$white</span>:<span class="variable">$cyan</span>\w<span class="variable">$red</span>\$git_branch<span class="variable">$green</span>\$ <span class="variable">$normal</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> PS1</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">常用的 重要的 容易忘记的</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>多PC协同管理hexo</title>
    <link href="http://example.com/2024/01/01/%E5%A4%9APC%E5%8D%8F%E5%90%8C%E7%AE%A1%E7%90%86hexo/"/>
    <id>http://example.com/2024/01/01/%E5%A4%9APC%E5%8D%8F%E5%90%8C%E7%AE%A1%E7%90%86hexo/</id>
    <published>2024-01-01T05:02:23.000Z</published>
    <updated>2024-02-08T04:28:28.309Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我的blog是基于gitub pages和hexo搭建的静态博客，环境win10 + nodejs + git，本地编写md文件，然后部署到github转化为html托管于github，优点不用花钱买服务器。</p><p>如题，因为部署blog的老PC是台式机，想更新下blog还得坐到电脑前，总归有点不方便，现在想在Mac/Ubuntu上也能管理hexo博客。既然blog都托管在github，那git指定行啊。</p><h3 id="新建一个git分支"><a href="#新建一个git分支" class="headerlink" title="新建一个git分支"></a>新建一个git分支</h3><p>原先hexo d生成的静态页面默认推到master分支上，提供博客页面供人访问，这是在_config.yml中配置的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git #冒号后面有空格</span><br><span class="line">  repository: git@github.com:xuhuigeren/xuhuigeren.github.io.git  #ssh/https仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src="/2024/01/01/%E5%A4%9APC%E5%8D%8F%E5%90%8C%E7%AE%A1%E7%90%86hexo/1.png" alt="01"></p><p>**新建一个分支<hexo>**，并且把hexo分支设为default分支，配置文件决定了hexo d每次推到master分支，master和hexo两个分支互相独立，hexo分支拉到本地，本地新增、删改时，git add，git commit、git push来更新源文件，然后执行hexo d更新静态页面，Mac/Ubuntu端同样本地维护hexo分支，为了保证同步，推荐先<code>git pull</code>合并更新在编辑博客。</hexo></p><p><img src="/2024/01/01/%E5%A4%9APC%E5%8D%8F%E5%90%8C%E7%AE%A1%E7%90%86hexo/3.png" alt="03"></p><p><img src="/2024/01/01/%E5%A4%9APC%E5%8D%8F%E5%90%8C%E7%AE%A1%E7%90%86hexo/2.png" alt="02"></p><p><strong>编辑hexo分支</strong></p><p>这部分是最重要的，临门一脚（Win侧操作，也就是在原PC上）</p><ol><li>git仓库到本地（clone下来的是默认的hexo分支）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure><ol start="2"><li>下载的文件夹里仅留下.git 文件夹，其他的文件都删除</li><li>将原来hexo blog文件夹内除.deploy_git 以外都复制到git下来的文件夹</li></ol><p>注意：如果已经git过主题文件，需要把theme主题文件夹里的 .git(隐藏文件) 也删除，因为git不能嵌套上传。</p><ol start="4"><li>将修改以后的文件夹推送到远程库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m “msg”</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>此时已经成功将整个网站推送到了远程库的默认分支hexo</p><p>至此，网站部署至master分支，整个网站备份至hexo分支。当网站的配置或文章修改后都要先git操作推到hexo分支，再hexo d，最新改动也同步更新到master分支了，两个分支互不干扰！</p><h3 id="在Mac上管理博客"><a href="#在Mac上管理博客" class="headerlink" title="在Mac上管理博客"></a>在Mac上管理博客</h3><ul><li><p><strong>配置环境</strong></p><blockquote><ul><li><p>安装Node.js</p></li><li><p>版本最好与win一样</p></li><li><p>node -v和npm -v查看</p></li><li><p>安装Git</p></li><li><p>安装hexo</p></li><li><p><a href="https://xuhuigeren.github.io/2021/02/14/hello-world/">hexo创建博客看这里</a></p></li><li><p>配置github的SSH key</p></li><li><p>cd ~/.ssh</p></li><li><p>ssh-keygen -t rsa -C “邮件地址”</p></li><li><p>github主页New SSH key复制进去</p></li><li><p>ssh -T <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#109;">&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#109;</a> 测试是否配置成功</p></li></ul></blockquote></li><li><p>git hexo分支到本地</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure><ul><li>在username.github.io文件夹下执行（不需要执行hexo init）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><ul><li>最后执行<code>hexo g</code>、<code>hexo s</code>、<code>hexo d</code>等命令即可提交成功</li></ul><p>至此，其实任何一台电脑只要有nodejs和git环境，都可以完整复刻出一个hexo环境，你甚至可以把老电脑原有的hexo工程删掉再执行上面这几步一样可以快速构建hexo环境、</p><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><ul><li>mac这边文件权限不足 errno -13<ul><li>udo chown -R $USER /usr/xxx/xxx</li></ul></li><li>26 vulnerabilities (3 low, 4 moderate, 12 high, 7 critical)<ul><li>如果是按以上步骤来操作的，可以不用管</li></ul></li><li>科学上网会导致<code>ssh: connect to host github.com port 22: Connection timed out</code> 或者 <code>Failed to connect to github.com port 443: Timed out</code><ul><li>git 所设端口与系统代理不一致，需重新设置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890 </span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><img src="/2024/01/01/%E5%A4%9APC%E5%8D%8F%E5%90%8C%E7%AE%A1%E7%90%86hexo/5.png" alt="05"></li></ul></li></ul>]]></content>
    
    
    <summary type="html">Welcome to Hexo</summary>
    
    
    
    <category term="我的博客" scheme="http://example.com/categories/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Back_to_myblog</title>
    <link href="http://example.com/2023/12/24/Back-to-myblog/"/>
    <id>http://example.com/2023/12/24/Back-to-myblog/</id>
    <published>2023-12-24T12:23:00.000Z</published>
    <updated>2024-01-05T15:03:16.994Z</updated>
    
    <content type="html"><![CDATA[<p>毕业这么久，一直都很浮躁，需要静下心来 学习 记录。</p><img src="/2023/12/24/Back-to-myblog/沉淀1.png" alt="02">]]></content>
    
    
    <summary type="html">越来越笨，只能不停学习呀</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GStreamer学习笔记--GObject类对象</title>
    <link href="http://example.com/2021/07/17/gstreamer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gobject%E7%B1%BB%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2021/07/17/gstreamer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gobject%E7%B1%BB%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-07-17T08:48:47.000Z</published>
    <updated>2023-12-31T18:44:13.893Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="GStreamer学习笔记–GObject类对象"><a href="#GStreamer学习笔记–GObject类对象" class="headerlink" title="GStreamer学习笔记–GObject类对象"></a>GStreamer学习笔记–GObject类对象</h1><h2 id="Gobject类定义"><a href="#Gobject类定义" class="headerlink" title="Gobject类定义"></a>Gobject类定义</h2><p>维基百科：<strong>GObject</strong>，是一个在<a href="https://zh.wikipedia.org/wiki/LGPL">LGPL</a>下发布的<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6">自由</a><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BA%93">软件库</a>，它提供了一个轻便的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F&action=edit&redlink=1">对象系统</a>并支持透明的多语言互通。GObject被设计为可以直接使用在<a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">C</a>程序中，也可以被封装至其他语言，例如<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a>，<a href="https://zh.wikipedia.org/wiki/Java">Java</a>，<a href="https://zh.wikipedia.org/wiki/Python">Python</a>，以及可以生成C代码的<a href="https://zh.wikipedia.org/wiki/Vala">Vala</a>（由此大大简化了<code>GObject</code>代码的书写）等等。</p><p><code>Gstreamer</code>框架是基于插件的，同时插件是可以动态的注册、创建，<code>gstreamer</code>基于<code>Gobject</code>开发，下面来了解一下<code>gstreamer</code>是如何通过<code>Gobject</code>完成自定义类的注册。</p><p>在每个类的<code>c</code>文件中，都会有以下这样的一个宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G_DEFINE_TYPE (GstV4l2Allocator, gst_v4l2_allocator, GST_TYPE_ALLOCATOR);</span><br></pre></td></tr></table></figure><p><code>G_DEFINE_TYPE</code>是一个宏定义，那么这个<code>G_DEFINE_TYPE</code>宏是如何完成向<code>Gobject</code>系统完成类的注册呢？</p><p>将<code>G_DEFINE_TYPE</code>展开可以看到以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G_DEFINE_TYPE(TN, t_n, T_P)</span></span><br><span class="line"><span class="comment">/******* </span></span><br><span class="line"><span class="comment"> *TN  ---&gt; TypeName</span></span><br><span class="line"><span class="comment"> *t_n ---&gt; type_name</span></span><br><span class="line"><span class="comment"> *T_P ---&gt; TYPE_PARENT</span></span><br><span class="line"><span class="comment"> *_f_ ---&gt; 0</span></span><br><span class="line"><span class="comment"> *_c_ ---&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">******/</span></span><br><span class="line"><span class="comment">/*****   以下为宏展开   *****/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>     type_name##_init              (TypeName        *self); </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>     type_name##_class_init        (TypeName##Class *klass); </span><br><span class="line"><span class="keyword">static</span> gpointer type_name##_parent_class = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> gint     TypeName##_private_offset;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>     type_name##_class_intern_init (gpointer klass)</span><br><span class="line">&#123;</span><br><span class="line">  type_name##_parent_class = g_type_class_peek_parent (klass);</span><br><span class="line">  <span class="keyword">if</span> (TypeName##_private_offset != <span class="number">0</span>)</span><br><span class="line">    g_type_class_adjust_private_offset (klass, &amp;TypeName##_private_offset);</span><br><span class="line">  type_name##_class_init ((TypeName##Class*) klass);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> gpointer</span><br><span class="line">type_name##_get_instance_private (TypeName *self)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (G_STRUCT_MEMBER_P (self, TypeName##_private_offset));</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">GType </span><br><span class="line">type_name##_get_type (<span class="keyword">void</span>) </span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">volatile</span> gsize g_define_type_id__volatile = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Prelude goes here */</span></span><br><span class="line">  <span class="keyword">if</span> (g_once_init_enter (&amp;g_define_type_id__volatile))</span><br><span class="line">    &#123;</span><br><span class="line">      GType g_define_type_id =</span><br><span class="line">        g_type_register_static_simple (TYPE_PARENT,</span><br><span class="line">                                       g_intern_static_string (#TypeName),</span><br><span class="line">                                       <span class="keyword">sizeof</span> (TypeName##Class),</span><br><span class="line">                                       (GClassInitFunc)(<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) type_name##_class_intern_init,</span><br><span class="line">                                       <span class="keyword">sizeof</span> (TypeName),</span><br><span class="line">                                       (GInstanceInitFunc)(<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) type_name##_init,</span><br><span class="line">                                       (GTypeFlags) flags);</span><br><span class="line">      &#123; <span class="comment">/* custom code follows */</span></span><br><span class="line">      &#123;_C_;&#125;</span><br><span class="line">        <span class="comment">/* following custom code */</span></span><br><span class="line">      &#125;</span><br><span class="line">      g_once_init_leave (&amp;g_define_type_id__volatile, g_define_type_id);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> g_define_type_id__volatile;</span><br><span class="line">&#125; <span class="comment">/* closes type_name##_get_type() */</span></span><br></pre></td></tr></table></figure><h2 id="向Gobject系统注册类"><a href="#向Gobject系统注册类" class="headerlink" title="向Gobject系统注册类"></a>向Gobject系统注册类</h2><p><code>G_DEFINE_TYPE</code>定义如上，那么，最终它是如何向<code>Gobject</code>系统注册该类的呢？<br><code>Gobject</code>系统为什么知道你新添加了一个名叫<code>TypeName</code>的类，是因为你通过<code>g_type_register_static_simple()</code>函数告诉它，我这里有一个新类，你登记一下<code>g_type_register_static_simple()</code>函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLIB_AVAILABLE_IN_ALL</span></span><br><span class="line"><span class="function">GType <span class="title">g_type_register_static_simple</span>     <span class="params">(GType                       parent_type,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> gchar                *type_name,</span></span></span><br><span class="line"><span class="params"><span class="function"> guint                       class_size,</span></span></span><br><span class="line"><span class="params"><span class="function"> GClassInitFunc              class_init,</span></span></span><br><span class="line"><span class="params"><span class="function"> guint                       instance_size,</span></span></span><br><span class="line"><span class="params"><span class="function"> GInstanceInitFunc           instance_init,</span></span></span><br><span class="line"><span class="params"><span class="function"> GTypeFlags             flags)</span></span>;</span><br></pre></td></tr></table></figure><p>函数声明的前面<code>GLIB_AVAILABLE_IN_ALL</code>就是一个<code>extern</code>关键词，从函数声明我们可以了解到，向<code>Gobject</code>系统注册一个类，需要告诉<code>Gobject</code>系统，我现在需要注册一个新类，它父类的类型是<code>parent_type</code>，大小是<code>class_size</code>，类的初始化函数是<code>class_init</code>，类的实例大小以及初始化函数，还有这个类有什么<code>flags</code>，通过告诉<code>Gobject</code>，它就会将新类登记在线。</p><p>通过<code>G_DEFINE_TYPE</code>宏的展开可以知道，在<code>type_name##_get_type()</code>函数中调用到<code>g_type_register_static_simple()</code>函数，那么，究竟是什么时候，程序会向<code>Gobject</code>系统注册该新类呢？<br>比如我们是要注册一个名叫<code>TestObject</code>的类，那么就是通过<code>TestObject_get_type()</code>函数完成<code>estObject</code>的注册登记。<br>在我们需要创建一个<code>TestObject</code>的实例时，会通过调用<code>g_object_new()</code>函数完成，在调用<code>g_object_new</code>函数，需要传进相应的参数，这个时候，我们就将<code>TestObject_get_type()</code>函数的返回值传递给它，即演变成以下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestObject *testObject = （TestObject *）g_object_new (TestObject_get_type(), <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>在创建<code>TestObject</code>实例对象的时候，将会调用<code>TestObject_get_type()</code>函数得到相应的类型，而在<code>TestObject_get_type()</code>函数中，将会先通过<code>g_once_init_enter()</code>函数检查<code>TestObject_get_type()</code>中的静态变量<code>g_define_type_id_volatile</code>是否为0，如果是，则通过<code>g_type_register_static_simple()</code>函数向<code>Gobject</code>系统登记<code>TestObject</code>类，同时返回<code>object ID</code>，如果<code>g_define_type_id_volatile</code>不为0，则说明已经向<code>Gobject</code>系统注册<code>TestObjec</code>t类，直接返回<code>object ID</code>，这样，即完成了<code>TestObject</code>的注册登记。</p><h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><p>学习<code>C++</code>我们都知道，类是有构造函数的，在创建类实例的时候，会自动调用该类的构造函数，那么，在<code>Gobject</code>中，又是怎么调用类的构造函数呢？</p><p>以<code>TestObject</code>为例，在上面说到通过<code>g_type_register_static_simple()</code>函数向<code>Gobject</code>系统注册自定义类的时候，就传进了相应的参数，包括类的初始化函数<code>test_object_class_intern_init()</code>以及类实例的初始化函数<code>test_object_init()</code>，它们两个共同的相当于<code>TestObject</code>类的构造函数。从宏定义<code>G_DEFINE_TYPE</code>的展开代码中发现以下函数声明以及<code>test_object_class_intern_init()</code>函数的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>     <span class="title">test_object_init</span>              <span class="params">(TestObject      *self)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>     <span class="title">test_object_class_init</span>        <span class="params">(TestObjectClass *klass)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>     <span class="title">test_object_class_intern_init</span> <span class="params">(gpointer klass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  test_object_parent_class = g_type_class_peek_parent (klass);</span><br><span class="line">  <span class="keyword">if</span> (test_object_private_offset != <span class="number">0</span>)</span><br><span class="line">    g_type_class_adjust_private_offset (klass, &amp;TestObject_private_offset);</span><br><span class="line">  test_object_class_init ((TestObjectClass*) klass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码我们可以知道，在通过<code>G_DEFINE_TYPE</code>向<code>Gobject</code>系统注册类，还需要我们实现<code>test_object_class_init()</code>和<code>test_object_init()</code>函数的定义。<code>test_object_class_init()</code>函数是在第一次创建<code>TestObject</code>类实例对象的时候调用的，该函数只会调用一次，而<code>test_object_init()</code>函数则是每次创建<code>TestObject</code>类实例对象都会调用。</p><h2 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h2><p>在<code>G_DEFINE_TYPE</code>的展开代码中，可以看到以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> gpointer type_name##_parent_class = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>     type_name##_class_intern_init (gpointer klass)</span><br><span class="line">&#123;</span><br><span class="line">  type_name##_parent_class = g_type_class_peek_parent (klass);</span><br><span class="line">  <span class="keyword">if</span> (TypeName##_private_offset != <span class="number">0</span>)</span><br><span class="line">    g_type_class_adjust_private_offset (klass, &amp;TypeName##_private_offset);</span><br><span class="line">  type_name##_class_init ((TypeName##Class*) klass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个宏中，可以看到定义了一个静态的全局指针变量<code>type_name_parent_class</code>，而<code>type_name_parent_class</code>变量是通过<code>g_type_class_peek_parent()</code>函数赋值的，<code>type_name_parent_class</code>变量代表着什么呢，它就是父类。一般的，会在该源文件新增一个宏，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> type_name##_parent_class parent_class</span></span><br></pre></td></tr></table></figure><p>这样就可以通过宏定义<code>parent_class</code>直接调用父类函数，而该父类，就是在通过宏定义<code>G_DEFINE_TYPE</code>向<code>Gobject</code>系统注册类时传进的第三个参数<code>T_P</code>。<code>g_type_class_peek_parent()</code>函数通过传进的子类指针，查找到注册时候的相应信息，得到父类的类型，而后通过父类类型得到父类信息并返回。</p><h2 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h2><p>有了相应的构造函数，在构造函数中申请了内存、硬件等资源，自然的，也会类似<code>C++</code>的，有相应的析构函数负责资源的释放操作。那么，在<code>Gobject</code>系统中，析构函数又是什么回事呢？我们都知道，构造函数是从父类到子类，而析构函数是从子类到父类。在<code>Gobject</code>系统中的析构函数又是如何的呢？</p><p>之前说到，在通过<code>G_DEFINE_TYPE</code>向<code>Gobject</code>系统，注册<code>TestObject</code>类的时候，需要定义<code>test_object_class_init()</code>和<code>test_object_init()</code>函数，而在类实例的初始化函数<code>test_object_init()</code>中，我们可能申请了一些内存等资源，我们需要在析构函数中释放这些资源，这个时候，需要我们在<code>TestObject</code>类初始化函数<code>test_object_class_init()</code>覆盖从父类继承的析构函数，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void</span><br><span class="line">test_object_dispose (GObject * object)</span><br><span class="line">&#123;</span><br><span class="line">TestObject *testobject = TEST_OBJECT (object);</span><br><span class="line"> </span><br><span class="line">/*  资源释放*/</span><br><span class="line"> </span><br><span class="line">/*  调用父类的dispose 函数 */</span><br><span class="line">G_OBJECT_CLASS (parent_class)-&gt;dispose (object);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void</span><br><span class="line">test_object_finalize (TestObject * testobject)</span><br><span class="line">&#123;</span><br><span class="line">g_free(testobject-&gt;mem);</span><br><span class="line"></span><br><span class="line">    /*  调用父类的finalize 函数 */</span><br><span class="line">G_OBJECT_CLASS (parent_class)-&gt;finalize (object);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void test_object_init(TestObject * self)</span><br><span class="line">&#123;</span><br><span class="line">self-&gt;mem = g_malloc (1);</span><br><span class="line">&#125;</span><br><span class="line">static void test_object_class_init(TestObjectClass *klass)</span><br><span class="line">&#123;</span><br><span class="line">GObjectClass *object_class = G_OBJECT_CLASS (klass);</span><br><span class="line"> </span><br><span class="line">object_class-&gt;dispose = test_object_dispose;</span><br><span class="line">object_class-&gt;finalize = test_object_finalize;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述代码我们可以知道，在<code>TestObject</code>的初始化的时候，将会覆盖从父类继承而来的析构函数，同时在析构函数中释放类实例初始化时占用的资源，同时还有递归调用父类的析构函数。<code>dispose</code>函数主要是将在类中占用的资源释放，而<code>finalize</code>函数则是有点类似真正的析构函数，将构造函数申请的资源进行释放回收。</p><p>既然析构函数也已经有了，析构函数又会是什么时候调用呢？</p><p><code> JAVA</code>使用的是垃圾回收的机制，而<code>Gobjec</code>t则是使用引用计数的方式。当每个对象创建的时候，将会对其引用计数加一，如果期间被其他对象进行引用，也都会将它的引用计数增加；而当对象被解除引用的时候，引用计数将会减一，当引用计数减为0的时候，将会调用对象的析构函数，进行资源的回收。</p><p><code>Gobject</code>的引用计数方式大致如下：</p><ul><li>使用<code>g_object_new()</code>函数进行实例化的时候，对象的引用计数为1；</li><li>使用<code>g_object_ref()</code>函数进行引用对象的时候，对象的引用计数加1；</li><li>使用<code>g_object_unref()</code>函数解除引用的时候，对象的引用计数减1；</li><li>调用<code>g_object_unref()</code>函数进行解引用的时候，如果发现对象的引用计数为0，将会先后调用该对象的<code>dispose()</code>函数和<code>finalize()</code>函数。</li></ul><p>而为什么在<code>test_object_class_init()</code>函数中覆盖从父类继承过来的析构函数呢？<br>因为在<code>g_object_unref()</code>函数中调用<code>dispose()</code>函数和<code>finalize()</code>函数是通过宏定义<code>G_OBJECT_GET_CLASS取得OBJECT_CLASS</code>类之后，再调用它的<code>dispose()</code>函数和<code>finalize()</code>函数，所以需要在<code>TestObject</code>的类初始化函数对这两个函数指针进行覆盖，而在<code>TestObject</code>类的<code>dispose()</code>函数和<code>finalize()</code>函数再通过<code>G_OBJECT_CLASS (parent_class)</code>取得父类指针，调用父类的析构函数。</p><h2 id="类的其他设置"><a href="#类的其他设置" class="headerlink" title="类的其他设置"></a>类的其他设置</h2><p>在<code>Gobject</code>系统中，设置了很多方便的宏，使在使用对象的时候可以更加的方便，在相应的头文件，一般会有如下宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GstTestObject</span> <span class="title">TestObject</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GstTestObjectClass</span> <span class="title">GstTestObjectClass</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 获取类型 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TYPE_TEST_OBJECT      (test_object_get_type())</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 类实例类型判断 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_IS_TEST_OBJECT(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_TEST_OBJECT))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 类结构判定 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_IS_TEST_OBJECT_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_TEST_OBJECT))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 获取obj的类型，同时将其转换为GST_TYPE_TEST_OBJECT，并返回指向GstTestObjectClass的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TEST_OBJECT_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_TEST_OBJECT, GstTestObjectClass))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 检查obj是否是GST_TYPE_TEST_OBJECT类型，如果是，则将返回指向obj成员变量TestObject的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TEST_OBJECT(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_TEST_OBJECT, TestObject))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 检查klass是不是GST_TYPE_TEST_OBJECT类型，如果是，则将返回指向klass成员变量GstTestObjectClass的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TEST_OBJECT_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_TEST_OBJECT, GstTestObjectClass))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 实例结构转换 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TEST_OBJECT_CAST(obj) ((TestObject*)(obj))</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GstTestObject</span> &#123;</span></span><br><span class="line">  GstObject            object;</span><br><span class="line">  gchar *mem;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 类定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GstTestObjectClass</span> &#123;</span></span><br><span class="line">  GstObjectClass    object_class;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是通过上述的宏定义，可以方便的将各种类以及对象进行转换，在子类中可以调用父类的函数等操作，同时，在<code>gstreamer</code>中，还有一些属性设置函数等，进行多样化的类管理。</p><p>另外的，宏定义<code>G_DEFINE_TYPE_WITH_CODE</code>也是实现与<code>G_DEFINE_TYP</code>类似的功能，只不过是可以将一些函数内置在<code>type_name##_get_type()</code>函数中。</p>]]></content>
    
    
    <summary type="html">GObject 设计用于直接在C程序中使用以提供面向对象的基于C的API，并通过与其他语言的绑定来提供透明的跨语言互操作性，例如PyGObject。</summary>
    
    
    
    <category term="Internship" scheme="http://example.com/categories/Internship/"/>
    
    
    <category term="GStreamer" scheme="http://example.com/tags/GStreamer/"/>
    
    <category term="GObject" scheme="http://example.com/tags/GObject/"/>
    
  </entry>
  
  <entry>
    <title>Deepstream 检测安全帽👷</title>
    <link href="http://example.com/2021/07/10/week-2-2/"/>
    <id>http://example.com/2021/07/10/week-2-2/</id>
    <published>2021-07-10T05:32:29.000Z</published>
    <updated>2023-12-31T18:44:13.911Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Yolov3-检测安全帽"><a href="#Yolov3-检测安全帽" class="headerlink" title="Yolov3 检测安全帽"></a>Yolov3 检测安全帽</h1><h2 id="运行自带yolov3示例"><a href="#运行自带yolov3示例" class="headerlink" title="运行自带yolov3示例"></a>运行自带yolov3示例</h2><h3 id="环境和示例说明"><a href="#环境和示例说明" class="headerlink" title="环境和示例说明"></a>环境和示例说明</h3><p><strong>该示例是Deepstream-5.0在Jetson Xavier NX上运行，具体环境部署可以参见<a href="https://xuhuigeren.github.io/2021/07/02/week-1/">这里</a>.</strong></p><p>示例文件在<code>deepstram-5.0\sources\objectDetector_Yolo</code>目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">|-- objectDetector_Yolo</span><br><span class="line">|   |-- config_infer_primary_yoloV2.txt</span><br><span class="line">|   |-- config_infer_primary_yoloV2_tiny.txt</span><br><span class="line">|   |-- config_infer_primary_yoloV3.txt</span><br><span class="line">|   |-- config_infer_primary_yoloV3_tiny.txt</span><br><span class="line">|   |-- deepstream_app_config_yoloV2.txt</span><br><span class="line">|   |-- deepstream_app_config_yoloV2_tiny.txt</span><br><span class="line">|   |-- deepstream_app_config_yoloV3.txt</span><br><span class="line">|   |-- deepstream_app_config_yoloV3_tiny.txt</span><br><span class="line">|   |-- labels.txt</span><br><span class="line">|   |-- prebuild.sh</span><br><span class="line">|   |-- README</span><br><span class="line">|   |-- yolov3-calibration.table.trt7.0</span><br><span class="line">|   |-- nvdsinfer_custom_impl_Yolo             </span><br><span class="line">|       |-- Makefile</span><br><span class="line">|       |-- kernels.cu</span><br><span class="line">|       |-- nvdsinfer_yolo_engine.cpp</span><br><span class="line">|       |-- nvdsparsebbox_Yolo.cpp</span><br><span class="line">|       |-- trt_utils.cpp</span><br><span class="line">|       |-- trt_utils.h</span><br><span class="line">|       |-- yolo.cpp</span><br><span class="line">|       |-- yolo.h</span><br><span class="line">|       |-- yoloPlugins.cpp</span><br><span class="line">|       |-- yoloPlugins.h</span><br></pre></td></tr></table></figure><p><strong>当然是先康康<code>README</code>，果然写的非常细致详尽，介绍了文件目录中每个文件的含义</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Sample contents:</span><br><span class="line">- deepstream_app_config_yolo[V3,V3_tiny,V2,V2_tiny,tlt].txt - DeepStream reference</span><br><span class="line">  app configuration file for using YoloV2/yoloV2-tiny/yolo/yolo-tiny/tlt model</span><br><span class="line">  as the primary detector.</span><br><span class="line">- config_infer_primary_yolo[V3,V3_tiny,V2,V2_tiny,tlt].txt - Configuration file for the GStreamer</span><br><span class="line">  nvinfer plugin for the Yolo detector model.</span><br><span class="line">- yolov3-calibration.table.trt7.0 - yoloV3 INT8 calibration binary on TensorRT 7.0+</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/nvdsinfer_yolo_engine.cpp -</span><br><span class="line">  Implementation of &#x27;NvDsInferCreateModelParser&#x27;/IModelParser for nvdsinfer to</span><br><span class="line">  parse custom models. Alternatively, also contains implementation of</span><br><span class="line">  &#x27;NvDsInferYoloCudaEngineGet&#x27; for nvdsinfer to directly create cuda engine.</span><br><span class="line">  To use the &#x27;NvDsInferYoloCudaEngineGet&#x27; interface, enable the macro</span><br><span class="line">  USE_CUDA_ENGINE_GET_API in nvdsinfer_yolo_engine.cpp</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/nvdsparsebbox_Yolo.cpp - Output layer</span><br><span class="line">  parsing function for detected objects for the Yolo model.</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/yoloPlugins.h -</span><br><span class="line">  Declaration of YoloLayerV3 and YoloLayerV3PluginCreator.</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/yoloPlugins.cpp -</span><br><span class="line">  Implementation of YoloLayerV3 and YoloLayerV3PluginCreator.</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/kernels.cu - Implementation of cuda kernels for</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/trt_utils.h - Utilities to setup tensorRT networks</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/trt_utils.cpp - Implementation of Utilities to setup</span><br><span class="line">   tensorRT networks</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/yolo.h - Interface to create Yolo Cuda-Engine</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/yolo.cpp - Implementation to create Yolo Cuda-Engine</span><br></pre></td></tr></table></figure><p><strong>下载权重和配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Pre-requisites:</span><br><span class="line">- Download yolo config and weights files</span><br><span class="line">  $ ./prebuild.sh         # 可以把脚本里的不需要的部分注释掉，提高下载速度。</span><br><span class="line">- Set correct yolo config/weights file in config_infer_primary_yolo[...].txt.</span><br><span class="line">    custom-network-config # path to yolo config</span><br><span class="line">    model-file # path to yolo weights</span><br><span class="line">- Enable INT8 precision detection if there is a calibration cache file, update</span><br><span class="line">  config_infer_primary_yolo[...].txt.</span><br><span class="line">    int8-calib-file=yolo[...]-calibration.table.trt5.1</span><br><span class="line">- Other INT8 precision calibration table need to be calibrated by user.</span><br><span class="line">- The yolo-tlt sample makes use of a few TensorRT OSS plugins. Download the</span><br><span class="line">  TensorRT OSS repo (https://github.com/NVIDIA/TensorRT/) and checkout the</span><br><span class="line">  &#x27;release/7.0&#x27; branch. Follow the instructions in the README to build the</span><br><span class="line">  plugin library &#x27;libnvinfer_plugin.so.7.0.0&#x27; corresponding to your dGPU/Jetson</span><br><span class="line">  platform. This library needs to be used with LD_PRELOAD to let nvinfer plugin</span><br><span class="line">  access the TRT OSS plugin layers.</span><br><span class="line">- Set the path of the etlt model (tlt-encoded-model) and the tlt model key</span><br><span class="line">  (tlt-model-key) in config_infer_primary_yolo_tlt.txt before running the sample.</span><br></pre></td></tr></table></figure><p><strong>编译工程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Compile the custom library:</span><br><span class="line">  # Based on the API to use &#x27;NvDsInferCreateModelParser&#x27; or &#x27;NvDsInferCudaEngineGet&#x27;</span><br><span class="line">  # set the macro USE_CUDA_ENGINE_GET_API to 0 or 1 in</span><br><span class="line">  # nvdsinfer_custom_impl_Yolo/nvdsinfer_yolo_engine.cpp</span><br><span class="line"></span><br><span class="line">  # Export correct CUDA version (e.g. 10.2, 10.1)</span><br><span class="line">  $ export CUDA_VER=10.2</span><br><span class="line">  $ make -C nvdsinfer_custom_impl_Yolo</span><br><span class="line">  这时候会在nvdsinfer_custom_impl_Yolo文件夹里生成.so文件</span><br></pre></td></tr></table></figure><p><strong>运行示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Run the sample:</span><br><span class="line">The &quot;nvinfer&quot; config file config_infer_primary_yolo.txt specifies the path to</span><br><span class="line">the custom library and the custom output parsing function through the properties</span><br><span class="line">&quot;custom-lib-path&quot; and &quot;parse-bbox-func-name&quot; respectively.</span><br><span class="line">The first-time a &quot;model_b1_int8.engine&quot; would be generated as the engine-file</span><br><span class="line"></span><br><span class="line">- With deepstream-app</span><br><span class="line">  $ deepstream-app -c deepstream_app_config_yoloV3.txt</span><br><span class="line">  $ deepstream-app -c deepstream_app_config_yoloV3_tiny.txt</span><br><span class="line">  $ deepstream-app -c deepstream_app_config_yoloV2.txt</span><br><span class="line">  $ deepstream-app -c deepstream_app_config_yoloV2_tiny.txt</span><br><span class="line">  $ LD_PRELOAD=&lt;path-to-TRT-OSS-libnvinfer_plugin.so.7.0.0&gt; deepstream-app -c deepstream_app_config_yolo_tlt.txt</span><br></pre></td></tr></table></figure><p><strong>检测结果</strong></p><p><img src="/2021/07/10/week-2-2/2-1.png" alt="1"></p><h3 id="程序注释和理解"><a href="#程序注释和理解" class="headerlink" title="程序注释和理解"></a>程序注释和理解</h3><p>该程序分为两个部分：</p><ul><li><p>一部分是<code>tensorRT</code>部分 就是<code>sources\objectDetector_Yolo</code>文件夹里的，编译后会生产动态库文件。也就是<code>libnvdsinfer_custom_impl_Yolo.so</code></p></li><li><p>另一部分是<code>deepstream</code>的文件，在<code>sources\apps\sample_apps\deepstream-app</code>文件夹里。</p></li></ul><p>首先说明下<code>tensorRT</code>几个文件的关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- kernels.cucuda核最底层的实现</span><br><span class="line">|-- nvdsinfer_yolo_engine.cpp根据网络类型创建引擎,生成tensorrt engine</span><br><span class="line">|-- nvdsparsebbox_Yolo.cppyolo目标检测结果的输出,推理后的后处理部分</span><br><span class="line">|-- trt_utils.cpp建立tensorRT网络的部分</span><br><span class="line">|-- trt_utils.h</span><br><span class="line">|-- yolo.cpp创建引擎、创建网络等的具体实现</span><br><span class="line">|-- yolo.h</span><br><span class="line">|-- yoloPlugins.cpp模型搭建的一些组件以及相应的实现</span><br><span class="line">|-- yoloPlugins.h</span><br></pre></td></tr></table></figure><p><img src="/2021/07/10/week-2-2/2-2.png" alt="1"></p><p>其中yolo.cpp实现了网络层的搭建，是核心代码部分,下面代码实现了卷积层的搭建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是卷积层</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_ConfigBlocks.at(i).at(<span class="string">&quot;type&quot;</span>) == <span class="string">&quot;convolutional&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">//获取tensor的大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> inputVol = dimsToString(previous-&gt;getDimensions());</span><br><span class="line">    nvinfer1::ILayer* out;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> layerType;<span class="comment">//保存网络类型</span></span><br><span class="line">    <span class="comment">// check if batch_norm enabled</span></span><br><span class="line">    <span class="keyword">if</span> (m_ConfigBlocks.at(i).find(<span class="string">&quot;batch_normalize&quot;</span>) !=</span><br><span class="line">    m_ConfigBlocks.at(i).end()) &#123;</span><br><span class="line">    <span class="comment">//有BN的卷积层</span></span><br><span class="line">    out = netAddConvBNLeaky(i, m_ConfigBlocks.at(i), weights,</span><br><span class="line">    m_TrtWeights, weightPtr, channels, previous, &amp;network);</span><br><span class="line">    layerType = <span class="string">&quot;conv-bn-leaky&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    out = netAddConvLinear(i, m_ConfigBlocks.at(i), weights,</span><br><span class="line">    m_TrtWeights, weightPtr, channels, previous, &amp;network);</span><br><span class="line">    layerType = <span class="string">&quot;conv-linear&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    previous = out-&gt;getOutput(<span class="number">0</span>);<span class="comment">//获取该层的输出</span></span><br><span class="line">    assert(previous != <span class="literal">nullptr</span>);</span><br><span class="line">    channels = getNumChannels(previous);</span><br><span class="line">    <span class="comment">//获取tensor的大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> outputVol = dimsToString(previous-&gt;getDimensions());</span><br><span class="line">    <span class="comment">//保存相应的层输出</span></span><br><span class="line">    tensorOutputs.push_back(out-&gt;getOutput(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//打印参数</span></span><br><span class="line">    printLayerInfo(layerIndex, layerType, inputVol, outputVol, <span class="built_in">std</span>::to_string(weightPtr));</span><br></pre></td></tr></table></figure><p>下面说明一下deepstream部分代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- deepstream-app</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- README</span><br><span class="line">|   |-- deepstream_app.cpipeline的一些操作在这里</span><br><span class="line">|   |-- deepstream_app.h</span><br><span class="line">|   |-- deepstream_app_config_parser.c 配置文件的解析</span><br><span class="line">|   |-- deepstream_app_main.c deepstream主函数</span><br><span class="line"></span><br><span class="line">deepstream会调用动态库文件libnvdsinfer_custom_impl_Yolo.so实现网络层的搭建等功能</span><br></pre></td></tr></table></figure><p>再来看下deepstream_app_main.c主函数部分的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GOptionContext *ctx = <span class="literal">NULL</span>;</span><br><span class="line">  GOptionGroup *group = <span class="literal">NULL</span>;</span><br><span class="line">  GError *error = <span class="literal">NULL</span>;</span><br><span class="line">  guint i;</span><br><span class="line">  ctx = g_option_context_new (<span class="string">&quot;Nvidia DeepStream Demo&quot;</span>);</span><br><span class="line">  group = g_option_group_new (<span class="string">&quot;abc&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  g_option_group_add_entries (group, entries);  <span class="comment">//把entries添加到group</span></span><br><span class="line">  g_option_context_set_main_group (ctx, group); <span class="comment">//group添加到ctx</span></span><br><span class="line">  g_option_context_add_group (ctx, gst_init_get_option_group ());</span><br><span class="line">  GST_DEBUG_CATEGORY_INIT (NVDS_APP, <span class="string">&quot;NVDS_APP&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);   </span><br><span class="line">  <span class="comment">// 解析命令行参数，识别已添加到上下文的选项</span></span><br><span class="line">  <span class="keyword">if</span> (!g_option_context_parse (ctx, &amp;argc, &amp;argv, &amp;error)) &#123;</span><br><span class="line">    NVGSTDS_ERR_MSG_V (<span class="string">&quot;%s&quot;</span>, error-&gt;message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (print_version) &#123;</span><br><span class="line">    g_print (<span class="string">&quot;deepstream-app version %d.%d.%d\n&quot;</span>,</span><br><span class="line">        NVDS_APP_VERSION_MAJOR, NVDS_APP_VERSION_MINOR, NVDS_APP_VERSION_MICRO);</span><br><span class="line">    nvds_version_print ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (print_dependencies_version) &#123;</span><br><span class="line">    g_print (<span class="string">&quot;deepstream-app version %d.%d.%d\n&quot;</span>,</span><br><span class="line">        NVDS_APP_VERSION_MAJOR, NVDS_APP_VERSION_MINOR, NVDS_APP_VERSION_MICRO);</span><br><span class="line">    nvds_version_print ();</span><br><span class="line">    nvds_dependencies_version_print ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cfg_files) &#123;<span class="comment">//一般执行这项</span></span><br><span class="line">    num_instances = g_strv_length (cfg_files);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (input_files) &#123;</span><br><span class="line">    num_input_files = g_strv_length (input_files);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!cfg_files || num_instances == <span class="number">0</span>) &#123;</span><br><span class="line">    NVGSTDS_ERR_MSG_V (<span class="string">&quot;Specify config file with -c option&quot;</span>);</span><br><span class="line">    return_value = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">    appCtx[i] = g_malloc0 (<span class="keyword">sizeof</span> (AppCtx));</span><br><span class="line">    appCtx[i]-&gt;person_class_id = <span class="number">-1</span>;</span><br><span class="line">    appCtx[i]-&gt;car_class_id = <span class="number">-1</span>;</span><br><span class="line">    appCtx[i]-&gt;index = i;</span><br><span class="line">    appCtx[i]-&gt;active_source_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (show_bbox_text) &#123;</span><br><span class="line">      appCtx[i]-&gt;show_bbox_text = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (input_files &amp;&amp; input_files[i]) &#123;</span><br><span class="line">      appCtx[i]-&gt;config.multi_source_config[<span class="number">0</span>].uri =</span><br><span class="line">          g_strdup_printf (<span class="string">&quot;file://%s&quot;</span>, input_files[i]);</span><br><span class="line">      g_free (input_files[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 解析配置文件内容，这是个重点函数</span></span><br><span class="line">    <span class="keyword">if</span> (!parse_config_file (&amp;appCtx[i]-&gt;config, cfg_files[i])) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;Failed to parse config file &#x27;%s&#x27;&quot;</span>, cfg_files[i]);</span><br><span class="line">      appCtx[i]-&gt;return_value = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 针对配置进行创建pipeline，这里是关键部分deepstream部分</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!create_pipeline (appCtx[i], <span class="literal">NULL</span>,</span><br><span class="line">            all_bbox_generated, perf_cb, overlay_graphics)) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;Failed to create pipeline&quot;</span>);</span><br><span class="line">      return_value = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  main_loop = g_main_loop_new (<span class="literal">NULL</span>, FALSE);</span><br><span class="line">  _intr_setup ();</span><br><span class="line">  g_timeout_add (<span class="number">400</span>, check_for_interrupt, <span class="literal">NULL</span>);</span><br><span class="line">  g_mutex_init (&amp;disp_lock);</span><br><span class="line">  <span class="comment">// 这部分是显示相关的内容</span></span><br><span class="line">  display = XOpenDisplay (<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">    guint j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gst_element_set_state (appCtx[i]-&gt;pipeline.pipeline,</span><br><span class="line">            GST_STATE_PAUSED) == GST_STATE_CHANGE_FAILURE) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;Failed to set pipeline to PAUSED&quot;</span>);</span><br><span class="line">      return_value = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!appCtx[i]-&gt;config.tiled_display_config.enable)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; appCtx[i]-&gt;config.num_sink_sub_bins; j++) &#123;</span><br><span class="line">      XTextProperty xproperty;</span><br><span class="line">      gchar *title;</span><br><span class="line">      guint width, height;</span><br><span class="line">      XSizeHints hints = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="keyword">if</span> (!GST_IS_VIDEO_OVERLAY (appCtx[i]-&gt;pipeline.instance_bins[<span class="number">0</span>].</span><br><span class="line">              sink_bin.sub_bins[j].sink)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!display) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;Could not open X Display&quot;</span>);</span><br><span class="line">        return_value = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">// 显示设置</span></span><br><span class="line">      <span class="keyword">if</span> (appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.width)</span><br><span class="line">        width =</span><br><span class="line">            appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.width;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        width = appCtx[i]-&gt;config.tiled_display_config.width;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.height)</span><br><span class="line">        height =</span><br><span class="line">            appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.height;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        height = appCtx[i]-&gt;config.tiled_display_config.height;</span><br><span class="line">      width = (width) ? width : DEFAULT_X_WINDOW_WIDTH;</span><br><span class="line">      height = (height) ? height : DEFAULT_X_WINDOW_HEIGHT;</span><br><span class="line">      hints.flags = PPosition | PSize;</span><br><span class="line">      hints.x = appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.offset_x;</span><br><span class="line">      hints.y = appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.offset_y;</span><br><span class="line">      hints.width = width;</span><br><span class="line">      hints.height = height;</span><br><span class="line">      windows[i] =</span><br><span class="line">          XCreateSimpleWindow (display, RootWindow (display,</span><br><span class="line">              DefaultScreen (display)), hints.x, hints.y, width, height, <span class="number">2</span>,</span><br><span class="line">              <span class="number">0x00000000</span>, <span class="number">0x00000000</span>);</span><br><span class="line">      XSetNormalHints(display, windows[i], &amp;hints);</span><br><span class="line">      <span class="keyword">if</span> (num_instances &gt; <span class="number">1</span>)</span><br><span class="line">        title = g_strdup_printf (APP_TITLE <span class="string">&quot;-%d&quot;</span>, i);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        title = g_strdup (APP_TITLE);</span><br><span class="line">      <span class="keyword">if</span> (XStringListToTextProperty ((<span class="keyword">char</span> **) &amp;title, <span class="number">1</span>, &amp;xproperty) != <span class="number">0</span>) &#123;</span><br><span class="line">        XSetWMName (display, windows[i], &amp;xproperty);</span><br><span class="line">        XFree (xproperty.value);</span><br><span class="line">      &#125;</span><br><span class="line">      XSetWindowAttributes attr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">      <span class="keyword">if</span> ((appCtx[i]-&gt;config.tiled_display_config.enable &amp;&amp;</span><br><span class="line">              appCtx[i]-&gt;config.tiled_display_config.rows *</span><br><span class="line">              appCtx[i]-&gt;config.tiled_display_config.columns == <span class="number">1</span>) ||</span><br><span class="line">          (appCtx[i]-&gt;config.tiled_display_config.enable == <span class="number">0</span> &amp;&amp;</span><br><span class="line">              appCtx[i]-&gt;config.num_source_sub_bins == <span class="number">1</span>)) &#123;</span><br><span class="line">        attr.event_mask = KeyPress;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        attr.event_mask = ButtonPress | KeyRelease;</span><br><span class="line">      &#125;</span><br><span class="line">      XChangeWindowAttributes (display, windows[i], CWEventMask, &amp;attr);</span><br><span class="line"></span><br><span class="line">      Atom wmDeleteMessage = XInternAtom (display, <span class="string">&quot;WM_DELETE_WINDOW&quot;</span>, False);</span><br><span class="line">      <span class="keyword">if</span> (wmDeleteMessage != None) &#123;</span><br><span class="line">        XSetWMProtocols (display, windows[i], &amp;wmDeleteMessage, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      XMapRaised (display, windows[i]);</span><br><span class="line">      XSync (display, <span class="number">1</span>);       <span class="comment">//discard the events for now</span></span><br><span class="line">      gst_video_overlay_set_window_handle (GST_VIDEO_OVERLAY (appCtx</span><br><span class="line">              [i]-&gt;pipeline.instance_bins[<span class="number">0</span>].sink_bin.sub_bins[j].sink),</span><br><span class="line">          (gulong) windows[i]);</span><br><span class="line">      gst_video_overlay_expose (GST_VIDEO_OVERLAY (appCtx[i]-&gt;</span><br><span class="line">              pipeline.instance_bins[<span class="number">0</span>].sink_bin.sub_bins[j].sink));</span><br><span class="line">      <span class="keyword">if</span> (!x_event_thread)</span><br><span class="line">        x_event_thread = g_thread_new (<span class="string">&quot;nvds-window-event-thread&quot;</span>,</span><br><span class="line">            nvds_x_event_thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Dont try to set playing state if error is observed */</span> </span><br><span class="line">  <span class="comment">// 发生错误的处理</span></span><br><span class="line">  <span class="keyword">if</span> (return_value != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (gst_element_set_state (appCtx[i]-&gt;pipeline.pipeline,</span><br><span class="line">              GST_STATE_PLAYING) == GST_STATE_CHANGE_FAILURE) &#123;</span><br><span class="line"></span><br><span class="line">        g_print (<span class="string">&quot;\ncan&#x27;t set pipeline to playing state.\n&quot;</span>);</span><br><span class="line">        return_value = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  print_runtime_commands ();</span><br><span class="line">  changemode (<span class="number">1</span>);</span><br><span class="line">  g_timeout_add (<span class="number">40</span>, event_thread_func, <span class="literal">NULL</span>);</span><br><span class="line">  g_main_loop_run (main_loop);</span><br><span class="line">  changemode (<span class="number">0</span>);</span><br><span class="line">done:</span><br><span class="line">  g_print (<span class="string">&quot;Quitting\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 下面是释放资源</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (appCtx[i]-&gt;return_value == <span class="number">-1</span>)</span><br><span class="line">      return_value = <span class="number">-1</span>;</span><br><span class="line">    destroy_pipeline (appCtx[i]);</span><br><span class="line"></span><br><span class="line">    g_mutex_lock (&amp;disp_lock);</span><br><span class="line">    <span class="keyword">if</span> (windows[i])</span><br><span class="line">      XDestroyWindow (display, windows[i]);</span><br><span class="line">    windows[i] = <span class="number">0</span>;</span><br><span class="line">    g_mutex_unlock (&amp;disp_lock);</span><br><span class="line">    g_free (appCtx[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  g_mutex_lock (&amp;disp_lock);</span><br><span class="line">  <span class="keyword">if</span> (display)</span><br><span class="line">    XCloseDisplay (display);</span><br><span class="line">  display = <span class="literal">NULL</span>;</span><br><span class="line">  g_mutex_unlock (&amp;disp_lock);</span><br><span class="line">  g_mutex_clear (&amp;disp_lock);</span><br><span class="line">  <span class="keyword">if</span> (main_loop) &#123;</span><br><span class="line">    g_main_loop_unref (main_loop);<span class="comment">//执行循环推理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ctx) &#123;</span><br><span class="line">    g_option_context_free (ctx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (return_value == <span class="number">0</span>) &#123;</span><br><span class="line">    g_print (<span class="string">&quot;App run successful\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    g_print (<span class="string">&quot;App run failed\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  gst_deinit ();</span><br><span class="line">  <span class="keyword">return</span> return_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>deepstream_app_config_parser.c</code>解析配置文件的代码，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">gboolean</span></span><br><span class="line"><span class="function"><span class="title">parse_config_file</span> <span class="params">(NvDsConfig *config, gchar *cfg_file_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GKeyFile *cfg_file = g_key_file_new ();</span><br><span class="line">  GError *error = <span class="literal">NULL</span>;</span><br><span class="line">  gboolean ret = FALSE;</span><br><span class="line">  gchar **groups = <span class="literal">NULL</span>;</span><br><span class="line">  gchar **group;</span><br><span class="line">  guint i, j;</span><br><span class="line"></span><br><span class="line">  config-&gt;source_list_enabled = FALSE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!APP_CFG_PARSER_CAT) &#123;</span><br><span class="line">    GST_DEBUG_CATEGORY_INIT (APP_CFG_PARSER_CAT, <span class="string">&quot;NVDS_CFG_PARSER&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!g_key_file_load_from_file (cfg_file, cfg_file_path, G_KEY_FILE_NONE,</span><br><span class="line">          &amp;error)) &#123;</span><br><span class="line">    GST_CAT_ERROR (APP_CFG_PARSER_CAT, <span class="string">&quot;Failed to load uri file: %s&quot;</span>,</span><br><span class="line">        error-&gt;message);</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (g_key_file_has_group (cfg_file, CONFIG_GROUP_SOURCE_LIST)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!parse_source_list (config, cfg_file, cfg_file_path)) &#123;</span><br><span class="line">      GST_CAT_ERROR (APP_CFG_PARSER_CAT, <span class="string">&quot;Failed to parse &#x27;%s&#x27; group&quot;</span>,</span><br><span class="line">          CONFIG_GROUP_SOURCE_LIST);</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    config-&gt;num_source_sub_bins = config-&gt;total_num_sources;</span><br><span class="line">    config-&gt;source_list_enabled = TRUE;</span><br><span class="line">    <span class="keyword">if</span> (!g_key_file_has_group (cfg_file, CONFIG_GROUP_SOURCE_ALL)) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;[source-attr-all] group not present.&quot;</span>);</span><br><span class="line">      ret = FALSE;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    g_key_file_remove_group (cfg_file, CONFIG_GROUP_SOURCE_LIST, &amp;error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (g_key_file_has_group (cfg_file, CONFIG_GROUP_SOURCE_ALL)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!parse_source (&amp;global_source_config,</span><br><span class="line">            cfg_file, CONFIG_GROUP_SOURCE_ALL, cfg_file_path)) &#123;</span><br><span class="line">      GST_CAT_ERROR (APP_CFG_PARSER_CAT, <span class="string">&quot;Failed to parse &#x27;%s&#x27; group&quot;</span>,</span><br><span class="line">          CONFIG_GROUP_SOURCE_LIST);</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!set_source_all_configs (config, cfg_file_path)) &#123;</span><br><span class="line">      ret = FALSE;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    g_key_file_remove_group (cfg_file, CONFIG_GROUP_SOURCE_ALL, &amp;error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 信息存储在里cfg_file里面</span></span><br><span class="line">  groups = g_key_file_get_groups (cfg_file, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//这里对应的是8项  </span></span><br><span class="line">  <span class="comment">//group[0]=application</span></span><br><span class="line">  <span class="comment">//group[1]=tiled-display</span></span><br><span class="line">  <span class="comment">//group[2]=source0</span></span><br><span class="line">  <span class="comment">//group[3]=sink0</span></span><br><span class="line">  <span class="comment">//group[4]=osd</span></span><br><span class="line">  <span class="comment">//group[5]=streammux</span></span><br><span class="line">  <span class="comment">//group[6]=primary-gie</span></span><br><span class="line">  <span class="comment">//group[7]=tracker</span></span><br><span class="line">  <span class="comment">//group[8]=tests</span></span><br><span class="line">  <span class="keyword">for</span> (group = groups; *group; group++) &#123;</span><br><span class="line">    gboolean parse_err = FALSE;</span><br><span class="line">    GST_CAT_DEBUG (APP_CFG_PARSER_CAT, <span class="string">&quot;Parsing group: %s&quot;</span>, *group);</span><br><span class="line">    <span class="comment">// application </span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_APP)) &#123;</span><br><span class="line">      parse_err = !parse_app (config, cfg_file, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// source0  </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*group, CONFIG_GROUP_SOURCE,</span><br><span class="line">            <span class="keyword">sizeof</span> (CONFIG_GROUP_SOURCE) - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;num_source_sub_bins == MAX_SOURCE_BINS) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d sources&quot;</span>, MAX_SOURCE_BINS);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      gchar *source_id_start_ptr = *group + <span class="built_in">strlen</span> (CONFIG_GROUP_SOURCE);</span><br><span class="line">      gchar *source_id_end_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      guint index =</span><br><span class="line">          g_ascii_strtoull (source_id_start_ptr, &amp;source_id_end_ptr, <span class="number">10</span>);</span><br><span class="line">      <span class="keyword">if</span> (source_id_start_ptr == source_id_end_ptr</span><br><span class="line">          || *source_id_end_ptr != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V</span><br><span class="line">            (<span class="string">&quot;Source group \&quot;[%s]\&quot; is not in the form \&quot;[source&lt;%%d&gt;]\&quot;&quot;</span>,</span><br><span class="line">            *group);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      guint source_id = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;source_list_enabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= config-&gt;total_num_sources) &#123;</span><br><span class="line">          NVGSTDS_ERR_MSG_V</span><br><span class="line">              (<span class="string">&quot;Invalid source group index %d, index cannot exceed %d&quot;</span>, index,</span><br><span class="line">              config-&gt;total_num_sources);</span><br><span class="line">          ret = FALSE;</span><br><span class="line">          <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        source_id = index;</span><br><span class="line">        NVGSTDS_INFO_MSG_V (<span class="string">&quot;Some parameters to be overwritten for group [%s]&quot;</span>,</span><br><span class="line">            *group);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        source_id = config-&gt;num_source_sub_bins;</span><br><span class="line">      &#125;</span><br><span class="line">      parse_err = !parse_source (&amp;config-&gt;multi_source_config[source_id],</span><br><span class="line">          cfg_file, *group, cfg_file_path);</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;source_list_enabled</span><br><span class="line">          &amp;&amp; config-&gt;multi_source_config[source_id].type ==</span><br><span class="line">          NV_DS_SOURCE_URI_MULTIPLE) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V</span><br><span class="line">            (<span class="string">&quot;MultiURI support not available if [source-list] is provided&quot;</span>);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;multi_source_config[source_id].enable</span><br><span class="line">          &amp;&amp; !config-&gt;source_list_enabled) &#123;</span><br><span class="line">        config-&gt;num_source_sub_bins++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// streammux</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_STREAMMUX)) &#123;</span><br><span class="line">      <span class="comment">// 存储到config-&gt;streammux_config中</span></span><br><span class="line">      parse_err = !parse_streammux (&amp;config-&gt;streammux_config, cfg_file, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// osd</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_OSD)) &#123;</span><br><span class="line">      parse_err = !parse_osd (&amp;config-&gt;osd_config, cfg_file);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// primary_gie</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_PRIMARY_GIE)) &#123;</span><br><span class="line">      parse_err =</span><br><span class="line">          !parse_gie (&amp;config-&gt;primary_gie_config, cfg_file,</span><br><span class="line">          CONFIG_GROUP_PRIMARY_GIE, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_TRACKER)) &#123;</span><br><span class="line">      parse_err = !parse_tracker (&amp;config-&gt;tracker_config, cfg_file, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*group, CONFIG_GROUP_SECONDARY_GIE,</span><br><span class="line">                  <span class="keyword">sizeof</span> (CONFIG_GROUP_SECONDARY_GIE) - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;num_secondary_gie_sub_bins == MAX_SECONDARY_GIE_BINS) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d secondary GIEs&quot;</span>, MAX_SECONDARY_GIE_BINS);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      parse_err =</span><br><span class="line">          !parse_gie (&amp;config-&gt;secondary_gie_sub_bin_config[config-&gt;</span><br><span class="line">                                  num_secondary_gie_sub_bins],</span><br><span class="line">                                  cfg_file, *group, cfg_file_path);</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;secondary_gie_sub_bin_config[config-&gt;num_secondary_gie_sub_bins].enable)&#123;</span><br><span class="line">        config-&gt;num_secondary_gie_sub_bins++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*group, CONFIG_GROUP_SINK, <span class="keyword">sizeof</span> (CONFIG_GROUP_SINK) - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;num_sink_sub_bins == MAX_SINK_BINS) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d sinks&quot;</span>, MAX_SINK_BINS);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      parse_err =</span><br><span class="line">          !parse_sink (&amp;config-&gt;</span><br><span class="line">          sink_bin_sub_bin_config[config-&gt;num_sink_sub_bins], cfg_file, *group,</span><br><span class="line">          cfg_file_path);</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;</span><br><span class="line">          sink_bin_sub_bin_config[config-&gt;num_sink_sub_bins].enable)&#123;</span><br><span class="line">        config-&gt;num_sink_sub_bins++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*group, CONFIG_GROUP_MSG_CONSUMER,</span><br><span class="line">        <span class="keyword">sizeof</span> (CONFIG_GROUP_MSG_CONSUMER) - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;num_message_consumers == MAX_MESSAGE_CONSUMERS) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d consumers&quot;</span>, MAX_MESSAGE_CONSUMERS);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      parse_err = !parse_msgconsumer (</span><br><span class="line">                    &amp;config-&gt;message_consumer_config[config-&gt;num_message_consumers],</span><br><span class="line">                    cfg_file, *group, cfg_file_path);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (config-&gt;message_consumer_config[config-&gt;num_message_consumers].enable) &#123;</span><br><span class="line">        config-&gt;num_message_consumers++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tiled-display</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_TILED_DISPLAY)) &#123;</span><br><span class="line">      parse_err = !parse_tiled_display (&amp;config-&gt;tiled_display_config, cfg_file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_IMG_SAVE)) &#123;</span><br><span class="line">      parse_err = !parse_image_save (&amp;config-&gt;image_save_config , cfg_file, *group, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_DSANALYTICS)) &#123;</span><br><span class="line">      parse_err = !parse_dsanalytics (&amp;config-&gt;dsanalytics_config, cfg_file, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_DSEXAMPLE)) &#123;</span><br><span class="line">      parse_err = !parse_dsexample (&amp;config-&gt;dsexample_config, cfg_file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_MSG_CONVERTER)) &#123;</span><br><span class="line">      parse_err = !parse_msgconv (&amp;config-&gt;msg_conv_config, cfg_file, *group, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// tests</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_TESTS)) &#123;</span><br><span class="line">      parse_err = !parse_tests (config, cfg_file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parse_err) &#123;</span><br><span class="line">      GST_CAT_ERROR (APP_CFG_PARSER_CAT, <span class="string">&quot;Failed to parse &#x27;%s&#x27; group&quot;</span>, *group);</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 二级网络处理</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; config-&gt;num_secondary_gie_sub_bins; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (config-&gt;secondary_gie_sub_bin_config[i].unique_id ==</span><br><span class="line">        config-&gt;primary_gie_config.unique_id) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;Non unique gie ids found&quot;</span>);</span><br><span class="line">      ret = FALSE;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; config-&gt;num_secondary_gie_sub_bins; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; config-&gt;num_secondary_gie_sub_bins; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;secondary_gie_sub_bin_config[i].unique_id ==</span><br><span class="line">          config-&gt;secondary_gie_sub_bin_config[j].unique_id) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;Non unique gie id %d found&quot;</span>,</span><br><span class="line">                            config-&gt;secondary_gie_sub_bin_config[i].unique_id);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 多输入源处理</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; config-&gt;num_source_sub_bins; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (config-&gt;multi_source_config[i].type == NV_DS_SOURCE_URI_MULTIPLE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;multi_source_config[i].num_sources &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        config-&gt;multi_source_config[i].num_sources = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; config-&gt;multi_source_config[i].num_sources; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (config-&gt;num_source_sub_bins == MAX_SOURCE_BINS) &#123;</span><br><span class="line">          NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d sources&quot;</span>, MAX_SOURCE_BINS);</span><br><span class="line">          ret = FALSE;</span><br><span class="line">          <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span> (&amp;config-&gt;multi_source_config[config-&gt;num_source_sub_bins],</span><br><span class="line">            &amp;config-&gt;multi_source_config[i],</span><br><span class="line">            <span class="keyword">sizeof</span> (config-&gt;multi_source_config[i]));</span><br><span class="line">        config-&gt;multi_source_config[config-&gt;num_source_sub_bins].type =</span><br><span class="line">            NV_DS_SOURCE_URI;</span><br><span class="line">        config-&gt;multi_source_config[config-&gt;num_source_sub_bins].uri =</span><br><span class="line">            g_strdup_printf (config-&gt;multi_source_config[config-&gt;</span><br><span class="line">                num_source_sub_bins].uri, j);</span><br><span class="line">        config-&gt;num_source_sub_bins++;</span><br><span class="line">      &#125;</span><br><span class="line">      config-&gt;multi_source_config[i].type = NV_DS_SOURCE_URI;</span><br><span class="line">      config-&gt;multi_source_config[i].uri =</span><br><span class="line">          g_strdup_printf (config-&gt;multi_source_config[i].uri, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = TRUE;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">  <span class="keyword">if</span> (cfg_file) &#123;</span><br><span class="line">    g_key_file_free (cfg_file);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (groups) &#123;</span><br><span class="line">    g_strfreev (groups);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    g_error_free (error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">    NVGSTDS_ERR_MSG_V (<span class="string">&quot;%s failed&quot;</span>, __func__);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是建立<code>pipeline</code>的代码，建立<code>pipeline</code>是属于<code>deepstream</code>的部分，里面包含了<code>tensorRT</code>的调用。配置文件当中的<code>[primary-gie]</code>是对推理引擎的相关配置。修改配置文件可以对模型参数进行设置。</p><h2 id="使用yolov3检测安全帽👷"><a href="#使用yolov3检测安全帽👷" class="headerlink" title="使用yolov3检测安全帽👷"></a>使用yolov3检测安全帽👷</h2><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>模型配置文件：<code>yolov3_half_helmet.cfg</code><br>模型权重文件：<code>yolov3_half_helmet.weights</code><br>模型类别：3  ， 0-正常头肩，1-保安头肩，2-安全帽头肩 见<code>helmet.names</code><br>测试视频文件：<code>test_helmet_1.mp4</code>    <code> test_personcount.mp4</code></p><h3 id="检测任务"><a href="#检测任务" class="headerlink" title="检测任务"></a>检测任务</h3><p>①使用<code>deepstream</code>构建一个<code>pipeline</code>，检测<code>test_helmet_1.mp4</code>，输出画面中正常头肩画红框，保安头肩画蓝框，安全帽头肩画绿框<br>②测试安全帽检测 前处理，推理，后处理所用的时间<br>③使用<code>deepstream</code>构建多线程<code>pipeline</code>，使用安全帽检测模型同时检测2个视频文件</p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>对于自定义数据的检测，需根据自己检测的类别修改如下文件</p><p>修改<code>nvdsinfer_custom_impl_Yolo/nvdsparsebbox_Yolo.cpp</code>文件中检测类别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 默认检测coco数据集80个类别，修改为你自己检测的类别</span><br><span class="line">static const int NUM_CLASSES_YOLO = 3;</span><br></pre></td></tr></table></figure><p>注意，修改完需要重新编译和运行生成链接的<code>.so</code>文件</p><p>修改<code>config_infer_primary_yoloV3.txt</code>文件，修改<code>cfg</code>和<code>weights</code>等文件，根据自己检测的类别设置<code>num-detected-classes</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[property]</span><br><span class="line">gpu-id=0</span><br><span class="line">net-scale-factor=0.0039215697906911373</span><br><span class="line">#0=RGB, 1=BGR</span><br><span class="line">model-color-format=0</span><br><span class="line">#修改cfg文件</span><br><span class="line">custom-network-config=yolov3_half_helmet_20200607.cfg</span><br><span class="line">#修改weights文件</span><br><span class="line">model-file=yolov3_half_helmet_20200607.weights</span><br><span class="line">#model-engine-file=yolov3_b1_gpu0_int8.engine</span><br><span class="line">#修改label文件</span><br><span class="line">labelfile-path=helmet_names.txt</span><br><span class="line">int8-calib-file=yolov3-calibration.table.trt7.0</span><br><span class="line">## 0=FP32, 1=INT8, 2=FP16 mode</span><br><span class="line">network-mode=1</span><br><span class="line">#模型类别:3 0-正常头肩，1-保安头肩，2-安全帽头肩</span><br><span class="line">num-detected-classes=3</span><br><span class="line">gie-unique-id=1</span><br><span class="line">network-type=0</span><br><span class="line">is-classifier=0</span><br><span class="line">## 0=Group Rectangles, 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering)</span><br><span class="line">cluster-mode=2</span><br><span class="line">maintain-aspect-ratio=1</span><br><span class="line">parse-bbox-func-name=NvDsInferParseCustomYoloV3</span><br><span class="line"># 编译的动态库路径</span><br><span class="line">custom-lib-path=nvdsinfer_custom_impl_Yolo/libnvdsinfer_custom_impl_Yolo.so</span><br><span class="line">engine-create-func-name=NvDsInferYoloCudaEngineGet</span><br><span class="line">#scaling-filter=0</span><br><span class="line">#scaling-compute-hw=0</span><br><span class="line"></span><br><span class="line">[class-attrs-all]</span><br><span class="line">nms-iou-threshold=0.3# NMS的阈值</span><br><span class="line">#threshold=0.7</span><br><span class="line">pre-cluster-threshold=0.7   # 检测框的过滤阈值</span><br></pre></td></tr></table></figure><p>修改<code>deepstream_app_config_yoloV3.txt</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">[application]</span><br><span class="line">enable-perf-measurement=1</span><br><span class="line">perf-measurement-interval-sec=5</span><br><span class="line">#gie-kitti-output-dir=streamscl</span><br><span class="line"></span><br><span class="line">[tiled-display]</span><br><span class="line">enable=1</span><br><span class="line">rows=1</span><br><span class="line">columns=1</span><br><span class="line">width=1280</span><br><span class="line">height=720</span><br><span class="line">gpu-id=0</span><br><span class="line">#(0): nvbuf-mem-default - Default memory allocated, specific to particular platform</span><br><span class="line">#(1): nvbuf-mem-cuda-pinned - Allocate Pinned/Host cuda memory, applicable for Tesla</span><br><span class="line">#(2): nvbuf-mem-cuda-device - Allocate Device cuda memory, applicable for Tesla</span><br><span class="line">#(3): nvbuf-mem-cuda-unified - Allocate Unified cuda memory, applicable for Tesla</span><br><span class="line">#(4): nvbuf-mem-surface-array - Allocate Surface Array memory, applicable for Jetson</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"></span><br><span class="line">[source0]</span><br><span class="line">enable=1</span><br><span class="line">#Type - 1=CameraV4L2 2=URI 3=MultiURI</span><br><span class="line">type=3</span><br><span class="line"># 修改文件位置</span><br><span class="line">uri=file://../../samples/streams/test_helmet_1.mp4</span><br><span class="line">num-sources=1</span><br><span class="line">gpu-id=0</span><br><span class="line"># (0): memtype_device   - Memory type Device</span><br><span class="line"># (1): memtype_pinned   - Memory type Host Pinned</span><br><span class="line"># (2): memtype_unified  - Memory type Unified</span><br><span class="line">cudadec-memtype=0</span><br><span class="line"></span><br><span class="line">[sink0]</span><br><span class="line">enable=1</span><br><span class="line">#Type - 1=FakeSink 2=EglSink 3=File</span><br><span class="line">type=2</span><br><span class="line">sync=0</span><br><span class="line">source-id=0</span><br><span class="line">gpu-id=0</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"></span><br><span class="line">[osd]</span><br><span class="line">enable=1</span><br><span class="line">gpu-id=0</span><br><span class="line">border-width=1</span><br><span class="line">text-size=15</span><br><span class="line">text-color=1;1;1;1;</span><br><span class="line">text-bg-color=0.3;0.3;0.3;1</span><br><span class="line">font=Serif</span><br><span class="line">show-clock=0</span><br><span class="line">clock-x-offset=800</span><br><span class="line">clock-y-offset=820</span><br><span class="line">clock-text-size=12</span><br><span class="line">clock-color=1;0;0;0</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"></span><br><span class="line">[streammux]</span><br><span class="line">gpu-id=0</span><br><span class="line">##Boolean property to inform muxer that sources are live</span><br><span class="line">live-source=0</span><br><span class="line">batch-size=1</span><br><span class="line">##time out in usec, to wait after the first buffer is available</span><br><span class="line">##to push the batch even if the complete batch is not formed</span><br><span class="line">batched-push-timeout=40000</span><br><span class="line">## Set muxer output width and height</span><br><span class="line">width=1920</span><br><span class="line">height=1080</span><br><span class="line">##Enable to maintain aspect ratio wrt source, and allow black borders, works</span><br><span class="line">##along with width, height properties</span><br><span class="line">enable-padding=0</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"></span><br><span class="line"># config-file property is mandatory for any gie section.</span><br><span class="line"># Other properties are optional and if set will override the properties set in</span><br><span class="line"># the infer config file.</span><br><span class="line">[primary-gie]</span><br><span class="line">enable=1</span><br><span class="line">gpu-id=0</span><br><span class="line">#model-engine-file=model_b1_gpu0_int8.engine</span><br><span class="line"># 修改标签文件</span><br><span class="line">labelfile-path=helmet_names.txt</span><br><span class="line">batch-size=1</span><br><span class="line">#Required by the app for OSD, not a plugin property</span><br><span class="line">bbox-border-color0=1;0;0;1</span><br><span class="line">bbox-border-color1=0;1;1;1</span><br><span class="line">bbox-border-color2=0;0;1;1</span><br><span class="line">bbox-border-color3=0;1;0;1</span><br><span class="line">interval=2</span><br><span class="line">gie-unique-id=1</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"># 修改config文件</span><br><span class="line">config-file=config_infer_helmet_yoloV3.txt</span><br><span class="line"></span><br><span class="line">[tracker]</span><br><span class="line">enable=1</span><br><span class="line">tracker-width=640</span><br><span class="line">tracker-height=384</span><br><span class="line">ll-lib-file=/opt/nvidia/deepstream/deepstream-5.0/lib/libnvds_mot_klt.so</span><br><span class="line"></span><br><span class="line">[tests]</span><br><span class="line">file-loop=0</span><br></pre></td></tr></table></figure><p>如果要检测多个视频，只要在<code>deepstream_app_config_yoloV3.txt</code>文件中添加<code>source</code>和<code>sink</code>并且一一对应即可。</p><h3 id="检测结果"><a href="#检测结果" class="headerlink" title="检测结果"></a>检测结果</h3><p>安全帽检测</p><p><img src="/2021/07/10/week-2-2/2-3.png" alt="18"></p><p>使用安全帽检测模型同时检测2个视频文件</p><p><img src="/2021/07/10/week-2-2/2-4.png" alt="18"></p><p>第一次运行生成<code>engine</code>，这是最耗时的地方，<code>engine</code>只在第一次运行生成，然后可以把<code>config_infer_primary_yoloV3.txt</code>文件中配置打开，多次运行时不必再生成<code>engine</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当这项配置打开时，这样只会在第一次生成引擎，后续启动会很快。</span><br><span class="line">model-engine-file=yolov3_b1_gpu0_int8.engine</span><br></pre></td></tr></table></figure><h2 id="测试时间"><a href="#测试时间" class="headerlink" title="测试时间"></a>测试时间</h2><p>测试安全帽检测 前处理，推理，后处理所用的时间这部分还没有完成。。。</p><p>尽量尽快补充完成！</p>]]></content>
    
    
    <summary type="html">Deepstream YoloV3检测安全帽</summary>
    
    
    
    <category term="Internship" scheme="http://example.com/categories/Internship/"/>
    
    
    <category term="Jetson" scheme="http://example.com/tags/Jetson/"/>
    
    <category term="Deepstreeam" scheme="http://example.com/tags/Deepstreeam/"/>
    
  </entry>
  
  <entry>
    <title>Installing  GStreamer</title>
    <link href="http://example.com/2021/07/09/week-2-1/"/>
    <id>http://example.com/2021/07/09/week-2-1/</id>
    <published>2021-07-09T13:01:50.000Z</published>
    <updated>2023-12-31T18:44:13.905Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Installing-GStreamer"><a href="#Installing-GStreamer" class="headerlink" title="Installing  GStreamer"></a>Installing  GStreamer</h1><h2 id="Installing-on-Linux"><a href="#Installing-on-Linux" class="headerlink" title="Installing on Linux"></a>Installing on Linux</h2><p><strong>系统：Ubuntu 16.04</strong></p><p>参照<a href="https://gstreamer.freedesktop.org/documentation/installing/on-linux.html?gi-language=c">官方文档</a>，运行以下命令，但是在我的笔记本和公司的台式机上似乎不太ok…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libgstreamer-plugins-bad1.0-dev gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio</span><br></pre></td></tr></table></figure><p><a href="https://samwhelp.github.io/note-ubuntu-18.04/read/howto/install-tool/gstreamer/">参考</a>了一位湾湾网友，运行以下命令成功安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools</span><br></pre></td></tr></table></figure><p><strong>Package</strong></p><ul><li><a href="https://packages.ubuntu.com/bionic/libgstreamer1.0-0">libgstreamer1.0-0</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-plugins-base">gstreamer1.0-plugins-base</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-plugins-good">gstreamer1.0-plugins-good</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-plugins-bad">gstreamer1.0-plugins-bad</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-plugins-ugly">gstreamer1.0-plugins-ugly</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-libav">gstreamer1.0-libav</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-doc">gstreamer1.0-doc</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-tools">gstreamer1.0-tools</a></li></ul><p><strong>验证安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep gstreamer</span><br></pre></td></tr></table></figure><p><strong>使用 GStreamer 构建应用程序</strong></p><p>为了编译 GStreamer 并使用 GStreamer 核心库的代码，需在<code>gcc</code>后添加以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --cflags --libs gstreamer-1.0</span><br></pre></td></tr></table></figure><p>如果使用其他 GStreamer 库，例如视频库，则必须在上述 gstreamer-1.0 之后添加其他包（例如，视频库的 gstreamer-video-1.0）</p><p><strong>获取tutorial’s source code</strong></p><p>可以使用以下命令git到本地，可以在文件目录<code>gst/examples/tutorials</code>中找到例程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.freedesktop.org/gstreamer/gst-docs</span><br></pre></td></tr></table></figure><p><strong>Building the tutorials</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc basic-tutorial-1.c -o basic-tutorial-1 `pkg-config --cflags --libs gstreamer-1.0`</span><br></pre></td></tr></table></figure><p><strong>Running the tutorials</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./basic-tutorial-1</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="/2021/07/09/week-2-1/2_1.png" alt="1"></p><p><strong>nice</strong>！</p><h2 id="Installing-on-Windows"><a href="#Installing-on-Windows" class="headerlink" title="Installing on Windows"></a>Installing on Windows</h2><p>首先参照<a href="https://gstreamer.freedesktop.org/documentation/installing/on-windows.html?gi-language=c">官方文档</a>安装，真的蛮心累的，英文我都能看懂，但就是搞不定。记录一下GStreamer on Windows的崎岖之路。</p><p><strong>环境：Win 10 + VS2017</strong></p><p><strong>1. 下载GStreamer</strong></p><p>选择MSVC 64-bit(有mingw可选)</p><p><a href="https://gstreamer.freedesktop.org/data/pkg/windows/1.18.4/msvc/gstreamer-1.0-msvc-x86_64-1.18.4.msi">gstreamer-1.0-msvc-x86_64-1.18.4.msi</a>               先装</p><p><a href="https://gstreamer.freedesktop.org/data/pkg/windows/1.18.4/msvc/gstreamer-1.0-devel-msvc-x86_64-1.18.4.msi">gstreamer-1.0-devel-msvc-x86_64-1.18.4.msi</a>    后装</p><p>安装的时候都选择<code>Complete</code>完整安装，默认会安装在剩余空间最大的盘符</p><p><strong>2. 配置系统变量</strong></p><p>首先将<code>glibconfig.h</code>文件拷贝到<code>include/glib-2.0</code>以及<code>include/glib-2.0/glib</code>目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|-- lib</span><br><span class="line">|   |-- glib-2.0</span><br><span class="line">|   |    -- include</span><br><span class="line">|   |        -- glibconfig.h 此文件拷贝到</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- include</span><br><span class="line">|     --glib-2.0 此目录下</span><br><span class="line">|        -- glib 以及此目录下</span><br></pre></td></tr></table></figure><p>添加用户变量</p><p><img src="/2021/07/09/week-2-1/2_3.png" alt="3"></p><p>添加系统变量</p><p><img src="/2021/07/09/week-2-1/2_4.png" alt="4"></p><p>Path中添加路径</p><p><img src="/2021/07/09/week-2-1/2_5.png" alt="5"></p><p><strong>3. 环境测试</strong></p><ul><li><p>影像测试，打开cmd运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-launch-1.0 videotestsrc ! videoconvert ! autovideosink</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/07/09/week-2-1/2_6.png" alt="6"></p><ul><li><p>撞球测试，打开cmd运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-launch-1.0 -v videotestsrc pattern=ball ! video/x-raw,width=320,height=240 ! videoconvert ! tee ! autovideosink device=0</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_7.png" alt="7"></p></li></ul><p>至此，GStreamer的MSCV环境ok，接下来在VS2017配置GStreamer</p><p><strong>4. VS2017配置GStreamer</strong></p><p>还是之前下载的<a href="https://medium.com/r/?url=https://gitlab.freedesktop.org/gstreamer/gst-docs/">gst-docs</a>，用VS打开，双击<code>tutorials.sln</code></p><p><img src="/2021/07/09/week-2-1/2_8.png" alt="8"></p><p><code>tutorials</code>给的是<code>VS2010</code>的例程，当然要升级一下啦</p><p><img src="/2021/07/09/week-2-1/2_9.png" alt="9"></p><p>打开后是这样滴</p><p><img src="/2021/07/09/week-2-1/2_9_1.png" alt="9_1"></p><p>站起来活动一下，直直腰可以开始啦，一上来全是<code>Errors</code>，能运行才奇怪捏。。。</p><p><img src="/2021/07/09/week-2-1/2_10.png" alt="10"></p><p>重点来了，第一次给<code>VS2017</code>配置第三方库</p><p>① 解决方案资源管理器里选择项目名，右键项目，选择属性</p><p>在配置属性——调试——工作目录 增加如下目录(选择活动(x64)平台哦，接下来都是)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\gstreamer\1.0\msvc_x86_64\bin</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_11.png" alt="11"></p><p>②在C/C++ —— 常规——附加包含目录 增加如下目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\gstreamer\1.0\msvc_x86_64\include\gstreamer-1.0</span><br><span class="line">D:\gstreamer\1.0\msvc_x86_64\include\glib-2.0</span><br><span class="line">D:\gstreamer\1.0\msvc_x86_64\include\libxml2</span><br><span class="line">D:\gstreamer\1.0\msvc_x86_64\include</span><br><span class="line">D:\gstreamer\1.0\msvc_x86_64\lib\glib-2.0\include</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_12.png" alt="12"></p><p>③在链接器—-常规—-附加库目录，增加 如下目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\gstreamer\1.0\msvc_x86_64\lib</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_13.png" alt="13"></p><p>④在链接器—-输入—–附加依赖性 增加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gobject-2.0.lib</span><br><span class="line">glib-2.0.lib</span><br><span class="line">gstreamer-1.0.lib</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_14.png" alt="14"></p><p>测试一下，运行一下<code>basic-tutorial-1.c</code>，没有报错了，撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> </p><p><img src="/2021/07/09/week-2-1/2_15.png" alt="15"></p><p>运行结果</p><p><img src="/2021/07/09/week-2-1/2_17.png" alt="17"></p><p><code>basic-tutorial-1.c</code>的代码就先不解读啦，里面注释很清晰了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GstElement *pipeline;</span><br><span class="line">GstBus *bus;</span><br><span class="line">GstMessage *msg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize GStreamer */</span></span><br><span class="line">gst_init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Build the pipeline */</span></span><br><span class="line">pipeline =</span><br><span class="line">gst_parse_launch</span><br><span class="line">(<span class="string">&quot;playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm&quot;</span>,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Start playing */</span></span><br><span class="line">gst_element_set_state(pipeline, GST_STATE_PLAYING);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait until error or EOS */</span></span><br><span class="line">bus = gst_element_get_bus(pipeline);</span><br><span class="line">msg =</span><br><span class="line">gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE,</span><br><span class="line">GST_MESSAGE_ERROR | GST_MESSAGE_EOS);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free resources */</span></span><br><span class="line"><span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">gst_message_unref(msg);</span><br><span class="line">gst_object_unref(bus);</span><br><span class="line">gst_element_set_state(pipeline, GST_STATE_NULL);</span><br><span class="line">gst_object_unref(pipeline);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>GStreamer on Windows的安装至此算是搞定了，还是有花蛮多精力的！No pains, no gains. 接下来还要学写GStreamer插件，能写好的再记录一下！</p><p><strong>参考</strong></p><p><a href="https://gstreamer.freedesktop.org/data/pkg/windows/1.18.4/msvc/">https://gstreamer.freedesktop.org/data/pkg/windows/1.18.4/msvc/</a></p><p><a href="https://gstreamer.freedesktop.org/documentation/installing/index.html?gi-language=c">https://gstreamer.freedesktop.org/documentation/installing/index.html?gi-language=c</a></p><p><a href="https://www.cnblogs.com/0-lingdu/p/12718613.html">https://www.cnblogs.com/0-lingdu/p/12718613.html</a></p><p><a href="https://blog.csdn.net/kongxingxing/article/details/104270463">https://blog.csdn.net/kongxingxing/article/details/104270463</a></p><p><a href="https://blog.csdn.net/fly_bear_unknown/article/details/113917633">https://blog.csdn.net/fly_bear_unknown/article/details/113917633</a></p>]]></content>
    
    
    <summary type="html">GStreamer在Ubuntu和Windows上安装</summary>
    
    
    
    <category term="Internship" scheme="http://example.com/categories/Internship/"/>
    
    
    <category term="GStreamer" scheme="http://example.com/tags/GStreamer/"/>
    
  </entry>
  
  <entry>
    <title>Jetson 部署 Deepstream</title>
    <link href="http://example.com/2021/07/02/week-1/"/>
    <id>http://example.com/2021/07/02/week-1/</id>
    <published>2021-07-02T12:13:16.000Z</published>
    <updated>2023-12-31T18:44:13.894Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Jetson-部署-Deep-stream"><a href="#Jetson-部署-Deep-stream" class="headerlink" title="Jetson 部署 Deep stream"></a>Jetson 部署 Deep stream</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="查看Jetson信息"><a href="#查看Jetson信息" class="headerlink" title="查看Jetson信息"></a><strong>查看Jetson信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo pip3 install jetson-stats</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jtop</span></span><br></pre></td></tr></table></figure><p><img src="/2021/07/02/week-1/01.png" alt="01"></p><h3 id="Jetson-Setup"><a href="#Jetson-Setup" class="headerlink" title="Jetson Setup"></a><strong>Jetson Setup</strong></h3><p>如果是 Jetson Nano 或者 Jetson Xavier NX developer kit, 从<a href="https://developer.nvidia.com/embedded/jetpack">JetPack SDK</a>下载 SD card image，这其中包含了 CUDA, TensorRT and cuDNN.</p><h3 id="命令行工具nvpmodel"><a href="#命令行工具nvpmodel" class="headerlink" title="命令行工具nvpmodel"></a><strong>命令行工具nvpmodel</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo nvpmodel --query</span></span><br><span class="line">NV Fan Mode:cool</span><br><span class="line">NV Power Mode: MODE_15W_2CORE</span><br><span class="line">0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到模式2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo nvpmodel -m 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最大化Xavier性能</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo jetson_clocks</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前设置：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo jetson_clocks --show</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复以前的设置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo jetson_clocks --restore</span></span><br></pre></td></tr></table></figure><h3 id="查看操作系统信息"><a href="#查看操作系统信息" class="headerlink" title="查看操作系统信息"></a><strong>查看操作系统信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux查看版本当前操作系统 内核信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> uname --a</span></span><br><span class="line">Linux name-desktop 4.9.140-tegra #1 SMP PREEMPT Thu Jun 25 21:22:12 PDT 2020 aarch64 aarch64 aarch64 GNU/Linux</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux查看当前操作系统 版本信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/version</span></span><br><span class="line">Linux version 4.9.140-tegra (buildbrain@mobile-u64-3357) (gcc version 7.3.1 20180425 [linaro-7.3-2018.05 revision d29120a424ecfbc167ef90065c0eeb7f91977701] (Linaro GCC 7.3-2018.05) ) #1 SMP PREEMPT Thu Jun 25 21:22:12 PDT 2020</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux查看版本当前操作系统 发行版信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/issue</span></span><br><span class="line">Ubuntu 18.04.5 LTS \n \l</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看cpu的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/cpuinfo</span></span><br><span class="line">processor: 0</span><br><span class="line">model name: ARMv8 Processor rev 0 (v8l)</span><br><span class="line">BogoMIPS: 62.50</span><br><span class="line">Features: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp</span><br><span class="line">CPU implementer: 0x4e</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant: 0x0</span><br><span class="line">CPU part: 0x004</span><br><span class="line">CPU revision: 0</span><br><span class="line">MTS version: 50168445</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line">processor: 5</span><br><span class="line">model name: ARMv8 Processor rev 0 (v8l)</span><br><span class="line">BogoMIPS: 62.50</span><br><span class="line">Features: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp</span><br><span class="line">CPU implementer: 0x4e</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant: 0x0</span><br><span class="line">CPU part: 0x004</span><br><span class="line">CPU revision: 0</span><br><span class="line">MTS version: 50168445</span><br></pre></td></tr></table></figure><h3 id="DeepStream-Setup"><a href="#DeepStream-Setup" class="headerlink" title="DeepStream Setup"></a>DeepStream Setup</h3><ol><li><p><a href="https://developer.nvidia.com/deepstream-sdk">NVIDIA DeepStream SDK</a>官网下载 <code>deepstream_sdk_v5.0.1_jetson.tbz2</code></p></li><li><p>命令行执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tar -xvf deepstream_sdk_v5.0.1_jetson.tbz2 -C /</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/nvidia/deepstream/deepstream-5.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ./install.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ldconfig</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/2021/07/02/week-1/02.png" alt="02"></p><h3 id="Run-deepstream-app"><a href="#Run-deepstream-app" class="headerlink" title="Run deepstream-app"></a>Run deepstream-app</h3><ol><li><p>导航到示例目录(samples)。</p></li><li><p>输入以下命令以运行参考应用程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> deepstream-app -c &lt;path_to_config_file&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;path_to_config_file&gt;</code>可以在<code>configs/deepstream-app/</code>中找到</p></li><li><p>在源文件目录中找到源码，编译并运行demo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 源文件目录（deepstream-test1）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 都需要make编译，具体请参阅其中的README文档</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/nvidia/deepstream/deepstream-5.0/sources/apps/sample_apps/deepstream-test1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">deepstream_test1_app.c  dstest1_pgie_config.txt  Makefile  README</span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">deepstream-test1-app    deepstream_test1_app.o   Makefile</span><br><span class="line">deepstream_test1_app.c  dstest1_pgie_config.txt  README</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行deepstream-test1-app</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./deepstream-test1-app /opt/nvidia/deepstream/deepstream-5.0/samples/streams/sample_720p.h264</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Reference test application</th><th align="center">Path inside sources directory</th><th>Description</th></tr></thead><tbody><tr><td align="center">Sample test application 1</td><td align="center">apps/sample_apps/deepstream-test1</td><td>Sample of how to use DeepStream elements for a single H.264 stream: filesrc → decode → nvstreammuH264 containerized streamx → nvinfer (primary detector) → nvdsosd → renderer.</td></tr><tr><td align="center">Sample test application 2</td><td align="center">apps/sample_apps/deepstream-test2</td><td>Sample of how to use DeepStream elements for a single H.264 stream: filesrc → decode → nvstreammux → nvinfer (primary detector) → nvtracker → nvinfer (secondary classifier) → nvdsosd → renderer.</td></tr><tr><td align="center">Sample test application 3</td><td align="center">apps/sample_apps/deepstream-test3</td><td>Builds on deepstream-test1 (simple test application 1) to demonstrate how to:Use multiple sources in the pipelineUse a uridecodebin to accept any type of input (e.g. RTSP/File), any GStreamer supported container format, and any codecConfigure Gst-nvstreammux to generate a batch of frames and infer on it for better resource utilizationExtract the stream metadata, which contains useful information about the frames in the batched buffer</td></tr><tr><td align="center">Sample test application 4</td><td align="center">apps/sample_apps/deepstream-test4</td><td>Builds on deepstream-test1 for a single H.264 stream: filesrc, decode, nvstreammux, nvinfer, nvdsosd, renderer to demonstrate how to:Use the Gst-nvmsgconv and Gst-nvmsgbroker plugins in the pipelineCreate NVDS_META_EVENT_MSG type metadata and attach it to the bufferUse NVDS_META_EVENT_MSG for different types of objects, e.g. vehicle and personImplement “copy” and “free” functions for use if metadata is extended through the extMsg field</td></tr><tr><td align="center">Sample test application 5</td><td align="center">apps/sample_apps/deepstream-test5</td><td>Builds on top of deepstream-app. Demonstrates:Use of Gst-nvmsgconv and Gst-nvmsgbroker plugins in the pipeline for multistreamHow to configure Gst-nvmsgbroker plugin from the config file as a sink plugin (for KAFKA, Azure, etc.)How to handle the RTCP sender reports from RTSP servers or cameras and translate the Gst Buffer PTS to a UTC timestamp.For more details refer the RTCP Sender Report callback function <code>test5_rtcp_sender_report_callback()</code> registration and usage in <code>deepstream_test5_app_main.c</code>. GStreamer callback registration with rtpmanager element’s “handle-sync” signal is documented in <code>apps-common/src/deepstream_source_bin.c</code>.</td></tr></tbody></table></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">|-- opt</span><br><span class="line">    |-- nvidia</span><br><span class="line">        |-- deepstream</span><br><span class="line">            |-- deepstream</span><br><span class="line">            |-- deepstream-5.0</span><br><span class="line">                |-- bin</span><br><span class="line">                |-- doc</span><br><span class="line">                |-- lib</span><br><span class="line">                |-- samples</span><br><span class="line">                |   |-- configs</span><br><span class="line">                |   |   |-- deepstream-app</span><br><span class="line">                |   |   |   |-- config_infer_primary.txt#将nvinfer配置为主要检测器</span><br><span class="line">                |   |   |   |-- config_infer_primary_nano.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_carcolor.txt#将nvinfer配置为辅助分类器</span><br><span class="line">                |   |   |   |-- config_infer_secondary_carmake.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_vehicletypes.txt</span><br><span class="line">                |   |   |   |-- iou_config.txt#配置一个低级的IOU跟踪器。</span><br><span class="line">                |   |   |   |-- source12_1080p_dec_infer-resnet_tracker_tiled_display_fp16_tx2.txt</span><br><span class="line">                |   |   |   |-- source1_csi_dec_infer_resnet_int8.txt   #演示一个CSI摄像机作为输入；仅适用于Jetson</span><br><span class="line">                |   |   |   |-- source1_usb_dec_infer_resnet_int8.txt#演示一个USB摄像机作为输入</span><br><span class="line">                |   |   |   |-- source2_csi_usb_dec_infer_resnet_int8.txt</span><br><span class="line">                                #演示30个具有主要推理功能的流解码（仅适用于dGPU和Jetson AGX Xavier平台）</span><br><span class="line">                |   |   |   |-- source30_1080p_dec_infer-resnet_tiled_display_int8.txt </span><br><span class="line">                #演示具有主要推理，对象跟踪和三个不同辅助分类器的四个流解码（仅适用于dGPU和Jetson AGX Xavier平台）</span><br><span class="line">                |   |   |   |-- source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt</span><br><span class="line">                |   |   |   |-- source6_csi_dec_infer_resnet_int8.txt</span><br><span class="line">                |   |   |   |-- source8_1080p_dec_infer-resnet_tracker_tiled_display_fp16_nano.txt</span><br><span class="line">                |   |   |   |-- source8_1080p_dec_infer-resnet_tracker_tiled_display_fp16_tx1.txt</span><br><span class="line">                |   |   |   |-- tracker_config.yml#配置NvDCF跟踪器</span><br><span class="line">                |   |   |-- deepstream-app-trtis</span><br><span class="line">                |   |   |-- tlt_pretrained_models</span><br><span class="line">                |   |-- models</span><br><span class="line">                |   |-- streams</span><br><span class="line">                |   |   |-- sample_1080p_h264.mp4#H264 containerized stream</span><br><span class="line">                |   |   |-- sample_1080p_h265.mp4#H265 containerized stream</span><br><span class="line">                |   |   |-- sample_720p.h264#H264 elementary stream</span><br><span class="line">                |   |   |-- sample_720p.jpg#JPEG image</span><br><span class="line">                |   |   |-- sample_720p.mjpeg#MJPEG stream</span><br><span class="line">                |   |   |-- sample_720p.mp4</span><br><span class="line">                |   |   |-- sample_cam6.mp4#H264 containerized stream(360D camera stream)</span><br><span class="line">                |   |   |-- sample_industrial.jpg</span><br><span class="line">                |   |   |-- sample_qHD.h264</span><br><span class="line">                |   |   |-- sample_qHD.mp4</span><br><span class="line">                |   |   |-- yoga.jpg</span><br><span class="line">                |   |   |-- yoga.mp4</span><br><span class="line">                |   |-- trtis_model_repo</span><br><span class="line">                |-- sources</span><br><span class="line">                    |-- apps</span><br><span class="line">                    |   |-- apps-common</span><br><span class="line">                    |   |   |-- includes</span><br><span class="line">                    |   |-- sample_apps</span><br><span class="line">                    |       |-- deepstream-app#端到端示例演示了4级联神经网络(1个一级检测器和3个二级分类器)的多相机流，并显示平铺输出。</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- deepstream_app.c</span><br><span class="line">                    |       |   |-- deepstream_app.h</span><br><span class="line">                    |       |   |-- deepstream_app_config_parser.c</span><br><span class="line">                    |       |   |-- deepstream_app_main.c</span><br><span class="line">                    |       |-- deepstream-test1#对单一H264视频流，应用filesrc→decode→nvstreammuH264 containerized streamx→nvinfer(主检测器)→nvdsosd→renderer</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                 Builds on deepstream-test1 (simple test application 1) to demonstrate how to:Use multiple sources in the pipelineUse a uridecodebin to accept any type of input (e.g. RTSP/File), any GStreamer supported container format, and any codecConfigure Gst-nvstreammux to generate a batch of frames and infer on it for better resource utilizationExtract the stream metadata, which contains useful information about the frames in the batched buffer   |       |   |-- deepstream-test1-app</span><br><span class="line">                    |       |   |-- deepstream_test1_app.c</span><br><span class="line">                    |       |   |-- deepstream_test1_app.o</span><br><span class="line">                    |       |   |-- dstest1_pgie_config.txt</span><br><span class="line">                    |       |-- deepstream-test2#建立在test1之上，显示额外的属性，如跟踪和二级分类属性。</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- deepstream_test2_app.c</span><br><span class="line">                    |       |   |-- dstest2_pgie_config.txt</span><br><span class="line">                    |       |   |-- dstest2_sgie1_config.txt</span><br><span class="line">                    |       |   |-- dstest2_sgie2_config.txt</span><br><span class="line">                    |       |   |-- dstest2_sgie3_config.txt</span><br><span class="line">                    |       |   |-- dstest2_tracker_config.txt</span><br><span class="line">                    |       |   |-- tracker_config.yml</span><br><span class="line">                    |       |-- deepstream-test3#建立在test1的基础上，显示多个输入源和批处理使用nvstreammuxer。</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- deepstream_test3_app.c</span><br><span class="line">                    |       |   |-- dstest3_pgie_config.txt</span><br><span class="line">                    |       |-nfer_primary.txt</span><br><span class="line">                |   |   |   |-- config_infer_primary_nano.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_carcolor.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_carmake.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_vehicletypes.txt</span><br><span class="line">                |   |   |   |-- iou_config.txt</span><br><span class="line">                |   |   |   |-- source12_1080p_dec_infer-resnet_tracker_tiled_display_fp16_tx2.txt</span><br><span class="line">                |   |   |   |-- source1_csi_dec_infer_resnet_int8.txt</span><br><span class="line">                |   |   |   |-- source1_usb_dec_infer_resnet_int8.txt</span><br><span class="line">                |   |   |   |-- source2_cs- deepstream-test4</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- cfg_amqp.txt</span><br><span class="line">                    |       |   |-- cfg_azure.txt</span><br><span class="line">                    |       |   |-- cfg_kafka.txt</span><br><span class="line">                    |       |   |-- deepstream_test4_app.c</span><br><span class="line">                    |       |   |-- dstest4_msgconv_config.txt</span><br><span class="line">                    |       |   |-- dstest4_pgie_config.txt</span><br><span class="line">                    |       |-- deepstream-test5</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- deepstream_test5_app.h</span><br><span class="line">                    |       |   |-- deepstream_test5_app_main.c</span><br><span class="line">                    |       |   |-- deepstream_utc.c</span><br><span class="line">                    |       |   |-- configs</span><br><span class="line">                    |       |       |-- dstest5_msgconv_sample_config.txt</span><br><span class="line">                    |       |       |-- test5_config_file_src_infer.txt</span><br><span class="line">                    |       |       |-- test5_config_file_src_infer_azure_iotedge.txt</span><br><span class="line">                    |       |       |-- test5_config_file_src_infer_tiler_demux.txt</span><br><span class="line">                    |       |       |-- test5_config_file_src_infer_tracker_sgie.txt</span><br><span class="line">                    |       |       |-- test5_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt</span><br><span class="line">                    |       |       |-- test5_ota_override_config.txt</span><br><span class="line">                    |-- gst-plugins</span><br><span class="line">                    |-- includes</span><br><span class="line">                    |-- libs</span><br><span class="line">                    |-- objectDetector_FasterRCNN</span><br><span class="line">                    |-- objectDetector_SSD</span><br><span class="line">                    |-- objectDetector_Yolo</span><br><span class="line">                    |-- tools</span><br></pre></td></tr></table></figure><p>日志信息：</p><p><img src="/2021/07/02/week-1/04.png" alt="04"><br>结果显示：</p><p><img src="/2021/07/02/week-1/05.png" alt="05"></p><p><img src="/2021/07/02/week-1/08.png" alt="08"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.nvidia.com/metropolis/deepstream/dev-guide/index.html">NVIDIA DeepStream SDK开发指南</a></p><p><a href="https://docs.nvidia.com/metropolis/deepstream/plugin-manual/index.html">NVIDIA DeepStream插件手册</a></p><p><a href="https://docs.nvidia.com/metropolis/deepstream/dev-guide/">NVIDIA DeepStream SDK API参考文档</a></p>]]></content>
    
    
    <summary type="html">Jetson Xavier NX部署 Deepstream</summary>
    
    
    
    <category term="Internship" scheme="http://example.com/categories/Internship/"/>
    
    
    <category term="Jetson" scheme="http://example.com/tags/Jetson/"/>
    
    <category term="Deepstreeam" scheme="http://example.com/tags/Deepstreeam/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="http://example.com/2021/05/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2021/05/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-05-21T14:32:12.000Z</published>
    <updated>2024-01-15T01:51:07.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-C-内存分区模型"><a href="#C-C-内存分区模型" class="headerlink" title="C/C++内存分区模型"></a>C/C++内存分区模型</h2><p>C/C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理,只读</li><li>全局区：存放<code>全局变量和静态变量以及常量</code>，可读可写</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收,可读可写</li><li>栈区：由编译器自动分配释放, 存放<code>函数的参数值,局部变量</code>等，可读可写</li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><p><strong>程序编译后</strong>，win下生成exe可执行程序，Linux下生成ELF格式可执行文件，<strong>未执行该程序前</strong>分为两个区域</p><p>​    <strong>代码区：</strong></p><p>​        存放 CPU 执行的机器指令</p><p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​    <strong>全局区：</strong><br>​    由数据区data+未初始化区bss+常量区组成</p><ul><li>data区：存放的是已经初始化的全局变量、静态变量</li><li>bss区：存放未初始化的全局变量和未初始化的静态变量，由exec初始化为0</li><li>常量区：存放字符串常量和const修饰的全局变量，只读</li></ul><p>可执行程序的三段是指【text段、data段、bss段】</p><p><img src="/2021/05/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/bss.png" alt="bss"></p><p><img src="/2021/05/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4%E5%8C%BA.png" alt="4"></p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>栈是由编译器在程序运行时分配的空间，由操作系统维护.堆是由malloc()函数分配的内存块，内存的管理由程序员手动控制，在C语言使用free()函数完成.主要区别有一下几点：</p><ul><li>管理方式不同<br>程序在运行时栈由操作系统自动管理，无须程序员手工控制；而堆空间的申请、释放工作由程序员控制，容易产生内存泄露.</li><li>空间大小不同</li></ul><p><strong>栈是向低地址扩展</strong>，是一块连续的内存区域.即栈顶的地址和栈的最大容量是系统预先规定好的，当申请的空间超过栈的剩余空间时，将出现栈溢出错误。<strong>堆是向高地址扩展</strong>，是不连续的内存区域.因为系统是用==链表==来存储空闲内存地址的，且链表的遍历方向是由低地址高地址.</p><ul><li>产生碎片不同<br>对于堆来说，频繁的malloc/free势必会造成内存空间的不连续从而造成大量的碎片，使程序效率降低.对于栈来说，一定是连续的物理内存空间。它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。</li><li>增长方式不同<br>在X86平台上，堆的增长方向是向上，即向着内存地址增加的方向；栈的增长方向是向下的，即向着内存地址减小的方向.</li><li>分配方式不同<br>堆都是程序中由malloc()函数动态申请分配并由free() 函数释放；栈的分配和释放是由操作系统完成的，栈的动态分配有alloca()函数完成，但是栈的动态分配和堆是不同的，其由编译器进行分配和释放，无须手工完成.</li><li>分配效率不同<br>栈是系统提供的，操作系统会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都是专门的指令执行。堆则是C 函数库提供的，它的机制很复杂，例如为了分配一块内存，则需要操作系统重新整理内存，搜索整理内存空间，这样就有机会分到足够大小的内存，然后返回。显然，堆的效率比栈要低的多.</li></ul><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><ul><li>用于修饰局部变量，使其具有静态存储期，即在函数调用结束后不会被销毁，而是保留上一次的值。这样可以实现一些特殊的功能，比如计数器，累加器等。</li><li>用于修饰全局变量或函数，使其具有文件作用域，即只能在定义它的源文件中被访问，而不能被其他文件访问。这样可以避免命名冲突，提高程序的模块化和封装性。</li><li>用于修饰类的数据成员或成员函数，使其属于整个类，而不是某个对象。这样可以实现类的共享数据和函数，节省内存空间，提高效率。</li></ul><h2 id="指针-数组-函数"><a href="#指针-数组-函数" class="headerlink" title="指针 数组 函数"></a>指针 数组 函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">10</span>]    <span class="comment">//指针数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">10</span>]  <span class="comment">//数组指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span>   <span class="comment">//函数声明</span></span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(*p)</span><span class="params">(<span class="keyword">int</span>)</span> <span class="comment">//函数指针</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span> x)</span></span>;   <span class="comment">/*声明一个函数*/</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p) (<span class="keyword">int</span> x);  <span class="comment">/*定义一个函数指针*/</span></span><br><span class="line">p = Func;          <span class="comment">/*将Func函数的首地址赋给指针变量p*/</span></span><br></pre></td></tr></table></figure><ul><li>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</li><li>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</li><li>int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</li><li>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</li><li>如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</li><li>最后需要注意的是，指向函数的指针变量没有 ++ 和 – 运算。</li></ul><h2 id="new-delete-与-malloc-free"><a href="#new-delete-与-malloc-free" class="headerlink" title="new/delete 与 malloc/free"></a>new/delete 与 malloc/free</h2><p><strong>相同点</strong></p><ul><li>都可用于内存的动态申请和释放</li></ul><p><strong>不同点</strong></p><ul><li>前者是C++运算符，支持重载overload，后者是C/C++语言标准库函数，支持覆盖override</li><li>new自动计算要分配的空间大小，malloc需要手工计算</li><li>new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象</li><li>new是类型安全的，malloc不是。因为 new 内置了<strong>sizeof、类型转换和类型安全检查功能</strong>。对于<strong>非内部数据类型的对象而言，new 在创建动态对象的同时完成了初始化工作</strong>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>]; <span class="comment">//编译错误</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));<span class="comment">//编译无错误</span></span><br><span class="line"><span class="comment">//函数malloc 的原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//用 malloc 申请一块长度为length 的整数类型的内存</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(length * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="comment">//函数free 的原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">( <span class="keyword">void</span> * memblock )</span></span>;</span><br><span class="line"><span class="comment">//new 创建对象数组，那么只能使用对象的无参数构造函数</span></span><br><span class="line">Obj *objects = <span class="keyword">new</span> Obj[<span class="number">100</span>];       <span class="comment">// 创建100 个动态对象</span></span><br><span class="line">Obj *objects = <span class="keyword">new</span> Obj[<span class="number">100</span>](<span class="number">1</span>);    <span class="comment">// 创建100 个动态对象的同时赋初值1  错误❌</span></span><br><span class="line"><span class="keyword">delete</span> []objects; <span class="comment">// 正确的用法</span></span><br><span class="line"><span class="keyword">delete</span> objects;   <span class="comment">// 错误的用法</span></span><br></pre></td></tr></table></figure><ul><li>new由两步构成：operator new 和 construct，operator new 对应于malloc，但 operator new可以重载，可以自定义内存分配策略；delete由deconstruct 和 operator new 构成，先析构对象，再释放内存。</li><li>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</li></ul><ul><li>delete和delete[]区别：delete只会调用一次析构函数，delete[]会调用数组中每个元素的析构函数。</li></ul><h2 id="public，protected，private"><a href="#public，protected，private" class="headerlink" title="public，protected，private"></a>public，protected，private</h2><p>（1）三种访问权限</p><ul><li>public:用该关键字修饰变量和函数在类的内部外部都可以访问</li><li>private:用该关键字修饰的元素只能在类内访问</li><li>protected:用该关键字修饰的变量和函数只能在类的内部和其派生类中访问</li></ul><p>（2）三种继承方式</p><ul><li>若继承方式是public，基类成员在派生类中的访问权限保持不变</li><li>若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；</li><li>若继承方式是protected，基类的公有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。</li></ul><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/* class B      size(4):</span><br><span class="line">    +---</span><br><span class="line"> 4  / _b</span><br><span class="line">    +---</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/* class C1        size(24):</span><br><span class="line">    +---</span><br><span class="line"> 8  | &#123;vbptr&#125;</span><br><span class="line"> 8  | c1</span><br><span class="line">    +---</span><br><span class="line">    +--- (virtual base B)</span><br><span class="line"> 4  | _b</span><br><span class="line">    +---</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/* class C2        size(16):</span><br><span class="line">    +---</span><br><span class="line"> 8  | &#123;vbptr&#125;</span><br><span class="line"> 4  | c1</span><br><span class="line">    +---</span><br><span class="line">    +--- (virtual base B)</span><br><span class="line"> 4  | _b</span><br><span class="line">    +---</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/* class d      size(48):</span><br><span class="line">        +---</span><br><span class="line">   | +--- (base class C1) 16</span><br><span class="line"> 8  | | &#123;vbptr&#125;</span><br><span class="line"> 8  | | c1</span><br><span class="line">    | +---</span><br><span class="line">    | +--- (base class C2) 16</span><br><span class="line"> 8  | | &#123;vbptr&#125;</span><br><span class="line"> 4  | | c2</span><br><span class="line">    | +---  8</span><br><span class="line"> 4  | _d</span><br><span class="line">    +---</span><br><span class="line">    +--- (virtual base B)  8</span><br><span class="line"> 4  | _b</span><br><span class="line">    +---</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>内存模型如上 64位操作系统 注意<code>字节对齐</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//virtual 虚拟继承标识符</span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">int _b;</span><br><span class="line">&#125;;</span><br><span class="line">class C1 :virtual public B &#123; //C1虚拟继承自B</span><br><span class="line">public:</span><br><span class="line">double c1;</span><br><span class="line">&#125;;</span><br><span class="line">class C2 :virtual public B &#123; //C2虚拟继承自B</span><br><span class="line">public:</span><br><span class="line">int c2;</span><br><span class="line">&#125;;</span><br><span class="line">class D :public C1, public C2 &#123;</span><br><span class="line">public:</span><br><span class="line">double _d;</span><br><span class="line">&#125;;</span><br><span class="line">int  main() &#123;</span><br><span class="line">D d;</span><br><span class="line">d.c1 = 1;</span><br><span class="line">d.c2 = 2;</span><br><span class="line">d._b = 3;</span><br><span class="line">d._d = 5;</span><br><span class="line">    cout &lt;&lt; sizeof(B) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sizeof(C1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sizeof(C2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sizeof(D) &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载-重写-覆盖-隐藏"><a href="#重载-重写-覆盖-隐藏" class="headerlink" title="重载 重写/覆盖 隐藏"></a>重载 重写/覆盖 隐藏</h2><p><img src="/2021/05/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/overide.png" alt="ov"></p><p><strong>使用 CL 编译器选项查看 C++ 类内存布局</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">VS开发人员命令提示符</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cl ***.cpp /d1 reportSingleClassLayout[classname]</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aa1</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aa2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aa3</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aa4</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> x;</span><br><span class="line">    <span class="keyword">char</span> sd;</span><br><span class="line">    <span class="keyword">float</span> z;</span><br><span class="line">    <span class="keyword">float</span> qw;</span><br><span class="line">    <span class="keyword">float</span> qe;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">g2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span> <span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived2</span>:</span> <span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">v2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base2</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> xx;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived3</span>:</span> <span class="keyword">public</span> base, <span class="keyword">public</span> base2&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> zz;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/05/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/cl1.png" alt="cl1"></p><p><img src="/2021/05/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/cl2.png" alt="cl2"></p><h2 id="C-中struct和class"><a href="#C-中struct和class" class="headerlink" title="C++中struct和class"></a>C++中struct和class</h2><p><strong>相同点</strong></p><ul><li>两者都拥有成员函数、公有和私有部分</li><li>任何可以使用class完成的工作，同样可以使用struct完成</li></ul><p><strong>不同点</strong></p><ul><li>两者中如果不对成员不指定公私有，struct默认是<strong>公有的public</strong>，class则默认是<strong>私有的private</strong></li><li>class默认是<strong>private继承</strong>，而struct模式是<strong>public继承</strong></li><li>class可以作为模板类型，struct不行</li></ul><p><strong>引申</strong>：C++和C的struct区别</p><ul><li>C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）</li><li>C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员<strong>不可以是函数</strong></li><li>C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</li><li>struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};），C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C++中被当作类的一种特例</li><li>C语言中，空结构体的大小为0，而C++中空结构体（属于空类）的大小为1。</li></ul><h2 id="C中violatile的用法"><a href="#C中violatile的用法" class="headerlink" title="C中violatile的用法"></a>C中violatile的用法</h2><p>在C语言中，<code>volatile</code> 是一个关键字，用于告诉编译器不要对被声明为 <code>volatile</code> 的变量进行优化，因为这些变量的值可能会在程序执行过程中被外部因素改变，而编译器不应该对其进行优化。</p><p><code>volatile</code> 主要用于两个方面：</p><ol><li><p><strong>防止编译器优化：</strong> 编译器在优化代码时会对变量进行缓存或寄存器操作，但对于声明为 <code>volatile</code> 的变量，编译器会生成对该变量的读取和写入的(汇编)代码，以确保每次都从内存中读取值，而不是使用寄存器中的缓存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> x; <span class="comment">// x是一个volatile变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个函数中使用x</span></span><br><span class="line"><span class="keyword">int</span> y = x; <span class="comment">// 编译器会生成读取x的汇编代码，而不是使用寄存器中的缓存</span></span><br></pre></td></tr></table></figure></li><li><p><strong>适用于多线程或中断处理：</strong> 当多个线程或中断可能同时访问某个变量时，为了确保每次访问都是从内存中读取最新值，可以将该变量声明为 <code>volatile</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> sharedVar; <span class="comment">// 在多线程或中断处理中共享的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1中</span></span><br><span class="line">sharedVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2中</span></span><br><span class="line"><span class="keyword">int</span> value = sharedVar; <span class="comment">// 确保从内存中读取最新值</span></span><br></pre></td></tr></table></figure></li></ol><p>需要注意的是，<code>volatile</code> 不能解决所有并发问题，它仅仅告诉编译器不要对这个变量进行优化。在多线程环境中，可能还需要使用其他同步机制来确保数据的一致性和正确性。</p><h2 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++ 11新特性"></a>C++ 11新特性</h2><ul><li><p>nullptr 替代 NULL</p></li><li><p>引入了 auto 和 decltype 这两个关键字实现了类型推导</p></li><li><p>基于范围的 for 循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : nums)&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>类和结构体的中初始化列表</p></li><li><p>Lambda 表达式（匿名函数）</p></li><li><p>std::forward_list（单向链表）</p></li><li><p>右值引用和move语义</p></li><li><p>智能指针</p></li><li><p>…</p></li></ul><h2 id="值传递-地址传递"><a href="#值传递-地址传递" class="headerlink" title="值传递 地址传递"></a>值传递 地址传递</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func swap(a int ,b int) &#123;</span></span><br><span class="line"><span class="comment">var temp int</span></span><br><span class="line"><span class="comment">temp = a</span></span><br><span class="line"><span class="comment">a = b</span></span><br><span class="line"><span class="comment">b = temp</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(pa *<span class="keyword">int</span>, pb *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> temp <span class="keyword">int</span></span><br><span class="line">temp = *pa <span class="comment">//temp = main::a</span></span><br><span class="line">*pa = *pb  <span class="comment">// main::a = main::b</span></span><br><span class="line">*pb = temp <span class="comment">// main::b = temp</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">swap(&amp;a, &amp;b)</span><br><span class="line">fmt.Println(<span class="string">&quot;a = &quot;</span>, a, <span class="string">&quot; b = &quot;</span>, b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">p = &amp;a</span><br><span class="line">fmt.Println(&amp;a)</span><br><span class="line">fmt.Println(p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pp **<span class="keyword">int</span> <span class="comment">//二级指针</span></span><br><span class="line">pp = &amp;p</span><br><span class="line"></span><br><span class="line">fmt.Println(&amp;p)</span><br><span class="line">fmt.Println(pp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/05/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%80%BC%E4%BC%A0%E9%80%92.png"></p><hr><p><img src="/2021/05/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%920.png"></p><hr><p><img src="/2021/05/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%92.png"></p><h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p><strong>左值、右值</strong></p><blockquote><p>在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。==在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）==。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。</p></blockquote><p><strong>右值、将亡值</strong></p><blockquote><p>在理解C++11的右值前，先看看C++98中右值的概念：C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。临时变量指的是非引用返回的函数返回值、表达式等，例如函数int func()的返回值，表达式a+b；不跟对象关联的字面量值，例如true，2，”C”等。</p><p>C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。</p><p>将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</p></blockquote><p><strong>左值引用、右值引用</strong></p><blockquote><p>左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。</p><p>右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。</p><p>左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;a = <span class="number">2</span>;       # 左值引用绑定到右值，编译失败</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;        # 非常量左值</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = b; # 常量左值引用绑定到非常量左值，编译通过</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">2</span>;  # 常量左值</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;e = c; # 常量左值引用绑定到常量左值，编译通过</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b =<span class="number">2</span>;  # 常量左值引用绑定到右值，编程通过</span><br></pre></td></tr></table></figure><p>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r1 = c;             # 编译失败</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r2 = std::<span class="built_in">move</span>(a);  # 编译通过</span><br></pre></td></tr></table></figure><p>下表列出了在C++11中各种引用类型可以引用的值的类型。值得注意的是，只要能够绑定右值的引用类型，都能够延长右值的生命期。</p><p><strong>右值引用的作用</strong>：==移动语义和完美转发==</p><p><a href="https://blog.csdn.net/hyman_yx/article/details/52044632?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.searchformbaiduhighlight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.searchformbaiduhighlight">参考</a></p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><blockquote><p>RAII是C++的发明者Bjarne Stroustrup提出的概念，RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现</p></blockquote><p><strong>原理</strong>：</p><p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源</p><p><strong>常用的智能指针</strong>：</p><p><strong>(1) shared_ptr</strong></p><p>实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。</p><ul><li>智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针</li><li>每次创建类的新对象时，初始化指针并将引用计数置为1</li><li>当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数</li><li>对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数</li><li>调用析构函数时，减少引用计数（如果引用计数减至0，则删除基础对象）</li></ul><p><strong>(2) unique_ptr</strong></p><p>unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。</p><p><strong>(3) weak_ptr</strong></p><p>weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。</p><p><strong>(4) auto_ptr</strong></p><p>主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。</p><p>auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。</p><p>auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。</p><h2 id="宏定义和函数"><a href="#宏定义和函数" class="headerlink" title="宏定义和函数"></a>宏定义和函数</h2><ul><li>宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数</li><li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值</li><li>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型</li><li>宏定义不要在最后加分号</li></ul><h2 id="宏定义和typedef"><a href="#宏定义和typedef" class="headerlink" title="宏定义和typedef"></a>宏定义和typedef</h2><ul><li>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名</li><li>宏替换发生在编译阶段之前(预处理)，属于文本插入替换；typedef是编译的一部分</li><li>宏不检查类型；typedef会检查数据类型</li><li>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束</li><li>注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * p_char;</span><br><span class="line">p_char a,b; <span class="comment">//a,b均为char*</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_char char*</span></span><br><span class="line">p_char a,b; <span class="comment">//a为char*，b为char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>只是进行字符串替换，因此第二句相当于char *a, b;</span></span><br></pre></td></tr></table></figure><h2 id="宏定义和inline"><a href="#宏定义和inline" class="headerlink" title="宏定义和inline"></a>宏定义和inline</h2><p>宏在C语言里极其重要，关于宏的第一规则是：绝不应该去使用它，除非你不得不这样做。几乎每个宏都表明了程序设计语言里或者程序里或者程序员的一个缺陷，因为它将在编译器看到程序的正文之前重新摆布这些正文。</p><p>inline函数是C++引入的机制，目的是解决使用宏定义的一些缺点</p><blockquote><ul><li>内联函数在编译时展开，宏在预编译/预处理时展开；</li><li>内联函数直接嵌入到目标代码中，宏是简单的做文本替换；</li><li>内联函数有类型检测、语法判断等功能，而宏没有；</li><li>inline函数是函数，支持重载，宏不是；</li><li>内联函数代码是被放到符号表中，使用时像宏一样展开，没有调用的开销，效率很高；</li><li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义；</li><li>宏不能访问对象的私有成员，inline函数作为类的成员函数，可以使用类的保护成员及私有成员；</li></ul></blockquote><p><strong>为什么不能把所有的函数写成inline函数</strong></p><blockquote><ul><li>函数体内的代码比较长，将导致内存消耗代价；</li><li>函数体内有循环，函数执行时间要比函数调用开销大；</li><li>内联函数本身不能是直接递归函数(自己内部还调用自己的函数)</li></ul></blockquote><h2 id="宏定义和const"><a href="#宏定义和const" class="headerlink" title="宏定义和const"></a>宏定义和const</h2><p><strong>语法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名称 宏值</span></span><br><span class="line"><span class="keyword">const</span> 数据类型 常量名 = 常量值;</span><br></pre></td></tr></table></figure><p><strong>编译阶段</strong></p><ul><li>define是在<strong>预处理</strong>阶段起作用，而const是在<strong>运行</strong>的时候起作用</li></ul><p><strong>安全性</strong></p><ul><li>define只做替换，不做类型检查和计算，要注意书写（参数要括起来）否则容易出现歧义</li><li>const常量有数据类型，编译器可以对其进行类型安全检查</li></ul><p><strong>内存占用</strong></p><ul><li>宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</li><li>define仅仅是展开，有多少地方使用，就展开多少次，<strong>不会分配内存</strong>。（宏定义不分配内存，变量定义分配内存。）</li><li>const常量会在<strong>内存中分配</strong>(可以是堆中也可以是栈中)</li></ul><h2 id="C-空类默认函数"><a href="#C-空类默认函数" class="headerlink" title="C++空类默认函数"></a>C++空类默认函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Empty</span>(); <span class="comment">// 缺省构造函数</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">Empty</span>( <span class="keyword">const</span> Empty&amp; ); <span class="comment">// 拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">      ~<span class="built_in">Empty</span>(); <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">       Empty&amp; <span class="keyword">operator</span>=( <span class="keyword">const</span> Empty&amp; ); <span class="comment">// 赋值运算符</span></span><br><span class="line"></span><br><span class="line">       Empty* <span class="keyword">operator</span>&amp;(); <span class="comment">// 取址运算符</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">const</span> Empty* <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>; <span class="comment">// 取址运算符 const</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="虚函数、纯虚函数"><a href="#虚函数、纯虚函数" class="headerlink" title="虚函数、纯虚函数"></a>虚函数、纯虚函数</h2><h2 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步 异步"></a>同步 异步</h2><h2 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程 线程"></a>进程 线程</h2><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h2 id="数据结构-–-数组和链表"><a href="#数据结构-–-数组和链表" class="headerlink" title="数据结构 – 数组和链表"></a>数据结构 – 数组和链表</h2><p><strong>数组的优点：</strong></p><ul><li>随机访问性强,查找速度快，时间复杂度是0（1）</li></ul><p><strong>数组的缺点：</strong></p><ul><li><p>从头部删除、从头部插入的效率低，时间复杂度是o(n),因为需要相应的向前搬移和向后搬移。</p></li><li><p>空间利用率不高</p></li><li><p>内存空间要求高，必须要有足够的连续的内存空间。</p></li><li><p>数组的空间大小是固定的，不能进行动态扩展。</p></li></ul><p><strong>链表的优点：</strong></p><ul><li><p>任意位置插入元素和删除元素的速度快，时间复杂度是o(1)</p></li><li><p>内存利用率高，不会浪费内存</p></li><li><p>链表的空间大小不固定，可以动态拓展。</p></li></ul><p><strong>链表的缺点：</strong></p><ul><li>随机访问效率低，时间复杂度是o(N)</li></ul><table><thead><tr><th align="center">操作</th><th align="center">数组</th><th align="center">链表</th></tr></thead><tbody><tr><td align="center">随机访问</td><td align="center">O(1)</td><td align="center">O(N)</td></tr><tr><td align="center">头部插入</td><td align="center">O(N)</td><td align="center">O(1)</td></tr><tr><td align="center">头部删除</td><td align="center">O(N)</td><td align="center">O(1)</td></tr><tr><td align="center">尾部插入</td><td align="center">O(1)</td><td align="center">O(1)</td></tr><tr><td align="center">尾部删除</td><td align="center">O(1)</td><td align="center">O(1)</td></tr></tbody></table><h2 id="单链表-双链表"><a href="#单链表-双链表" class="headerlink" title="单链表 双链表"></a>单链表 双链表</h2><blockquote><p>单向链表：只有一个指向下一个节点的指针。</p><p>优点：单向链表增加删除节点简单。遍历时候不会死循环；</p><p>缺点：只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。</p><p>适用于节点的增加删除。</p></blockquote><blockquote><p>双向链表：有两个指针，一个指向前一个节点，一个后一个节点。</p><p>优点：可以找到前驱和后继，可进可退；</p><p>缺点：增加删除节点复杂，需要多分配一个指针存储空间。</p><p>适用于需要双向查找节点值的情况。</p></blockquote><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ol><li><p>自我介绍</p><p>2.<a href>项目</a>相关，实习相关。  </p><p>3.什么是Reactor？Reactor和Proactor的区别，为什么用Reactor? 同步和异步IO的区别。  </p><p>4.epoll怎么判断数据读取完毕？  </p><p>5.new 和 malloc的区别？有malloc了为什么还要设置new，new还有哪些用法？  </p><p>6.为什么要设置虚析构函数？虚析构函数的作用。  </p><p>7.TCP 和 UDP的区别？ 面向连接的连接的含义？  </p></li><li><p>private 有多态吗？ 引用有多态吗？  </p><ol start="9"><li><p>web 服务器的作用？服务器的处理流程？  </p></li><li><p>日志系统的实现，为什么采用两块缓冲区，而不是把缓冲区的大小扩大。好处是什么。  </p></li><li><p>日志来不及写，怎么处理。  </p></li><li><p>线程池的处理逻辑，怎么判断一个线程挂掉，怎么实现负载均衡。  </p></li><li><p>对智能指针的理解。  </p></li></ol><p>14.怎么处理失效和过期的请求。  </p><p>15.如果没有空闲的工作线程，新到的请求怎么办？  </p><p>16.怎么处理下载请求。下载的数据大小都不一致。怎么支持浏览器。  </p><p>17.介绍一下对深度学习的理解。</p></li></ol><h2 id="操作系统–进程和线程"><a href="#操作系统–进程和线程" class="headerlink" title="操作系统–进程和线程"></a>操作系统–进程和线程</h2><table><thead><tr><th></th><th align="center">进程</th><th align="center">线程</th><th align="center">协程</th></tr></thead><tbody><tr><td>定义</td><td align="center">资源分配的最小单位</td><td align="center">CPU调度的最小单位</td><td align="center">用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td>切换情况</td><td align="center">旧进程CPU环境的保存(栈、寄存器、页表)以及新进行CPU环境的设置</td><td align="center">保存和设置程序计数器、少量寄存器和栈的内容</td><td align="center">先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td>切换者</td><td align="center">操作系统</td><td align="center">操作系统</td><td align="center">用户</td></tr><tr><td>切换过程</td><td align="center">用户态-&gt;内核态-&gt;用户态</td><td align="center">用户态-&gt;内核态-&gt;用户态</td><td align="center">用户态(没有陷入内核)</td></tr><tr><td>调用栈</td><td align="center">内核栈</td><td align="center">内核栈</td><td align="center">用户栈</td></tr><tr><td>拥有资源</td><td align="center">CPU资源、内存资源、文件资源和句柄等</td><td align="center">程序计数器、寄存器、栈和状态字</td><td align="center">拥有自己的寄存器上下文和栈</td></tr><tr><td>并发性</td><td align="center">不同进程之间切换实现并发，各自占有CPU实现并行</td><td align="center">一个进程内部的多个线程并发执行</td><td align="center">同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td>系统开销</td><td align="center">切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td align="center">切换时只需保存和设置少量寄存器内容，因此开销很小</td><td align="center">直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td>通信方面</td><td align="center">进程间通信需要借助操作系统</td><td align="center">线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td align="center">共享内存、消息队列</td></tr></tbody></table><ul><li>进程是资源调度的基本单位，是资源分配的最小单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</li><li>线程是程序执行的基本单位，是CPU调度的最小单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。</li><li>Linux 中进程和线程实际上都是用一个结构体 <code>task_struct</code>来表示一个执行任务的实体。进程创建调用<code>fork</code> 系统调用，而线程创建则是 <code>pthread_create</code> 方法，但是这两个方法最终都会调用到 <code>do_fork</code> 来做具体的创建操作 ，区别就在于传入的参数不同。Linux 实现线程的方式简直太巧妙了，实际上根本没有<strong>线程</strong>，它创建的就是进程，只不过通过参数指定多个进程之间共享某些资源（如虚拟内存、页表、文件描述符等），函数调用栈、寄存器等线程私有数据则独立。</li><li>同一进程内的多个线程共享该进程的资源，但线程并不拥有资源，只是使用他们。</li><li>但是在其它提供了专门线程支持的系统中，则会在进程控制块（PCB）中增加一个包含指向该进程所有线程的指针，然后在每个线程中再去包含自己独占的资源。这算是非常正统的实现方式了，比如 Windows 就是这样干的。</li><li>多提一句：协程是用户态的轻量级线程，线程内部调度的基本单位</li></ul><blockquote><p>维基百科对于协程的定义：<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B">https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B</a></p><p>官方定义：A coroutine is a <strong>function</strong> that can <strong>suspend</strong> its execution (yield) until the given given <strong>YieldInstruction</strong> finishes.</p></blockquote><p><strong>另一篇博客的总结：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210317110139.png"></p><ul><li>进程是资源分配的最小单位，会拥有独立的地址空间以及对应的内存空间，还有网络和文件资源等，不同进程之间资源都是独立的，可以通过进程间通信（管道、共享内存、信号量等方式）来进行交互。</li><li>线程为CPU调度的基本单位，除了拥有运行中必不可少的信息(如程序计数器、一组寄存器和栈)以外，本身并不拥有系统资源，所有线程会共享进程的资源，比如会共享堆资源。</li><li>协程可以认为是运行在线程上的代码块，协程提供的挂起操作会使协程暂停执行，而不会导致线程阻塞。一个线程内部可以创建几千个协程都没有任何问题。</li><li>进程的切换和线程切换中都包含了对应上下文的切换，这块都涉及到了内核来完成，即一次用户态到内核态的切换和一次内核态到用户态的切换。因为进程上下文切换保存的信息更多，所以进程切换代价会比线程切换代价更大。</li><li>协程是一个纯用户态的并发机制，同一时刻只会有一个协程在运行，其他协程挂起等待；不同协程之间的切换不涉及内核，只用在用户态切换即可，所以切换代价更小，更轻量级，适合IO密集型的场景。</li></ul>]]></content>
    
    
    <summary type="html">持续整理记录面试中C++相关问题</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>webserver</title>
    <link href="http://example.com/2021/04/11/webserver/"/>
    <id>http://example.com/2021/04/11/webserver/</id>
    <published>2021-04-11T13:32:24.000Z</published>
    <updated>2023-12-31T18:44:13.894Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="TinyWebserver"><a href="#TinyWebserver" class="headerlink" title="TinyWebserver"></a>TinyWebserver</h1><h2 id="什么是Web-Server（网络服务器）"><a href="#什么是Web-Server（网络服务器）" class="headerlink" title="什么是Web Server（网络服务器）"></a>什么是Web Server（网络服务器）</h2>]]></content>
    
    
    <summary type="html">Linux网络编程项目实践。参考游双《Linux高性能服务器编程》和https://github.com/qinguoyi/TinyWebServer/tree/master。</summary>
    
    
    
    <category term="服务器" scheme="http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CMake&amp;Meson 边学边记</title>
    <link href="http://example.com/2021/04/10/cmake-notes/"/>
    <id>http://example.com/2021/04/10/cmake-notes/</id>
    <published>2021-04-10T12:32:42.000Z</published>
    <updated>2023-12-31T18:44:13.893Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="CMake笔记"><a href="#CMake笔记" class="headerlink" title="CMake笔记"></a>CMake笔记</h1><p><strong>一开始是记录CMake的学习，7月份实习用到了Meson，故也记录在了这篇文章中。</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><ul><li>网址：<a href="https://cmake.org/download/">https://cmake.org/download/</a></li></ul><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><ul><li><p>直接安装 <code>apt install cmake</code></p></li><li><p>网址：<a href="https://cmake.org/download/">https://cmake.org/download/</a>     下载对应版本的CMake（32位或者64位）</p></li><li><p>输入以下命令进行解压</p><p><code>    tar -zxvf cmake-3.10.0-rc4-Linux-x86_64.tar.gz</code></p></li><li><p>把解压后的目录改名为：cmake</p><p><code>mv cmake-3.10.0-rc4-Linux-x86_64 cmake</code></p></li><li><p>安装完毕，命令行输入：<code>cmake --version</code>检测是否安装成功</p></li></ul><h2 id="CMake初探"><a href="#CMake初探" class="headerlink" title="CMake初探"></a>CMake初探</h2><p><strong>基本都在我的阿里云服务器上倒腾，环境为Ubuntu 16.04</strong></p><h3 id="CMake基础知识"><a href="#CMake基础知识" class="headerlink" title="CMake基础知识"></a>CMake基础知识</h3><ul><li><p>最低版本</p><ul><li><p><code>CMakeLists.txt</code>的第一行都会写：<code>cmake_minimum_required(VERSION 3.1)</code>，该命令指定了CMake的最低版本是3.1</p></li><li><p>命令名称<code>cmake_minimum_required</code>不区分大小写</p></li><li><p>设置版本范围：<code>cmake_minimum_required(VERSION 3.1...3.12)</code></p></li><li><p>判断CMake版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#该命令表示：如果CMake版本小于3.12，则if块将为true，然后将设置为当前CMake版本</span><br><span class="line">#如果CMake版本高于3.12，if块为假，cmake_minimum_required将被正确执行</span><br><span class="line">if($&#123;CMAKE_VERSION&#125; VERSION_LESS 3.12)     </span><br><span class="line">    cmake_policy(VERSION $&#123;CMAKE_MAJOR_VERSION&#125;.$&#123;CMAKE_MINOR_VERSION&#125;) </span><br><span class="line">endif() </span><br></pre></td></tr></table></figure></li><li><p>注意：如果需要支持非命令行Windows版本则需在上面的if判断加上else分支，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.1)</span><br><span class="line">if($&#123;CMAKE_VERSION&#125; VERSION_LESS 3.12)</span><br><span class="line">    cmake_policy(VERSION $&#123;CMAKE_MAJOR_VERSION&#125;.$&#123;CMAKE_MINOR_VERSION&#125;)</span><br><span class="line">else()</span><br><span class="line">    cmake_policy(VERSION 3.12)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置生成项目名称</p><ul><li><p>命令：<code>project（MyProject）</code>,表示生成的工程名字叫做：<code>MyProject</code></p></li><li><p>命令还可以标识项目支持的语言，写法：<code>project（MyProject[C] [C++]）</code>,不过通常将后面的参数省掉，因为默认支持所有语言</p></li><li><p>使用该指令之后系统会自动创建两个变量：<code>&lt;projectname&gt;_BINARY_DIR</code>  二进制文件保存路径、<code>&lt;projectname&gt;_SOURCE_DIR</code>  源代码路径</p></li><li><p>执行<code>project(MyProject)</code>，就是定义了一个项目的名称为<code>MyProject</code>，对应的就会生成两个变量：<code>_BINARY_DIR</code>和<code>_SOURCE_DIR</code>，但是<code>cmake</code>中其实已经有两个预定义的变量：<code>PROJECT_BINARY_DIR</code> 和 <code>PROJECT_SOURCR_DIR</code></p></li><li><p>关于两个变量是否相同，涉及到是内部构建还是外部构建</p><ul><li><p>内部构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake ./</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>外部构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd ./build</span><br><span class="line">cmake ../</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>内部构建和外部构建的不同在于：<code>cmake </code>的工作目录不同。内部构建会将<code>cmake</code>生成的中间文件和可执行文件放在和项目同一目录；外部构建的话，中间文件和可执行文件会放在<code>build</code>目录</p></li><li><p><code>PROJECT_SOURCE_DIR</code>和<code>_SOURCE_DIR</code>无论内部构建还是外部构建，指向的内容都是一样的，都指向工程的根目录</p></li><li><p><code>PROJECT_BINARY_DIR</code>和<code>_BINARY_DIR</code>指向的相同内容，内部构建的时候指向<code>CMakeLists.txt</code>文件的目录，外部构建指向<code>target</code>编译的目录</p></li></ul></li></ul></li><li><p>生成可执行文件</p><ul><li><p>语法：<code>add_executable(exename srcname)</code></p><blockquote><ul><li>exename:生成的可执行文件的名字</li><li>srcname:原来的源文件</li></ul></blockquote></li><li><p>该命令指定生成可执行文件的名字以及指出需要依赖的源文件的文件名</p></li><li><p>获取文件路径中的所有源文件</p><ul><li>命令：<code>aux_sourcr_directory(&lt;dir&gt; &lt;variable&gt;)</code></li><li>例子：<code>aux_sourcr_directory(. DIR_SRCS)</code>，将当前目录下的源文件名字存放到变量<code>DIR_SRCS</code>里面 ，如果源文件比较多，直接用<code>DIR_SRCS</code>变量即可</li></ul></li><li><p>生成可执行文件：<code>add_executable(Demo $&#123;DIR_SRCS&#125;)</code>，将生成的可执行文件命名为：<code>Demo</code></p></li></ul></li><li><p>生成<code>lib</code>库</p><ul><li><p>命令：<code>add_library(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)</code></p><blockquote><ul><li><code>libname</code>:生成的库文件的名字</li><li><code>[SHARED|STATIC|MODULE]</code>：生成库文件的类型（动态库|静态库|模块）</li><li><code>[EXCLUDE_FROM_ALL]</code>：有这个参数表示该库不会被默认构建</li><li><code>source2 ... sourceN</code>：生成库依赖的源文件，如果源文件比较多，可以使用</li><li><code>aux_sourcr_directory</code>命令获取路径下所有源文件，具体章节参见：<code>CMake</code>初探-&gt;生成可执行文件-&gt;获取路径中所有源文件</li></ul></blockquote></li><li><p>例子：<code>add_library(ALib SHARE alib.cpp)</code></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_executable(demo demo.cpp) # 生成可执行文件</span><br><span class="line">add_library(common STATIC util.cpp) # 生成静态库</span><br><span class="line">add_library(common SHARED util.cpp) # 生成动态库或共享库</span><br></pre></td></tr></table></figure><blockquote><p><code>add_library</code> 默认生成是静态库，通过以上命令生成文件名字，</p><ul><li>在 Linux 下是：<br>demo<br>libcommon.a<br>libcommon.so</li><li>在 Windows 下是：<br>demo.exe<br>common.lib<br>common.dll</li></ul></blockquote><ul><li><p>添加头文件目录</p><ul><li><p>命令1：<code>target_include_directories(&lt;target&gt; [SYSTEM] [BEFORE]   &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]   [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</code></p><blockquote><p>当我们添加子项目之后还需要设置一个<code>include</code>路径，例子：<br>eg:<code>target_include_directories(RigelEditor PUBLIC ./include/rgeditor)</code>，表示给<code>RigelEditor</code> 这个子项目添加一个库文件的路径</p></blockquote></li><li><p>命令2：<code>include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 …])</code></p><blockquote><p>参数解析：</p><ul><li>[AFTER|BEFORE]：指定了要添加路径是添加到原有列表之前还是之后</li><li>[SYSTEM]：若指定了<code>system</code>参数，则把被包含的路径当做系统包含路径来处理</li><li>dir1 [dir2 …]把这些路径添加到<code>CMakeLists</code>及其子目录的<code>CMakeLists</code>的头文件包含项目中<br>相当于<code>g++</code>选项中的-l的参数的作用</li><li>举例：<code>include_directories(&quot;/opt/MATLAB/R2012a/extern/include&quot;)</code></li></ul></blockquote></li></ul><ul><li>两条指令的作用都是讲将<code>include</code>的目录添加到目标区别在于<code>include_directorie</code>s是<code>CMake</code>编译所有目标的目录进行添加，<code>target_include_directories</code>是将<code>CMake</code>编译的指定的特定目标的包含目录进行添加</li></ul></li><li><p>添加需要链接的库文件路径</p><ul><li><p>命令1:<code>target_link_libraries(&lt;target&gt; [item1 [item2 [...]]] [[debug|optimized|general] &lt;item&gt;] ...)</code></p><blockquote><ul><li>作用：为给定的目标设置链接时使用的库（设置要链接的库文件的名称）</li><li>eg:target_link_libraries(MyProject a b.a <a href="http://c.so/">c.so</a>)    //将若干库文件链接到hello中，target_link_libraries里的库文件的顺序符合gcc/g++链接顺序规则，即：被依赖的库放在依赖他的库的后面，如果顺序有错，链接将会报错</li><li>关键字：debug对应于调试配置</li><li>关键字：optimized对应于所有其他的配置类型</li><li>关键字：general对应于所有的配置（该属性是默认值）</li></ul></blockquote></li><li><p>命令2：<code>link_libraries</code></p><blockquote><ul><li>作用：给当前工程链接需要的库文件（全路径）</li><li>eg:<code>link_libraries((&quot;/opt/MATLAB/R2012a/bin/glnxa64/libeng.so&quot;)</code>//必须添加带名字的全路径</li></ul></blockquote></li><li><p>区别：<code>target_link_libraries</code>可以给工程或者库文件设置其需要链接的库文件，而且不需要填写全路径，但是<code>link_libraries</code>只能给工程添加依赖的库，而且必须添加全路径</p></li><li><p>添加需要链接的库文件目录</p><blockquote><ul><li><p>命令：link_directories（添加需要链接的库文件目录）</p></li><li><p>语法：link_directories(directory1 directory2 …)</p></li><li><p>例子：link_directories(“/opt/MATLAB/R2012a/bin/glnxa64”)</p></li></ul></blockquote></li><li><p>指令的区别：指令的前缀带<code>target</code>，表示针对某一个目标进行设置，必须指明设置的目标；<code>include_directories</code>是在编译时用，指明<code>.h</code>文件的路径；<code>link_directoeies</code>是在链接时用的，指明链接库的路径；<code>target_link_libraries</code>是指明链接库的名字，也就是具体谁链接到哪个库。<code>link_libraries</code>不常用，因为必须指明带文件名全路径</p></li></ul></li><li><p>控制目标属性</p><ul><li><p>以上的几条命令的区分都是：是否带<code>target</code>前缀，在<code>CMake</code>里面，一个<code>target</code>有自己的属性集，如果我们没有显示的设置这些<code>target</code>的属性的话，<code>CMake</code>默认是由相关的全局属性来填充<code>target</code>的属性，我们如果需要单独的设置<code>target</code>的属性，需要使用命令：<code>set_target_properties()</code></p></li><li><p>命令格式:</p><blockquote><p>set_target_properties(target1 target2 …<br>PROPERTIES<br>属性名称1  值<br>属性名称2  值<br>…<br>)</p></blockquote></li><li><p>控制编译选项的属性是：<code>COMPILE_FLAGS</code></p></li><li><p>控制链接选项的属性是：<code>LINK_FLAGS</code></p></li><li><p>控制输出路径的属性：<code>EXECUTABLE_OUTPUT_PATH</code>（exe的输出路径）、<code>LIBRARY_OUTPUT_PATH</code>（库文件的输出路径）</p></li><li><p>举例：</p><blockquote><p>set_target_properties(exe<br>PROPERTIES<br>LINK_FLAGS          -static<br>LINK_FLAGS_RELEASE  -s<br>)</p></blockquote><p>这条指令会使得<code>exe</code>这个目标在所有的情况下都采用<code>-static</code>选项，而且在<code>release build</code>的时候<code>-static -s</code>选项。但是这个属性仅仅在<code>exe</code>这个<code>target</code>上面有效</p></li></ul></li></ul><h3 id="Cmake构建示例"><a href="#Cmake构建示例" class="headerlink" title="Cmake构建示例"></a>Cmake构建示例</h3><p>经典的<code>helloworld</code>必须出现啊，首先创建一个<code>main.cpp</code>包含源的文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> parameter_size, <span class="keyword">char</span> **parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = a + <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello word  &quot;</span> &lt;&lt; parameter_size &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们创建一个 <code>CMakeLists.txt</code>同一个目录中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.5)</span><br><span class="line">#项目名称</span><br><span class="line">project(test_cmaka)</span><br><span class="line">#代码路径</span><br><span class="line">aux_source_directory(. DIR_TOOT_SRCS)</span><br><span class="line">#dubug 模式</span><br><span class="line">set (CMAKE_CXX_FLAGS  &quot;$&#123;CMAKE_CXX_FLAGS&#125; -g&quot;)</span><br><span class="line">#将可执行文件放入bin目录</span><br><span class="line">set( EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line">#生成可执行的文件</span><br><span class="line">add_executable(main $&#123;DIR_TOOT_SRCS&#125;)</span><br></pre></td></tr></table></figure><p>文件目录 如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- test_cmake</span><br><span class="line">    |-- main.cpp</span><br><span class="line">    |-- CMakeLists.txt</span><br></pre></td></tr></table></figure><p>现在准备构建我们的应用程序，导航到文件目录下，创建<code>build</code>文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build</span><br></pre></td></tr></table></figure><p>进入<code>build</code>目录，执行外部构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd build</span><br><span class="line"># cmake ../</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- The C compiler identification is GNU 7.5.0</span><br><span class="line">-- The CXX compiler identification is GNU 7.5.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /root/share/C++/test_cmake/build</span><br></pre></td></tr></table></figure><p>再看看目录下的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMakeCache.txt  CMakeFiles  cmake_install.cmake  Makefile</span><br></pre></td></tr></table></figure><p>可以看到成功生成了Makefile，还有一些cmake运行时自动生成的文件<br>然后在终端下输入make并回车,输出以下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanning dependencies of target main</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/main.dir/main.cpp.o</span><br><span class="line">[100%] Linking CXX executable ../bin/main</span><br><span class="line">[100%] Built target main</span><br></pre></td></tr></table></figure><p>此时，文件目录如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-- test_cmake</span><br><span class="line">    |-- bin</span><br><span class="line">    |-- build</span><br><span class="line">    |-- main.cpp</span><br><span class="line">    |-- CMakeLists.txt</span><br></pre></td></tr></table></figure><p>生成的可执行文件在<code>bin</code>目录下，导航到该目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ../bin</span><br><span class="line">./main</span><br></pre></td></tr></table></figure><p>产生预期的输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello word  1 </span><br></pre></td></tr></table></figure><p><code>github</code>上有不错的<code>CMake——examples</code>  链接：<a href="https://github.com/ttroy50/cmake-examples">https://github.com/ttroy50/cmake-examples</a></p><h1 id="Meson笔记"><a href="#Meson笔记" class="headerlink" title="Meson笔记"></a>Meson笔记</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux安装-1"><a href="#Linux安装-1" class="headerlink" title="Linux安装"></a>Linux安装</h3><ul><li><p>Meson基于Python3运行，要求Python版本3.5以上</p></li><li><p>安装依赖 <code>ninja-build</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ninja-build</span><br></pre></td></tr></table></figure></li><li><p>安装<code>Meson</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install meson #root      </span><br><span class="line"></span><br><span class="line">pip3 install --user meson #user 官方推荐</span><br></pre></td></tr></table></figure></li><li><p>也从<code>git</code>下载安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/mesonbuild/meson.git /path/to/sourcedir</span><br></pre></td></tr></table></figure></li></ul><h3 id="Meson构建示例"><a href="#Meson构建示例" class="headerlink" title="Meson构建示例"></a>Meson构建示例</h3><p>依然经典的<code>helloworld</code>，首先创建一个<code>main.c</code>包含源的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello there.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们创建一个 <code>meson.build</code>同一个目录中调用的文中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">project(&#x27;tutorial&#x27;, &#x27;c&#x27;)</span><br><span class="line">executable(&#x27;main&#x27;, &#x27;main.c&#x27;)</span><br></pre></td></tr></table></figure><p>文件目录如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- test_meson</span><br><span class="line">    |-- main.c</span><br><span class="line">    |-- meson.build</span><br></pre></td></tr></table></figure><p>现在准备构建我们的应用程序，导航到文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#构建程序</span><br><span class="line">$ meson build</span><br></pre></td></tr></table></figure><p>创建一个单独的构建目录<code>build</code>来保存所有编译器输出。<code>Meson</code> 与其他一些构建系统的不同之处在于它不允许源代码构建。您必须始终创建一个单独的构建目录。常见的约定是将默认构建目录放在顶级源目录的子目录中</p><p>当 <code>Meson</code> 运行时，它会打印以下输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">The Meson build system</span><br><span class="line">Version: 0.58.1</span><br><span class="line">Source dir: /root/share/C++/test_meson</span><br><span class="line">Build dir: /root/share/C++/test_meson/build</span><br><span class="line">Build type: native build</span><br><span class="line">Project name: tutorial</span><br><span class="line">Project version: undefined</span><br><span class="line">C compiler for the host machine: cc (gcc 7.5.0 &quot;cc (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;)</span><br><span class="line">C linker for the host machine: cc ld.bfd 2.30</span><br><span class="line">Host machine cpu family: x86_64</span><br><span class="line">Host machine cpu: x86_64</span><br><span class="line">Build targets in project: 1</span><br></pre></td></tr></table></figure><p>现在已经准备好构建我们的代码了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd buildd</span><br><span class="line">$ ninja</span><br></pre></td></tr></table></figure><p>如果您的 <code>Meson</code> 版本高于 <code>0.55.0</code>，您可以使用新的后端不可知构建命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd build</span><br><span class="line">$ meson compile</span><br></pre></td></tr></table></figure><p>一旦构建了可执行文件，我们就可以运行它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure><p>这会产生预期的输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello there.</span><br></pre></td></tr></table></figure><p>​    </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mubu.com/doc/t1VDCEn4O0#o-17f166a665726b18d">https://mubu.com/doc/t1VDCEn4O0#o-17f166a665726b18d</a></p><p><a href="https://cmake.org/documentation">https://cmake.org/documentation</a></p><p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">https://cmake.org/cmake/help/latest/guide/tutorial/index.html</a></p><p><a href="https://mesonbuild.com/">https://mesonbuild.com/</a></p>]]></content>
    
    
    <summary type="html">学习生产力工具CMake、Meson</summary>
    
    
    
    <category term="Tools" scheme="http://example.com/categories/Tools/"/>
    
    
    <category term="CMake" scheme="http://example.com/tags/CMake/"/>
    
    <category term="Meson" scheme="http://example.com/tags/Meson/"/>
    
  </entry>
  
  <entry>
    <title>多路复用-select、poll、epoll</title>
    <link href="http://example.com/2021/03/29/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select%E3%80%81poll%E3%80%81epoll/"/>
    <id>http://example.com/2021/03/29/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select%E3%80%81poll%E3%80%81epoll/</id>
    <published>2021-03-29T02:04:11.000Z</published>
    <updated>2023-12-31T18:44:13.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多路复用之select、poll、epoll详解"><a href="#多路复用之select、poll、epoll详解" class="headerlink" title="多路复用之select、poll、epoll详解"></a>多路复用之select、poll、epoll详解</h1><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p><blockquote><ol><li>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。</li><li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li><li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li><li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li><li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li></ol></blockquote><p>与多进程和多线程技术相比，<code>I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程</code>，也不必维护这些进程/线程，从而大大减小了系统的开销。</p><p>目前支持I/O多路复用的系统调用有 <code>select，pselect，poll，epoll</code>，I/O多路复用就是<code>通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</code>。<code>但select，pselect，poll，epoll本质上都是同步I/O</code>，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><h2 id="select、poll、epoll简介"><a href="#select、poll、epoll简介" class="headerlink" title="select、poll、epoll简介"></a>select、poll、epoll简介</h2><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，<code>其中epoll是Linux所特有，而select则应该是POSIX所规定</code>，一般操作系统均有实现。</p><h3 id="selsect"><a href="#selsect" class="headerlink" title="selsect"></a>selsect</h3><p><strong>基本原理</strong></p><blockquote><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p></blockquote><p><strong>基本流程，如图所示：</strong></p><p><img src="/2021/03/29/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select%E3%80%81poll%E3%80%81epoll/03.png" alt="01"></p><blockquote><ol><li>使用copy_from_user从用户空间拷贝fd_set到内核空间</li><li>注册回调函数__pollwait</li><li>遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</li><li>以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。</li><li>__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</li><li>poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</li><li>如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</li><li>把fd_set从内核空间拷贝到用户空间。</li></ol></blockquote><p>select目前几乎在所有的平台上支持，<code>其良好跨平台支持也是它的一个优点</code>。<code>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制</code>，在Linux上一般为<code>1024</code>，<code>可以通过修改宏定义甚至重新编译内核的方式提升这一限制</code>，但是这样也会造成效率的降低。</p><p><code>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理</code>。这样所带来的缺点是：</p><ol><li><strong>单个进程可监视的fd数量被限制，即能监听端口的大小有限。。</strong></li></ol><blockquote><p>单个用户的文件描述符上限<code>ulimit -n //1024</code> ，linux系统本身就有文件描述符上限和系统内存关系很大，<code>具体数目可以cat /proc/sys/fs/file-max 查看</code>。</p></blockquote><ol start="2"><li><strong>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</strong></li></ol><blockquote><p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。<code>如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询</code>，这正是epoll与kqueue做的。</p><p><strong>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p><p><strong>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></p></blockquote><ol start="3"><li><strong>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</strong></li></ol><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><strong>基本原理：</strong></p><blockquote><p>poll的实现和select非常相似，只是描述fd集合的方式不同，<code>poll使用pollfd结构而不是select的fd_set结构</code>，其他的都差不多,管理多个描述符也是进行轮询，根据描述符的状态进行处理，<strong>但是poll没有最大文件描述符数量的限制</strong>。poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><p><code>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间</code>，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p></blockquote><p><strong>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：</strong></p><blockquote><ol><li><code>大量的fd的数组被整体复制于用户态和内核地址空间之间</code>，而不管这样的复制是不是有意义。</li><li><code>poll还有一个特点是“水平触发”</code>，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li></ol></blockquote><p><strong>注意：</strong></p><blockquote><p>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，<code>同时连接的大量客户端在一时刻可能只有很少的处于就绪状态</code>，因此随着监视的描述符数量的增长，其效率也会线性下降。</p></blockquote><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><strong>基本流程，如图所示：</strong></p><p><img src="/2021/03/29/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select%E3%80%81poll%E3%80%81epoll/04.png" alt="01"></p><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本，可以理解位<code>event poll</code>。相对于select和poll来说，epoll更加灵活，没有描述符限制。<code>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次</code>。</p><p><strong>基本原理：</strong></p><blockquote><p><code>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次</code>。还有一个特点是，<code>epoll使用“事件”的就绪通知方式</code>，通过epoll_ctl注册fd，<code>一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd</code>，epoll_wait便可以收到通知。</p></blockquote><p><strong>epoll的优点：</strong></p><blockquote><ol><li><code>没有最大并发连接的限制</code>，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li><li><code>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降</code>。只有活跃可用的FD才会调用callback函数；<code>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关</code>，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li><li><code>内存拷贝</code>，利用mmap()文件映射内存加速与内核空间的消息传递；<code>即epoll使用mmap减少复制开销</code>。</li></ol></blockquote><p><strong>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</strong></p><blockquote><p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。若就绪的事件一次没有处理完要做的事件，就会一直去处理。即就会将没有处理完的事件继续放回到就绪队列之中（即那个内核中的链表）</p><p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。就绪的事件只能处理<strong>一次</strong>，若没有处理完会在下次的其它事件就绪时再进行处理。而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失。 </p></blockquote><ol><li><strong>LT模式</strong></li></ol><blockquote><p><code>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket</code>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。<code>如果你不作任何操作，内核还是会继续通知你的</code>。</p></blockquote><ol start="2"><li><strong>ET模式</strong></li></ol><blockquote><p><code>ET(edge-triggered)是高速工作方式，只支持no-block socket</code>。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。<code>但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</code>。</p><p><code>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高</code>。epoll工作在ET模式的时候，<code>必须使用非阻塞套接口</code>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p></blockquote><ol start="3"><li>在select/poll中，<code>进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描</code>，而epoll事先通过epoll_ctl()来注册一个文件描述符，<code>一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制</code>，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。</code>)</li></ol><p><strong>注意：</strong></p><blockquote><p>如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll。</p></blockquote><p><strong>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</strong></p><blockquote><ol><li>表面上看epoll的性能最好，<code>但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好</code>，毕竟epoll的通知机制需要很多函数回调。</li><li><code>select低效是因为每次它都需要轮询</code>。但低效也是相对的，视情况而定，也可通过良好的设计改善。</li></ol></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>select</strong></p><blockquote><ul><li>单进程可以打开fd有限制，1024；</li><li>对socket进行扫描时是线性扫描，时间复杂度:O(n)，即采用轮询的方法，效率较低；</li><li>用户空间和内核空间的复制非常消耗资源；</li></ul></blockquote><p><strong>poll</strong></p><blockquote><ul><li>调用过程和select类似，时间复杂度:O(n)</li><li>其和select不同的地方：采用<strong>链表</strong>的方式替换原有fd_set数据结构,而使其<strong>没有连接数的限制</strong>。</li></ul></blockquote><p><strong>epoll</strong></p><blockquote><ul><li><strong>LT</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。 </li><li><strong>ET</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。 </li><li>ET模式的效率比LT模式的效率要高很多。只是如果使用ET模式，就要保证每次进行数据处理时，要将其处理完，不能造成数据丢失。</li><li>ET模式只支持非阻塞的读写：为了保证数据的完整性。</li></ul></blockquote><h2 id="epoll实现多路复用"><a href="#epoll实现多路复用" class="headerlink" title="epoll实现多路复用"></a>epoll实现多路复用</h2><p>由于epoll的实现机制与select/poll机制完全不同，上面所说的 select的缺点在epoll上不复存在。</p><p>设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p><p>在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p><p>epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先的select/poll调用分成了3个部分：</p><blockquote><ul><li>调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</li><li>调用epoll_ctl向epoll对象中添加这100万个连接的套接字</li><li>调用epoll_wait收集发生的事件的连接</li></ul></blockquote><p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</p><p><strong>下面来看看Linux内核具体的epoll机制实现思路。</strong><br>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>&#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</p><p>而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p><p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span><span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllink</span>;</span><span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span>  <span class="comment">//事件句柄信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>    <span class="comment">//指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。<br><img src="/2021/03/29/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select%E3%80%81poll%E3%80%81epoll/05.png" alt="01"></p><p>从上面的可知：通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。一句话描述就是：三步曲。</p><blockquote><p>第一步：epoll_create()系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。</p><p>第二步：epoll_ctl()系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。</p><p>第三部：epoll_wait()系统调用。通过此调用收集收集在epoll监控中已经发生的事件。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a simple echo server using epoll in linux  </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 500  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> fd;  </span><br><span class="line">    <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg);  </span><br><span class="line">    <span class="keyword">int</span> events;  </span><br><span class="line">    <span class="keyword">void</span> *arg;  </span><br><span class="line">    <span class="keyword">int</span> status; <span class="comment">// 1: in epoll wait list, 0 not in  </span></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">128</span>]; <span class="comment">// recv data buffer  </span></span><br><span class="line">    <span class="keyword">int</span> len, s_offset;  </span><br><span class="line">    <span class="keyword">long</span> last_active; <span class="comment">// last active time  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// set event  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventSet</span><span class="params">(myevent_s *ev, <span class="keyword">int</span> fd, <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span>*), <span class="keyword">void</span> *arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    ev-&gt;fd = fd;  </span><br><span class="line">    ev-&gt;call_back = call_back;  </span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;  </span><br><span class="line">    ev-&gt;arg = arg;  </span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    bzero(ev-&gt;buff, <span class="keyword">sizeof</span>(ev-&gt;buff));</span><br><span class="line">    ev-&gt;s_offset = <span class="number">0</span>;  </span><br><span class="line">    ev-&gt;len = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;last_active = time(<span class="literal">NULL</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// add/mod an event to epoll  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventAdd</span><span class="params">(<span class="keyword">int</span> epollFd, <span class="keyword">int</span> events, myevent_s *ev)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;  </span><br><span class="line">    <span class="keyword">int</span> op;  </span><br><span class="line">    epv.data.ptr = ev;  </span><br><span class="line">    epv.events = ev-&gt;events = events;  </span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status == <span class="number">1</span>)&#123;  </span><br><span class="line">        op = EPOLL_CTL_MOD;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>&#123;  </span><br><span class="line">        op = EPOLL_CTL_ADD;  </span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(epoll_ctl(epollFd, op, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Event Add failed[fd=%d], evnets[%d]\n&quot;</span>, ev-&gt;fd, events);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Event Add OK[fd=%d], op=%d, evnets[%0X]\n&quot;</span>, ev-&gt;fd, op, events);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// delete an event from epoll  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventDel</span><span class="params">(<span class="keyword">int</span> epollFd, myevent_s *ev)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;  </span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status != <span class="number">1</span>) <span class="keyword">return</span>;  </span><br><span class="line">    epv.data.ptr = ev;  </span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    epoll_ctl(epollFd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">int</span> g_epollFd;  </span><br><span class="line">myevent_s g_Events[MAX_EVENTS+<span class="number">1</span>]; <span class="comment">// g_Events[MAX_EVENTS] is used by listen fd  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecvData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;  </span><br><span class="line"><span class="comment">// accept new connections from clients  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AcceptConn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>  </span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct sockaddr_in);  </span><br><span class="line">    <span class="keyword">int</span> nfd, i;  </span><br><span class="line">    <span class="comment">// accept  </span></span><br><span class="line">    <span class="keyword">if</span>((nfd = accept(fd, (struct sockaddr*)&amp;<span class="built_in">sin</span>, &amp;len)) == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EINTR)  </span><br><span class="line">        &#123;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: accept, %d&quot;</span>, __func__, errno);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_EVENTS; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(g_Events[i].status == <span class="number">0</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(i == MAX_EVENTS)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s:max connection limit[%d].&quot;</span>, __func__, MAX_EVENTS);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// set nonblocking</span></span><br><span class="line">        <span class="keyword">int</span> iret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((iret = fcntl(nfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: fcntl nonblocking failed:%d&quot;</span>, __func__, iret);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add a read event for receive data  </span></span><br><span class="line">        EventSet(&amp;g_Events[i], nfd, RecvData, &amp;g_Events[i]);  </span><br><span class="line">        EventAdd(g_epollFd, EPOLLIN, &amp;g_Events[i]);  </span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new conn[%s:%d][time:%d], pos[%d]\n&quot;</span>, inet_ntoa(<span class="built_in">sin</span>.sin_addr),</span><br><span class="line">            ntohs(<span class="built_in">sin</span>.sin_port), g_Events[i].last_active, i);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// receive data  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecvData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (struct myevent_s*)arg;  </span><br><span class="line">    <span class="keyword">int</span> len;  </span><br><span class="line">    <span class="comment">// receive data</span></span><br><span class="line">    len = recv(fd, ev-&gt;buff+ev-&gt;len, <span class="keyword">sizeof</span>(ev-&gt;buff)<span class="number">-1</span>-ev-&gt;len, <span class="number">0</span>);    </span><br><span class="line">    EventDel(g_epollFd, ev);</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;len += len;</span><br><span class="line">        ev-&gt;buff[len] = <span class="string">&#x27;\0&#x27;</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C[%d]:%s\n&quot;</span>, fd, ev-&gt;buff);  </span><br><span class="line">        <span class="comment">// change to send event  </span></span><br><span class="line">        EventSet(ev, fd, SendData, ev);  </span><br><span class="line">        EventAdd(g_epollFd, EPOLLOUT, ev);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        close(ev-&gt;fd);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d] pos[%d], closed gracefully.\n&quot;</span>, fd, ev-g_Events);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        close(ev-&gt;fd);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv[fd=%d] error[%d]:%s\n&quot;</span>, fd, errno, strerror(errno));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// send data  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (struct myevent_s*)arg;  </span><br><span class="line">    <span class="keyword">int</span> len;  </span><br><span class="line">    <span class="comment">// send data  </span></span><br><span class="line">    len = send(fd, ev-&gt;buff + ev-&gt;s_offset, ev-&gt;len - ev-&gt;s_offset, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d], [%d&lt;-&gt;%d]%s\n&quot;</span>, fd, len, ev-&gt;len, ev-&gt;buff);</span><br><span class="line">        ev-&gt;s_offset += len;</span><br><span class="line">        <span class="keyword">if</span>(ev-&gt;s_offset == ev-&gt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// change to receive event</span></span><br><span class="line">            EventDel(g_epollFd, ev);  </span><br><span class="line">            EventSet(ev, fd, RecvData, ev);  </span><br><span class="line">            EventAdd(g_epollFd, EPOLLIN, ev);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        close(ev-&gt;fd);  </span><br><span class="line">        EventDel(g_epollFd, ev);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d] error[%d]\n&quot;</span>, fd, errno);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitListenSocket</span><span class="params">(<span class="keyword">int</span> epollFd, <span class="keyword">short</span> port)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> listenFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    fcntl(listenFd, F_SETFL, O_NONBLOCK); <span class="comment">// set non-blocking  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server listen fd=%d\n&quot;</span>, listenFd);  </span><br><span class="line">    EventSet(&amp;g_Events[MAX_EVENTS], listenFd, AcceptConn, &amp;g_Events[MAX_EVENTS]);  </span><br><span class="line">    <span class="comment">// add listen socket  </span></span><br><span class="line">    EventAdd(epollFd, EPOLLIN, &amp;g_Events[MAX_EVENTS]);  </span><br><span class="line">    <span class="comment">// bind &amp; listen  </span></span><br><span class="line">    sockaddr_in <span class="built_in">sin</span>;  </span><br><span class="line">    bzero(&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));  </span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;  </span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;  </span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons(port);  </span><br><span class="line">    bind(listenFd, (<span class="keyword">const</span> sockaddr*)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));  </span><br><span class="line">    listen(listenFd, <span class="number">5</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> port = <span class="number">12345</span>; <span class="comment">// default port  </span></span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">2</span>)&#123;  </span><br><span class="line">        port = atoi(argv[<span class="number">1</span>]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// create epoll  </span></span><br><span class="line">    g_epollFd = epoll_create(MAX_EVENTS);  </span><br><span class="line">    <span class="keyword">if</span>(g_epollFd &lt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;create epoll failed.%d\n&quot;</span>, g_epollFd);  </span><br><span class="line">    <span class="comment">// create &amp; bind listen socket, and add to epoll, set non-blocking  </span></span><br><span class="line">    InitListenSocket(g_epollFd, port);  </span><br><span class="line">    <span class="comment">// event loop  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span>  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server running:port[%d]\n&quot;</span>, port);  </span><br><span class="line">    <span class="keyword">int</span> checkPos = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="comment">// a simple timeout check here, every time 100, better to use a mini-heap, and add timer event  </span></span><br><span class="line">        <span class="keyword">long</span> now = time(<span class="literal">NULL</span>);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++, checkPos++) <span class="comment">// doesn&#x27;t check listen fd  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(checkPos == MAX_EVENTS) checkPos = <span class="number">0</span>; <span class="comment">// recycle  </span></span><br><span class="line">            <span class="keyword">if</span>(g_Events[checkPos].status != <span class="number">1</span>) <span class="keyword">continue</span>;  </span><br><span class="line">            <span class="keyword">long</span> duration = now - g_Events[checkPos].last_active;  </span><br><span class="line">            <span class="keyword">if</span>(duration &gt;= <span class="number">60</span>) <span class="comment">// 60s timeout  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                close(g_Events[checkPos].fd);  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d] timeout[%d--%d].\n&quot;</span>, g_Events[checkPos].fd, g_Events[checkPos].last_active, now);  </span><br><span class="line">                EventDel(g_epollFd, &amp;g_Events[checkPos]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// wait for events to happen  </span></span><br><span class="line">        <span class="keyword">int</span> fds = epoll_wait(g_epollFd, events, MAX_EVENTS, <span class="number">1000</span>);  </span><br><span class="line">        <span class="keyword">if</span>(fds &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait error, exit\n&quot;</span>);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fds; i++)&#123;  </span><br><span class="line">            myevent_s *ev = (struct myevent_s*)events[i].data.ptr;  </span><br><span class="line">            <span class="keyword">if</span>((events[i].events&amp;EPOLLIN)&amp;&amp;(ev-&gt;events&amp;EPOLLIN)) <span class="comment">// read event  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>((events[i].events&amp;EPOLLOUT)&amp;&amp;(ev-&gt;events&amp;EPOLLOUT)) <span class="comment">// write event  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// free resource  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多路复用之select、poll、epoll详解</summary>
    
    
    
    <category term="多路复用" scheme="http://example.com/categories/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
    
    <category term="I/O" scheme="http://example.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>网络IO演变发展过程和模型介绍</title>
    <link href="http://example.com/2021/03/24/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E7%BD%91%E7%BB%9CIO/"/>
    <id>http://example.com/2021/03/24/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E7%BD%91%E7%BB%9CIO/</id>
    <published>2021-03-24T06:04:11.000Z</published>
    <updated>2023-12-31T18:44:13.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络-IO-演变发展过程和模型介绍"><a href="#网络-IO-演变发展过程和模型介绍" class="headerlink" title="网络 IO 演变发展过程和模型介绍"></a>网络 IO 演变发展过程和模型介绍</h1><blockquote><p>转腾讯技术工程——<a href="https://mp.weixin.qq.com/s/EDzFOo3gcivOe_RgipkTkQ">网络 IO 演变发展过程和模型介绍</a></p></blockquote><p>在互联网中提起网络，我们都会避免不了讨论高并发、百万连接。而此处的百万连接的实现，脱离不了网络 IO 的选择，因此本文作为一篇个人学习的笔记，特此进行记录一下整个网络 IO 的发展演变过程。以及目前广泛使用的网络模型。</p><h2 id="1-网络-IO-的发展"><a href="#1-网络-IO-的发展" class="headerlink" title="1.网络 IO 的发展"></a>1.网络 IO 的发展</h2><p>在本节内容中，我们将一步一步介绍网络 IO 的演变发展过程。介绍完发展过程后，再对网络 IO 中几组容易混淆的概念进行对比、分析。</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415112127.webp"></p><h3 id="1-1-网络-IO-的各个发展阶段"><a href="#1-1-网络-IO-的各个发展阶段" class="headerlink" title="1.1 网络 IO 的各个发展阶段"></a>1.1 网络 IO 的各个发展阶段</h3><p>通常，我们在此讨论的网络 IO 一般都是针对 linux 操作系统而言。网络 IO 的发展过程是随着 linux 的内核演变而变化，因此网络 IO 大致可以分为如下几个阶段：</p><p><strong>1. 阻塞 IO(BIO)</strong><br><strong>2. 非阻塞 IO(NIO)</strong><br><strong>3. IO 多路复用第一版(select/poll)</strong><br><strong>4. IO 多路复用第二版(epoll)</strong><br><strong>5. 异步 IO(AIO)</strong></p><p>而每一个阶段，都是因为当前的网络有一些缺陷，因此又在不断改进该缺陷。这是<strong>网络 IO 一直演变过程中的本质</strong>。下面将对上述几个阶段进行介绍，并对每个阶段的网络 IO 解决了哪些问题、优点、缺点进行剖析。</p><h3 id="1-2-网络的两个阶段"><a href="#1-2-网络的两个阶段" class="headerlink" title="1.2 网络的两个阶段"></a>1.2 网络的两个阶段</h3><p>在网络中，我们通常可以将其广义上划分为以下两个阶段：</p><p><strong>第一阶段：硬件接口到内核态</strong><br><strong>第二阶段：内核态到用户态</strong></p><p>本人理解：我们通常上网，大部分数据都是通过网线传递的。因此对于两台计算机而言，要进行网络通信，其数据都是先从应用程序传递到传输层(TCP/UDP)到达内核态，然后再到网络层、数据链路层、物理层，接着数据传递到硬件网卡，最后通过网络传输介质传递到对端机器的网卡，然后再一步一步数据从网卡传递到内核态，最后再拷贝到用户态。</p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415112223.webp" style="zoom:50%;"><h3 id="1-3-阻塞-IO-和非阻塞-IO-的区别"><a href="#1-3-阻塞-IO-和非阻塞-IO-的区别" class="headerlink" title="1.3 阻塞 IO 和非阻塞 IO 的区别"></a>1.3 阻塞 IO 和非阻塞 IO 的区别</h3><p>根据 1.2 节的内容，我们可以知道，网络中的数据传输从网络传输介质到达目的机器，需要如上两个阶段。此处我们把从<strong>硬件到内核态</strong>这一阶段，是否发生阻塞等待，可以将网络分为<strong>阻塞 IO</strong>和<strong>非阻塞 IO</strong>。如果用户发起了读写请求，但内核态数据还未准备就绪，该阶段不会阻塞用户操作，内核立马返回，则称为非阻塞 IO。如果该阶段一直阻塞用户操作。直到内核态数据准备就绪，才返回。这种方式称为阻塞 IO。</p><p>因此，区分阻塞 IO 和非阻塞 IO 主要看第一阶段是否阻塞用户操作。</p><h3 id="1-4-同步-IO-和异步-IO-的区别"><a href="#1-4-同步-IO-和异步-IO-的区别" class="headerlink" title="1.4 同步 IO 和异步 IO 的区别"></a>1.4 同步 IO 和异步 IO 的区别</h3><p>从前面我们知道了，数据的传递需要两个阶段，在此处只要任何一个阶段会阻塞用户请求，都将其称为同步 IO，两个阶段都不阻塞，则称为异步 IO。</p><p>在目前所有的操作系统中，linux 中的 epoll、mac 的 kqueue 都属于同步 IO，因为其在第二阶段(数据从内核态到用户态)都会发生拷贝阻塞。而只有 windows 中的 IOCP 才真正属于异步 IO，即 AIO。</p><h2 id="2-阻塞-IO"><a href="#2-阻塞-IO" class="headerlink" title="2.阻塞 IO"></a>2.阻塞 IO</h2><p>在本节，我们将介绍最初的阻塞 IO，阻塞 IO 英文为 blocking IO，又称为 BIO。根据前面的介绍，阻塞 IO 主要指的是第一阶段(硬件网卡到内核态)。</p><h3 id="2-1-阻塞-IO-的概念"><a href="#2-1-阻塞-IO-的概念" class="headerlink" title="2.1 阻塞 IO 的概念"></a>2.1 阻塞 IO 的概念</h3><p>阻塞 IO，顾名思义当用户发生了系统调用后，如果数据未从网卡到达内核态，内核态数据未准备好，此时会一直阻塞。直到数据就绪，然后从内核态拷贝到用户态再返回。具体过程可以参考 2.2 的图示。</p><h3 id="2-2-阻塞-IO-的过程"><a href="#2-2-阻塞-IO-的过程" class="headerlink" title="2.2 阻塞 IO 的过程"></a>2.2 阻塞 IO 的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415112344.webp"></p><h3 id="2-3-阻塞-IO-的缺点"><a href="#2-3-阻塞-IO-的缺点" class="headerlink" title="2.3 阻塞 IO 的缺点"></a>2.3 阻塞 IO 的缺点</h3><p>在一般使用阻塞 IO 时，都需要配置多线程来使用，最常见的模型是<strong>阻塞 IO+多线程</strong>，每个连接一个单独的线程进行处理。</p><p><strong>我们知道，一般一个程序可以开辟的线程是有限的，而且开辟线程的开销也是比较大的。也正是这种方式，会导致一个应用程序可以处理的客户端请求受限。面对百万连接的情况，是无法处理。</strong></p><p>既然发现了问题，分析了问题，那就得解决问题。既然阻塞 IO 有问题，本质是由于其阻塞导致的，因此自然而然引出了下面即将介绍的主角：<strong>非阻塞 IO</strong></p><h2 id="3-非阻塞-IO"><a href="#3-非阻塞-IO" class="headerlink" title="3.非阻塞 IO"></a>3.非阻塞 IO</h2><p>非阻塞 IO 是为了解决前面提到的阻塞 IO 的缺陷而引出的，下面我们将介绍非阻塞 IO 的过程。</p><h3 id="3-1-非阻塞-IO-的概念"><a href="#3-1-非阻塞-IO-的概念" class="headerlink" title="3.1 非阻塞 IO 的概念"></a>3.1 非阻塞 IO 的概念</h3><p>非阻塞 IO：见名知意，就是在第一阶段(网卡-内核态)数据未到达时不等待，然后直接返回。因此非阻塞 IO 需要不断的用户发起请求，询问内核数据好了没，好了没。</p><h3 id="3-2-非阻塞-IO-的过程"><a href="#3-2-非阻塞-IO-的过程" class="headerlink" title="3.2 非阻塞 IO 的过程"></a>3.2 非阻塞 IO 的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415112435.webp"></p><p>非阻塞 IO 是需要系统内核支持的，在创建了连接后，可以调用 setsockop 设置 noblocking。</p><h3 id="3-3-非阻塞-IO-的优点"><a href="#3-3-非阻塞-IO-的优点" class="headerlink" title="3.3 非阻塞 IO 的优点"></a>3.3 非阻塞 IO 的优点</h3><p>正如前面提到的，非阻塞 IO 解决了阻塞 IO<strong>每个连接一个线程处理的问题</strong>，所以其最大的优点就是 <strong>一个线程可以处理多个连接</strong>，这也是其非阻塞决定的。</p><h3 id="3-4-非阻塞-IO-的缺点"><a href="#3-4-非阻塞-IO-的缺点" class="headerlink" title="3.4 非阻塞 IO 的缺点"></a>3.4 非阻塞 IO 的缺点</h3><p>但这种模式，也有一个问题，就是需要用户多次发起系统调用。<strong>频繁的系统调用</strong>是比较消耗系统资源的。</p><p>因此，既然存在这样的问题，那么自然而然我们就需要解决该问题：<strong>保留非阻塞 IO 的优点的前提下，减少系统调用</strong>。</p><h2 id="4-IO-多路复用第一版"><a href="#4-IO-多路复用第一版" class="headerlink" title="4.IO 多路复用第一版"></a>4.IO 多路复用第一版</h2><p>为了解决非阻塞 IO 存在的频繁的系统调用这个问题，随着内核的发展，出现了 IO 多路复用模型。那么我们就需要搞懂几个问题：</p><ol><li>IO 多路复用到底复用什么？</li><li>IO 多路复用如何复用？</li></ol><p><strong>IO 多路复用：</strong> 很多人都说，IO 多路复用是用一个线程来管理多个网络连接，但本人不太认可，因为在非阻塞 IO 时，就已经可以实现一个线程处理多个网络连接了，这个是由于其非阻塞而决定的。</p><p><strong>在此处，个人观点，多路复用主要复用的是通过有限次的系统调用来实现管理多个网络连接。最简单来说，我目前有 10 个连接，我可以通过一次系统调用将这 10 个连接都丢给内核，让内核告诉我，哪些连接上面数据准备好了，然后我再去读取每个就绪的连接上的数据。因此，IO 多路复用，复用的是系统调用。通过有限次系统调用判断海量连接是否数据准备好了</strong>。</p><p><strong>无论下面的 select、poll、epoll，其都是这种思想实现的，不过在实现上，select/poll 可以看做是第一版，而 epoll 是第二版</strong>。</p><h3 id="4-1-IO-多路复用第一版的概念"><a href="#4-1-IO-多路复用第一版的概念" class="headerlink" title="4.1 IO 多路复用第一版的概念"></a>4.1 IO 多路复用第一版的概念</h3><p><strong>IO 多路复用第一版，这个概念是本人想出来的，主要是方便将 select/poll 和 epoll 进行区分</strong>。</p><p>所以此处 IO 多路复用第一版，主要特指 select 和 poll 这两个。</p><h4 id="select-的-api"><a href="#select-的-api" class="headerlink" title="select 的 api"></a>select 的 api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readfds:关心读的fd集合；writefds：关心写的fd集合；excepttfds：异常的fd集合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>select 函数监视的文件描述符分 3 类，分别是 writefds、readfds、和 exceptfds。调用后 select 函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 select 函数返回后，可以 通过遍历 fdset，来找到就绪的描述符。</p><p>select 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select 的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p><h4 id="poll-的-api"><a href="#poll-的-api" class="headerlink" title="poll 的 api"></a>poll 的 api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pollfd 结构包含了要监视的 event 和发生的 event，不再使用 select“参数-值”传递的方式。同时，pollfd 并没有最大数量限制（但是数量过大后性能也是会下降）。和 select 函数一样，poll 返回后，需要轮询 pollfd 来获取就绪的描述符。</p><p>从上面看，select 和 poll 都需要在返回后，通过遍历文件描述符来获取已经就绪的 socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p><p><strong>从本质来说：IO 多路复用中，select()/poll()/epoll_wait()这几个函数对应第一阶段；read()/recvfrom()对应第二阶段</strong>。</p><h3 id="4-2-IO-多路复用第一版的过程"><a href="#4-2-IO-多路复用第一版的过程" class="headerlink" title="4.2 IO 多路复用第一版的过程"></a>4.2 IO 多路复用第一版的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415112735.webp"></p><h3 id="4-3-IO-多路复用第一版的优点"><a href="#4-3-IO-多路复用第一版的优点" class="headerlink" title="4.3 IO 多路复用第一版的优点"></a>4.3 IO 多路复用第一版的优点</h3><p><strong>IO 多路复用，主要在于复用，通过 select()或者 poll()将多个 socket fds 批量通过系统调用传递给内核，由内核进行循环遍历判断哪些 fd 上数据就绪了，然后将就绪的 readyfds 返回给用户。再由用户进行挨个遍历就绪好的 fd，读取或者写入数据。</strong></p><p><strong>所以通过 IO 多路复用+非阻塞 IO，一方面降低了系统调用次数，另一方面可以用极少的线程来处理多个网络连接。</strong></p><h3 id="4-4-IO-多路复用第一版的缺点"><a href="#4-4-IO-多路复用第一版的缺点" class="headerlink" title="4.4 IO 多路复用第一版的缺点"></a>4.4 IO 多路复用第一版的缺点</h3><p>虽然第一版 IO 多路复用解决了之前提到的频繁的系统调用次数，但同时引入了新的问题：<strong>用户需要每次将海量的 socket fds 集合从用户态传递到内核态，让内核态去检测哪些网络连接数据就绪了</strong></p><p><strong>但这个地方会出现频繁的将海量 fd 集合从用户态传递到内核态，再从内核态拷贝到用户态。所以，这个地方开销也挺大。</strong></p><p>既然还有这个问题，那我们继续开始解决这个问题，因此就引出了第二版的 IO 多路复用。</p><p><strong>其实思路也挺简单，既然需要拷贝，那就想办法，不拷贝。既然不拷贝，那就在内核开辟一段区域咯</strong></p><h3 id="4-5-IO-多路复用第一版的区别"><a href="#4-5-IO-多路复用第一版的区别" class="headerlink" title="4.5 IO 多路复用第一版的区别"></a>4.5 IO 多路复用第一版的区别</h3><p><strong>select 和 poll 的区别</strong></p><ol><li>select 能处理的最大连接，默认是 1024 个，可以通过修改配置来改变，但终究是有限个；而 poll 理论上可以支持无限个</li><li>select 和 poll 在管理海量的连接时，会频繁的从用户态拷贝到内核态，比较消耗资源。</li></ol><h2 id="5-IO-多路复用第二版"><a href="#5-IO-多路复用第二版" class="headerlink" title="5. IO 多路复用第二版"></a>5. IO 多路复用第二版</h2><p>IO 多路复用第二版主要指 epoll，epoll 的出现也是随着内核版本迭代才诞生的，在网上到处看到，epoll 是内核 2.6 以后开始支持的</p><p><strong>epoll 的出现是为了解决前面提到的 IO 多路复用第一版的问题</strong>。</p><h3 id="5-1-IO-多路复用第二版的概念"><a href="#5-1-IO-多路复用第二版的概念" class="headerlink" title="5.1 IO 多路复用第二版的概念"></a>5.1 IO 多路复用第二版的概念</h3><h4 id="epoll-提供的-api"><a href="#epoll-提供的-api" class="headerlink" title="epoll 提供的 api"></a>epoll 提供的 api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建epollFd，底层是在内核态分配一段区域，底层数据结构红黑树+双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span>；<span class="comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//往红黑树中增加、删除、更新管理的socket fd</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//这个api是用来在第一阶段阻塞，等待就绪的fd。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+<span class="number">1</span>的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</span><br><span class="line">当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span>；</span></span><br><span class="line"><span class="function">函数是对指定描述符fd执行op操作。</span></span><br><span class="line"><span class="function">- epfd：是<span class="title">epoll_create</span><span class="params">()</span>的返回值。</span></span><br><span class="line"><span class="function">- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</span></span><br><span class="line"><span class="function">- fd：是需要监听的fd（文件描述符）</span></span><br><span class="line"><span class="function">- epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct epoll_event </span>&#123;</span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">等待epfd上的io事件，最多返回maxevents个事件。</span><br><span class="line">参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，<span class="number">0</span>会立即返回，<span class="number">-1</span>将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回<span class="number">0</span>表示已超时。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p>epoll 对文件描述符的操作有两种模式：LT（level trigger）和 ET（edge trigger）。LT 模式是默认模式，LT 模式与 ET 模式的区别如下：</p><ul><li>LT 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。</li><li>ET 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。</li></ul><ol><li><p>LT 模式</p><p>LT(level triggered)是缺省的工作方式，并且同时支持 block 和 no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。</p></li><li><p>ET 模式</p><p>ET(edge-triggered)是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个 EWOULDBLOCK 错误）。但是请注意，如果一直不对这个 fd 作 IO 操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p><p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p></li></ol><h3 id="5-2-IO-多路复用第二版的过程"><a href="#5-2-IO-多路复用第二版的过程" class="headerlink" title="5.2 IO 多路复用第二版的过程"></a>5.2 IO 多路复用第二版的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415113121.webp"></p><p>当 epoll_wait()调用后会阻塞，然后完了当返回时，会返回了哪些 fd 的数据就绪了，用户只需要遍历就绪的 fd 进行读写即可。</p><h3 id="5-3-IO-多路复用第二版的优点"><a href="#5-3-IO-多路复用第二版的优点" class="headerlink" title="5.3 IO 多路复用第二版的优点"></a>5.3 IO 多路复用第二版的优点</h3><p><strong>IO 多路复用第二版 epoll 的优点在于：</strong></p><p>一开始就在内核态分配了一段空间，来存放管理的 fd,所以在每次连接建立后，交给 epoll 管理时，需要将其添加到原先分配的空间中，后面再管理时就不需要频繁的从用户态拷贝管理的 fd 集合。通通过这种方式大大的提升了性能。</p><p>所以现在的 IO 多路复用主要指 epoll。</p><h3 id="5-4-IO-多路复用第二版的缺点"><a href="#5-4-IO-多路复用第二版的缺点" class="headerlink" title="5.4 IO 多路复用第二版的缺点"></a>5.4 IO 多路复用第二版的缺点</h3><p><strong>个人猜想：</strong> 如何降低占用的空间。</p><h2 id="6-异步-IO"><a href="#6-异步-IO" class="headerlink" title="6.异步 IO"></a>6.异步 IO</h2><h3 id="6-1-异步-IO-的过程"><a href="#6-1-异步-IO-的过程" class="headerlink" title="6.1 异步 IO 的过程"></a>6.1 异步 IO 的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415113223.webp"></p><p>前面介绍的所有网络 IO 都是同步 IO，因为当数据在内核态<strong>就绪</strong>时，在内核态拷贝用用户态的过程中，仍然会有短暂时间的阻塞等待。而异步 IO 指：<strong>内核态拷贝数据到用户态这种方式也是交给系统线程来实现，不由用户线程完成</strong>，目前只有 windows 系统的 IOCP 是属于异步 IO。</p><p><strong>区分同步异步IO的准则就是判断是就绪还是完成，就绪就是同步，完成就是异步</strong></p><h2 id="7-网络-IO-各种模型"><a href="#7-网络-IO-各种模型" class="headerlink" title="7.网络 IO 各种模型"></a>7.网络 IO 各种模型</h2><h3 id="7-1-reactor-模型"><a href="#7-1-reactor-模型" class="headerlink" title="7.1 reactor 模型"></a>7.1 reactor 模型</h3><p>目前 reactor 模型有以下几种实现方案：</p><p><strong>1. 单 reactor 单线程模型</strong><br><strong>2. 单 reactor 多线程模型</strong><br><strong>3. multi-reactor 多线程模型</strong><br><strong>4. multi-reactor 多进程模型</strong></p><h4 id="单-reactor-单线程模型"><a href="#单-reactor-单线程模型" class="headerlink" title="单 reactor 单线程模型"></a>单 reactor 单线程模型</h4><p>此种模型，通常是只有一个 epoll 对象，所有的<strong>接收客户端连接</strong>、<strong>客户端读取</strong>、<strong>客户端写入</strong>操作都包含在一个线程内。该种模型也有一些中间件在用，比如 redis。</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415113326.webp"></p><p>但在目前的单线程 Reactor 模式中，不仅 I/O 操作在该 Reactor 线程上，连非 I/O 的业务操作也在该线程上进行处理了，这可能会大大延迟 I/O 请求的响应。所以我们应该将非 I/O 的业务逻辑操作从 Reactor 线程上卸载，以此来加速 Reactor 线程对 I/O 请求的响应。</p><h4 id="单-reactor-多线程模型"><a href="#单-reactor-多线程模型" class="headerlink" title="单 reactor 多线程模型"></a>单 reactor 多线程模型</h4><p>该模型主要是通过将，前面的模型进行改造，将读写的业务逻辑交给具体的线程池来实现，这样可以显示 reactor 线程对 IO 的响应，以此提升系统性能。</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415113406.webp"></p><p>在工作者线程池模式中，虽然非 I/O 操作交给了线程池来处理，但是所有的 I/O 操作依然由 Reactor 单线程执行，在高负载、高并发或大数据量的应用场景，依然较容易成为瓶颈。所以，对于 Reactor 的优化，又产生出下面的多线程模式。</p><h4 id="multi-reactor-多线程模型"><a href="#multi-reactor-多线程模型" class="headerlink" title="multi-reactor 多线程模型"></a>multi-reactor 多线程模型</h4><p>在这种模型中，主要分为两个部分：mainReactor、subReactors。mainReactor 主要负责接收客户端的连接，然后将建立的客户端连接通过负载均衡的方式分发给 subReactors，subReactors 来负责具体的每个连接的读写。对于非 IO 的操作，依然交给工作线程池去做，对逻辑进行解耦。</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415113459.webp"></p><p>mainReactor 对应 Netty 中配置的 BossGroup 线程组，主要负责接受客户端连接的建立。一般只暴露一个服务端口，BossGroup 线程组一般一个线程工作即可 subReactor 对应 Netty 中配置的 WorkerGroup 线程组，BossGroup 线程组接受并建立完客户端的连接后，将网络 socket 转交给 WorkerGroup 线程组，然后在 WorkerGroup 线程组内选择一个线程，进行 I/O 的处理。WorkerGroup 线程组主要处理 I/O，一般设置 2*CPU 核数个线程。</p><h3 id="7-2-proactor-模型"><a href="#7-2-proactor-模型" class="headerlink" title="7.2 proactor 模型"></a>7.2 proactor 模型</h3><p>proactor 主要是通过对异步 IO 的封装的一种模型，它需要底层操作系统的支持，目前只有 windows 的 IOCP 支持的比较好。详细的介绍可以参考<a href="https://zhuanlan.zhihu.com/p/95662364">高性能IO模型分析-Reactor模式和Proactor模式（二）</a>。</p><h3 id="7-3-主流的中间件所采用的网络模型"><a href="#7-3-主流的中间件所采用的网络模型" class="headerlink" title="7.3 主流的中间件所采用的网络模型"></a>7.3 主流的中间件所采用的网络模型</h3><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415113546.webp"></p><h3 id="7-4-主流网络框架"><a href="#7-4-主流网络框架" class="headerlink" title="7.4 主流网络框架"></a>7.4 主流网络框架</h3><ul><li>netty</li><li>gnet</li><li>libevent</li><li>evio(golang)</li><li>ACE(c++)</li><li>boost::asio(c++)</li><li>muduo （linux only)</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://juejin.im/post/5bf7b89e518825369c564059">IO 模式和 IO 多路复用</a></li><li><a href="https://segmentfault.com/a/1190000003063859">Linux IO 模式及 select、poll、epoll 详解</a></li><li><a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06.html">Chapter 6. I/O Multiplexing: The select and poll Functions</a></li><li><a href="https://zhuanlan.zhihu.com/p/95662364">高性能 IO 模型分析-Reactor 模式和 Proactor 模式（二）</a></li></ol>]]></content>
    
    
    <summary type="html">多路复用——网络 IO 演变发展过程和模型介绍</summary>
    
    
    
    <category term="多路复用" scheme="http://example.com/categories/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
    
    <category term="I/O" scheme="http://example.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>shell</title>
    <link href="http://example.com/2021/03/15/shell/"/>
    <id>http://example.com/2021/03/15/shell/</id>
    <published>2021-03-15T07:45:40.000Z</published>
    <updated>2023-12-31T18:44:13.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nc-01统计文件的行数"><a href="#nc-01统计文件的行数" class="headerlink" title="nc_01统计文件的行数"></a>nc_01统计文件的行数</h2><p>写一个 bash脚本以输出一个文本文件 nowcoder.txt中的行数<br>示例:<br>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 100;</span><br><span class="line">    cout &lt;&lt; &quot;a + b:&quot; &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你的脚本应当输出：<br>9</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat nowcoder.txt | wc -l</span><br><span class="line"></span><br><span class="line">wc -l nowcoder.txt | awk &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line"></span><br><span class="line">awk &#x27;&#123;print NR&#125;&#x27; nowcoder.txt | tail -n1</span><br><span class="line"></span><br><span class="line">awk &#x27;END&#123;print NR&#125;&#x27; nowcoder.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">sed 统计行</span></span><br><span class="line">sed -n &#x27;$=&#x27; nowcoder.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">使用 grep 搜索 <span class="string">&quot;&quot;</span>，然后利用 grep 自带的功能统计行</span></span><br><span class="line">grep -c &quot;&quot; nowcoder.txt</span><br><span class="line"></span><br><span class="line">grep -n &quot;&quot; nowcoder.txt  | awk -F &quot;:&quot; &#x27;&#123;print $1 &#125;&#x27; | tail -n 1</span><br></pre></td></tr></table></figure><h2 id="nc-02打印文件的最后5行"><a href="#nc-02打印文件的最后5行" class="headerlink" title="nc_02打印文件的最后5行"></a>nc_02打印文件的最后5行</h2><p>经常查看日志的时候，会从文件的末尾往前查看，于是请你写一个 bash脚本以输出一个文本文件 nowcoder.txt中的最后5行<br>示例:<br>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 100;</span><br><span class="line">cout &lt;&lt; &quot;a + b:&quot; &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你的脚本应当输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 100;</span><br><span class="line">cout &lt;&lt; &quot;a + b:&quot; &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -n5 nowcoder.txt</span><br><span class="line"></span><br><span class="line">awk &#x27;NR&gt;=4&#123;print $0&#125;&#x27; nowcoder.txt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NR ||　NF</span><br><span class="line">NR代表的是这个文本文件的行数（记录数）</span><br><span class="line">NF代表的是一个文本文件中一行（一条记录）中的字段个数/列数</span><br><span class="line">September 2003               # NR=1;NF=2</span><br><span class="line">Su Mo Tu We Th Fr Sa         # NR=2;NF=7</span><br><span class="line">    1  2  3  4  5  6         # NR=3;NF=6</span><br><span class="line">07 08 09 10 11 12 13         # NR=4;NF=7</span><br><span class="line">14 15 16 17 18 19 20         # NR=5;NF=7</span><br><span class="line">21 22 23 24 25 26 27         # NR=6;NF=7</span><br><span class="line">28 29 30                     # NR=7;NF=3</span><br></pre></td></tr></table></figure><h2 id="nc-03输出7的倍数"><a href="#nc-03输出7的倍数" class="headerlink" title="nc_03输出7的倍数"></a>nc_03输出7的倍数</h2><p>写一个 bash脚本以输出数字 0 到 500 中 7 的倍数(0 7 14 21…)的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for num in &#123;0..500..7&#125;; do</span><br><span class="line">  echo &quot;$&#123;num&#125;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># seq 用于生成从一个数到另一个数之间的所有整数。</span><br><span class="line"># 用法：seq [选项]... 尾数</span><br><span class="line"># 或：seq [选项]... 首数 尾数</span><br><span class="line"># 或：seq [选项]... 首数 增量 尾数</span><br><span class="line">seq 0 7 500</span><br></pre></td></tr></table></figure><h2 id="nc-04输出第五行内容"><a href="#nc-04输出第五行内容" class="headerlink" title="nc_04输出第五行内容"></a>nc_04输出第五行内容</h2><p>写一个 bash脚本以输出一个文本文件 nowcoder.txt 中第5行的内容</p><p>示例:<br>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">welcome</span><br><span class="line">to</span><br><span class="line">nowcoder</span><br><span class="line">this</span><br><span class="line">is</span><br><span class="line">shell</span><br><span class="line">code</span><br></pre></td></tr></table></figure><p>你的脚本应当输出：<br>is</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> p 打印 通常 p 会与参数 sed -n 一起运行～</span></span><br><span class="line">sed -n &#x27;5p&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">head n 5 nowcoder.txt | tail -n 1</span><br><span class="line"></span><br><span class="line">awk &#x27;NR==5&#123;print $0&#125;&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">awk &#x27;&#123;if(NR==5)&#123;print $0&#125;&#125;&#x27; nowcoder.txt</span><br></pre></td></tr></table></figure><h2 id="nc-05打印空行的行号"><a href="#nc-05打印空行的行号" class="headerlink" title="nc_05打印空行的行号"></a>nc_05打印空行的行号</h2><p>写一个 bash脚本以输出一个文本文件 nowcoder.txt中空行的行号,可能连续,从1开始</p><p>示例:<br>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">d</span><br><span class="line"></span><br><span class="line">e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f</span><br></pre></td></tr></table></figure><p>你的脚本应当输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">^：开始</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">：结尾</span></span><br><span class="line"></span><br><span class="line">^$：表示空行</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">awk &#x27;/^$/ &#123;print NR&#125;&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">awk &#x27;&#123;if($0 == &quot;&quot;) &#123;print NR&#125;&#125;&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">awk &#x27;&#123;if (NF==0) print NR&#125;&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">sed -n &#x27;/^$/=&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">grep -n &#x27;^$&#x27; nowcoder.txt | awk -F: &#x27;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="nc-06去掉空行"><a href="#nc-06去掉空行" class="headerlink" title="nc_06去掉空行"></a>nc_06去掉空行</h2><p>写一个 bash脚本以去掉一个文本文件 nowcoder.txt中的空行<br>示例:<br>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line"></span><br><span class="line">567</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ccc</span><br></pre></td></tr></table></figure><p>你的脚本应当输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">567</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -v 显示不包含匹配文本的所有行</span></span><br><span class="line">grep -v &#x27;^$&#x27; nowcoder.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> -e 指定字符串做为查找文件内容的样式</span></span><br><span class="line">grep -e &#x27;\S&#x27;</span><br><span class="line"></span><br><span class="line">awk &#x27;&#123;if($0!=&quot;&quot;) &#123;print $0 &#125;&#125;&#x27; nowcoder.txt</span><br><span class="line">awk &#x27;!/^$/ &#123;print $NF&#125;&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat 输出文本内容，然后通过管道符交由 awk 做非空校验然后输出</span></span><br><span class="line">cat nowcoder.txt | awk NF</span><br><span class="line"></span><br><span class="line">sed &#x27;/^$/d&#x27; nowcoder.txt</span><br></pre></td></tr></table></figure><h2 id="nc-07打印字母数小于8的单词"><a href="#nc-07打印字母数小于8的单词" class="headerlink" title="nc_07打印字母数小于8的单词"></a>nc_07打印字母数小于8的单词</h2><p>写一个 bash脚本以统计一个文本文件 nowcoder.txt中字母数小于8的单词。</p><p>示例:假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">how they are implemented and applied in computer </span><br></pre></td></tr></table></figure><p>你的脚本应当输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">how</span><br><span class="line">they</span><br><span class="line">are</span><br><span class="line">and</span><br><span class="line">applied</span><br><span class="line">in</span><br></pre></td></tr></table></figure><p>说明:不要担心你输出的空格以及换行的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat nowcoder.txt | awk &#x27;&#123;</span><br><span class="line">for (i=1;i&lt;=NF;i++)&#123;</span><br><span class="line">        if (length($i) &lt; 8)</span><br><span class="line">                print $i</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="nc-08统计所有进程占用内存大小的和"><a href="#nc-08统计所有进程占用内存大小的和" class="headerlink" title="nc_08统计所有进程占用内存大小的和"></a>nc_08统计所有进程占用内存大小的和</h2><p>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root         2  0.0  0.0      0     0 ?        S    9月25   0:00 [kthreadd]</span><br><span class="line">root         4  0.0  0.0      0     0 ?        I&lt;   9月25   0:00 [kworker/0:0H]</span><br><span class="line">web       1638  1.8  1.8 6311352 612400 ?      Sl   10月16  21:52 test</span><br><span class="line">web       1639  2.0  1.8 6311352 612401 ?      Sl   10月16  21:52 test</span><br><span class="line">tangmiao-pc       5336   0.0  1.4  9100240 238544   ??  S     3:09下午   0:31.70 /Applications</span><br></pre></td></tr></table></figure><p>上内容是通过<code>ps aux | grep -v &#39;RSS TTY&#39; </code>命令输出到<code>nowcoder.txt</code>文件下面的<br>请你写一个脚本计算一下所有进程占用内存大小的和:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;a+=$6&#125;END&#123;print a&#125;&#x27;</span><br><span class="line">对第一列数字求和： awk &#x27;&#123;a+=$1&#125;END&#123;print a&#125;&#x27;</span><br><span class="line">对第二列数字求和： awk &#x27;&#123;a+=$2&#125;END&#123;print a&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="nc-09统计每个单词出现的次数"><a href="#nc-09统计每个单词出现的次数" class="headerlink" title="nc_09统计每个单词出现的次数"></a>nc_09统计每个单词出现的次数</h2><p>写一个 bash脚本以统计一个文本文件 nowcoder.txt 中每个单词出现的个数。</p><p>为了简单起见，你可以假设：<br>nowcoder.txt只包括小写字母和空格。<br>每个单词只由小写字母组成。<br>单词间由一个或多个空格字符分隔。</p><p>示例:<br>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">welcome nowcoder</span><br><span class="line">welcome to nowcoder</span><br><span class="line">nowcoder</span><br></pre></td></tr></table></figure><p>你的脚本应当输出（以词频升序排列）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">to 1 </span><br><span class="line">welcome 2 </span><br><span class="line">nowcoder 3 </span><br></pre></td></tr></table></figure><p>说明:<br>不要担心个数相同的单词的排序问题，每个单词出现的个数都是唯一的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat nowcoder.txt | xargs -n1 | sort | uniq -c | sort -n | awk &#x27;&#123;print $2,$1&#125;&#x27;</span><br></pre></td></tr></table></figure><p>对于nowcoder.txt文件进行词频统计，首先要做的事情就是把nowcoder.txt文件当中的每一个单词分割出来，分割出每一个单词可以使用以下两种方式：</p><p><strong>使用awk命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;for(i=1;i&lt;=NF;i++)&#123;print $i&#125;&#125;&#x27; nowcoder.txt </span><br><span class="line">其中NF表示当前记录的字段数（即列数）</span><br><span class="line"><span class="meta">$</span><span class="bash">i 文件中每行以间隔符号分割的不同字段</span></span><br><span class="line">如果对awk命令不熟悉，可以参考之前分享的一篇文章学习：</span><br><span class="line">号称三剑客之首的awk，开始秀！</span><br></pre></td></tr></table></figure><p><strong>使用xargs命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat nowcoder.txt | xargs -n1</span><br><span class="line">xargs命令是用于给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。</span><br><span class="line">-n1，指定 输出时每行输出的 1列</span><br><span class="line">welcome</span><br><span class="line">nowcoder</span><br><span class="line">welcome</span><br><span class="line">to</span><br><span class="line">nowcoder</span><br><span class="line">nowcoder</span><br><span class="line"></span><br><span class="line">-n2，指定 输出时每行输出的 2列</span><br><span class="line">welcome nowcoder</span><br><span class="line">welcome to</span><br><span class="line">nowcoder nowcoder</span><br></pre></td></tr></table></figure><p>可以在xargs的基础之上使用一些shell小工具来得到每个单词出现的次数。sort 工具及 uniq 工具，这里仅介绍解决问题使用的参数，关于小工具（grep、cut、sort、uniq、tee、diff、past、tr）可以参考文章：<a href="https://mp.weixin.qq.com/s/7pfE3S-uDSLOG1AZSj3D1A">Shell编程之文本处理工具与bash的特性</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sort工具用于排序，它将文件的每一行作为一个单位，从首字母向后按照ASCII码值进行比较，默认将他们升序输出。</span><br><span class="line">nowcoder</span><br><span class="line">nowcoder</span><br><span class="line">nowcoder</span><br><span class="line">to</span><br><span class="line">welcome</span><br><span class="line">welcome</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uniq用去取出连续的重复行</span><br><span class="line"></span><br><span class="line">-c ：统计重复行的次数</span><br><span class="line">     3 nowcoder</span><br><span class="line">     1 to</span><br><span class="line">     2 welcome</span><br><span class="line"></span><br><span class="line">-r : 降序排列</span><br><span class="line"></span><br><span class="line">-n : 以数字排序，默认是按照字符排序的。</span><br><span class="line">      1 to</span><br><span class="line">      2 welcome</span><br><span class="line">      3 nowcoder</span><br><span class="line"></span><br><span class="line">最后我们仅需要对上面的结果进行排序啦，很简单的使用sort就可以啦！</span><br></pre></td></tr></table></figure><h2 id="nc-10第二列是否有重复"><a href="#nc-10第二列是否有重复" class="headerlink" title="nc_10第二列是否有重复"></a>nc_10第二列是否有重复</h2><p>给定一个 <code>nowcoder.txt</code>文件，其中有3列信息，如下实例，编写一个<code>shell</code>脚本来检查文件第二列是否有重复，且有几个重复，并提取出重复的行的第二列信息：<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">20201001 python 99</span><br><span class="line">20201002 go 80</span><br><span class="line">20201002 c++ 88</span><br><span class="line">20201003 php 77</span><br><span class="line">20201001 go 88</span><br><span class="line">20201005 shell 89</span><br><span class="line">20201006 java 70</span><br><span class="line">20201008 c 100</span><br><span class="line">20201007 java 88</span><br><span class="line">20201006 go 97</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 java</span><br><span class="line">3 go</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $2&#125;&#x27; nowcoder.txt | sort | uniq -cd | sort -n</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $2&#125;&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">python</span><br><span class="line">go</span><br><span class="line">c++</span><br><span class="line">php</span><br><span class="line">go</span><br><span class="line">shell</span><br><span class="line">java</span><br><span class="line">c</span><br><span class="line">java</span><br><span class="line">go</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $2&#125;&#x27; nowcoder.txt | sort</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line">c++</span><br><span class="line">go</span><br><span class="line">go</span><br><span class="line">go</span><br><span class="line">java</span><br><span class="line">java</span><br><span class="line">php</span><br><span class="line">python</span><br><span class="line">shell</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $2&#125;&#x27; nowcoder.txt | sort | uniq -cd</span><br><span class="line"></span><br><span class="line">3 go</span><br><span class="line">2 java</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq [-c/d/D/u/i] [-f Fields] [-s N] [-w N] [InFile] [OutFile]</span><br></pre></td></tr></table></figure><blockquote><ul><li>-c: 在每列旁边显示该行重复出现的次数。</li><li>-d: 仅显示重复出现的行列，显示一行。</li><li>-D: 显示所有重复出现的行列，有几行显示几行。</li><li>-u: 仅显示出一次的行列。</li><li>-i: 忽略大小写字符的不同。</li><li>-f Fields: 忽略比较指定的列数。</li><li>-s N: 忽略比较前面的N个字符。</li><li>-w N: 对每行第N个字符以后的内容不作比较。</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [-b/d/f/g/i/M/n/r] [InFile]</span><br></pre></td></tr></table></figure><blockquote><ul><li>-b: ignore-leading-blanks，忽略前面空格符部分</li><li>-d: data-order，仅考虑空格和字母数字字符</li><li>-f: ignore-case，忽略大小写</li><li>-g: general-numeric-sort，根据一般数值进行排序</li><li>-i: ignore-nonprinting，忽略不可打印的字符，比如换行符、回车符</li><li>-M: month-sort，以月份进行排序</li><li>-n: numeric-sort，根据字符串数值进行排序-r: reverse，反向输出排序结果</li></ul></blockquote><h2 id="nc-11转置文件中的内容"><a href="#nc-11转置文件中的内容" class="headerlink" title="nc_11转置文件中的内容"></a>nc_11转置文件中的内容</h2><p>写一个 bash脚本来转置文本文件<code>nowcoder.txt</code>中的文件内容。</p><p>为了简单起见，你可以假设：<br>你可以假设每行列数相同，并且每个字段由空格分隔</p><p>示例:<br>假设 <code>nowcoder.txt </code>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">job salary</span><br><span class="line">c++ 13</span><br><span class="line">java 14</span><br><span class="line">php 12</span><br></pre></td></tr></table></figure><p>你的脚本应当输出（以词频升序排列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job c++ java php</span><br><span class="line">salary 13 14 12</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123; </span><br><span class="line">    # NF表示列数,NR表示当前行数</span><br><span class="line">    for (i=1; i&lt;=NF; i++)&#123;</span><br><span class="line">        if(NR==1)&#123; </span><br><span class="line">            # 处理第一行时,将第i列的值($i)存入arr[i],i为数组的下标,数组不用定义可以直接使用</span><br><span class="line">            arr[i]=$i;   </span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            # 不是第一行时，将该行对应i列的值拼接到arr[i]</span><br><span class="line">            arr[i]=arr[i] &quot; &quot; $i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">END&#123;</span><br><span class="line">    # 每行处理完以后,输出数组</span><br><span class="line">    for (i=1; i&lt;=NF; i++)&#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27; nowcoder.txt</span><br></pre></td></tr></table></figure><h2 id="shell基本语法"><a href="#shell基本语法" class="headerlink" title="shell基本语法"></a>shell基本语法</h2><p><strong>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具</strong></p><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] <span class="string">&#x27;script&#x27;</span> var=value file(s)</span><br><span class="line">或</span><br><span class="line">awk [选项参数] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure><p><strong>选项参数</strong></p><ul><li>-F fs or –field-separator fs<br>指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:</li><li>-v var=value or –asign var=value<br>赋值一个用户定义变量。</li><li>-f scripfile or –file scriptfile<br>从脚本文件中读取awk命令。</li><li>-mf nnn and -mr nnn<br>对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li><li>-W compact or –compat, -W traditional or –traditional<br>在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</li><li>-W copyleft or –copyleft, -W copyright or –copyright<br>打印简短的版权信息。</li><li>-W help or –help, -W usage or –usage<br>打印全部awk选项和每个选项的简短说明。</li><li>-W lint or –lint<br>打印不能向传统unix平台移植的结构的警告。</li><li>-W lint-old or –lint-old<br>打印关于不能向传统unix平台移植的结构的警告。</li><li>-W posix<br>打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符<strong>和</strong>=不能代替^和^=；fflush无效。</li><li>-W re-interval or –re-inerval<br>允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。</li><li>-W source program-text or –source program-text<br>使用program-text作为源代码，可与-f命令混用。</li><li>-W version or –version<br>打印bug报告信息的版本。</li></ul><p><strong>sed</strong></p><p><strong>sed 命令是利用脚本来处理文本文件。</strong></p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li>-e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。</li><li>-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</li><li>-h或–help 显示帮助。</li><li>-n或–quiet或–silent 仅显示script处理后的结果。</li><li>-V或–version 显示版本信息。</li></ul><p><strong>动作说明</strong>：</p><ul><li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)</li><li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li><li>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li></ul><p>** wc**</p><p><strong>wc命令的功能为统计指定文件中的字节数、字数、行数, 并将统计结果显示输出。</strong></p><p><strong>参数说明</strong></p><ul><li>-c 统计字节数 chars byres</li><li>-l 统计行数      lines</li><li>-w 统计词数    words</li></ul></script></li></ul>]]></content>
    
    
    <summary type="html">整理牛客和力扣上的shell编程题</summary>
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="Shell" scheme="http://example.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>程序、进程和线程</title>
    <link href="http://example.com/2021/03/03/%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2021/03/03/%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-03-03T14:12:17.000Z</published>
    <updated>2023-12-31T18:44:13.919Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="sleep-和usleep"><a href="#sleep-和usleep" class="headerlink" title="sleep()和usleep()"></a>sleep()和usleep()</h2><p>函数名:<strong>sleep()</strong></p><p>头文件:<code>#include &lt;unistd.h&gt; </code>  // 在<code>gcc</code>编译器中，使用的头文件因<code>gcc</code>版本的不同而不同</p><p>功 能: 执行挂起指定的秒数<br>语 法: <code>unsigned sleep(unsigned seconds);</code></p><p>函数名:<strong>usleep()</strong><br>头文件:<code> #include &lt;unistd.h&gt;</code><br>功  能:<code> usleep</code>功能把进程挂起一段时间， 单位是微秒（百万分之一秒）<br>语  法:<code> void usleep(int micro_seconds);</code><br>内容说明：本函数可暂时使程序停止执行。参数 <code>micro_seconds </code>为要暂停的微秒数(us)。</p><h2 id="线程间的互斥"><a href="#线程间的互斥" class="headerlink" title="线程间的互斥"></a>线程间的互斥</h2><p>下面是一个线程互斥的例子。代码用线程互斥的方法构建了以哦个生产者和消费者的例子。代码中建立了两个线程，函数<code>producter_f()</code>用于生成，函数<code>consumer_f()</code>用于消费。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* mutex.c</span></span><br><span class="line"><span class="comment">* 线程实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producter_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span>;<span class="comment">/*生产者*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span>;<span class="comment">/*消费者*/</span></span><br><span class="line"><span class="keyword">int</span> buffer_has_item=<span class="number">0</span>;<span class="comment">/*缓冲区计数值*/</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;<span class="comment">/*互斥区*/</span></span><br><span class="line"><span class="keyword">int</span> running =<span class="number">1</span> ;<span class="comment">/*线程运行控制*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">consumer_t</span>;<span class="comment">/*消费者线程参数*/</span></span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">producter_t</span>;<span class="comment">/*生产者线程参数*/</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_init (&amp;mutex,<span class="literal">NULL</span>);<span class="comment">/*初始化互斥*/</span></span><br><span class="line"></span><br><span class="line">pthread_create(&amp;<span class="keyword">producter_t</span>, <span class="literal">NULL</span>,(<span class="keyword">void</span>*)producter_f, <span class="literal">NULL</span> );            <span class="comment">/*建立生产者线程*/</span></span><br><span class="line">pthread_create(&amp;<span class="keyword">consumer_t</span>, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)consumer_f, <span class="literal">NULL</span>);            <span class="comment">/*建立消费者线程*/</span></span><br><span class="line">usleep(<span class="number">1</span>);<span class="comment">/*等待，线程创建完毕*/</span></span><br><span class="line">running =<span class="number">0</span>;<span class="comment">/*设置线程退出值*/</span></span><br><span class="line">pthread_join(<span class="keyword">consumer_t</span>,<span class="literal">NULL</span>);<span class="comment">/*等待消费者线程退出*/</span></span><br><span class="line">pthread_join(<span class="keyword">producter_t</span>,<span class="literal">NULL</span>);    <span class="comment">/*等待生产者线程退出*/</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);<span class="comment">/*销毁互斥*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producter_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">/*生产者线程程序*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(running)<span class="comment">/*没有设置退出值*/</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock (&amp;mutex);<span class="comment">/*进入互斥区*/</span></span><br><span class="line">buffer_has_item++;<span class="comment">/*增加计数值*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产，总数量:%d\n&quot;</span>,buffer_has_item); <span class="comment">/*打印信息*/</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);<span class="comment">/*离开互斥区*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer_f</span><span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">/*消费者线程程序*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(running)<span class="comment">/*没有设置退出值*/</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);<span class="comment">/*进入互斥区*/</span></span><br><span class="line">buffer_has_item--;<span class="comment">/*减小计数值*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;消费，总数量:%d\n&quot;</span>,buffer_has_item);<span class="comment">/*打印信息*/</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);<span class="comment">/*离开互斥区*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生产，总数量:1</span><br><span class="line">消费，总数量:0</span><br></pre></td></tr></table></figure><p>上例中声明了一个线程互斥变量<code>mutex</code>,在线程函数<code>consumer_f()</code>和<code>producter_f()</code>中，用线程互斥锁函数<code>pthread_mutex_lock()</code>和<code>pthread_mutex_ublock()</code>来保护对公共变量<code>buffer_has_item</code>的访问。</p><h2 id="线程中使用信号量"><a href="#线程中使用信号量" class="headerlink" title="线程中使用信号量"></a>线程中使用信号量</h2><p>下面是一个使用信号量的例子。在<code>mutex</code>的例子中，使用了一个全局变量来计数，在这个例子中，使用信号量来做同样的工作，其中一个线程增加信号量来模仿生产者，另一个线程获得信号量来模仿消费者。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* sem.c</span></span><br><span class="line"><span class="comment">* 线程实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producter_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span>;<span class="comment">/*生产者线程函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span>;<span class="comment">/*消费者线程函数*/</span></span><br><span class="line"><span class="keyword">sem_t</span> sem;</span><br><span class="line"><span class="keyword">int</span> running =<span class="number">1</span> ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">consumer_t</span>;<span class="comment">/*消费者线程参数*/</span></span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">producter_t</span>;<span class="comment">/*生产者线程参数*/</span></span><br><span class="line"></span><br><span class="line">sem_init (&amp;sem, <span class="number">0</span>, <span class="number">16</span>);<span class="comment">/*信号量初始化*/</span></span><br><span class="line"></span><br><span class="line">pthread_create(&amp;<span class="keyword">producter_t</span>, <span class="literal">NULL</span>,(<span class="keyword">void</span>*)producter_f, <span class="literal">NULL</span> );             <span class="comment">/*建立生产者线程*/</span></span><br><span class="line">pthread_create(&amp;<span class="keyword">consumer_t</span>, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)consumer_f, <span class="literal">NULL</span>);             <span class="comment">/*建立消费者线程*/</span></span><br><span class="line">sleep(<span class="number">1</span>);<span class="comment">/*等待*/</span></span><br><span class="line">running =<span class="number">0</span>;<span class="comment">/*设置线程退出*/</span></span><br><span class="line">pthread_join(<span class="keyword">consumer_t</span>,<span class="literal">NULL</span>);<span class="comment">/*等待消费者线程退出*/</span></span><br><span class="line">pthread_join(<span class="keyword">producter_t</span>,<span class="literal">NULL</span>);    <span class="comment">/*等待生产者线程退出*/</span></span><br><span class="line">sem_destroy(&amp;sem);<span class="comment">/*销毁信号量*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producter_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">/*生产者处理程序代码*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> semval=<span class="number">0</span>;<span class="comment">/*信号量的初始值为0*/</span></span><br><span class="line"><span class="keyword">while</span>(running)<span class="comment">/*运行状态为可运行*/</span></span><br><span class="line">&#123;</span><br><span class="line">usleep(<span class="number">1</span>);<span class="comment">/*等待*/</span></span><br><span class="line">sem_post (&amp;sem);<span class="comment">/*信号量增加*/</span></span><br><span class="line">sem_getvalue(&amp;sem,&amp;semval);<span class="comment">/*获得信号量的值*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产，总数量:%d\n&quot;</span>,semval);<span class="comment">/*打印信息*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer_f</span><span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">/*消费者处理程序代码*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> semval=<span class="number">0</span>;<span class="comment">/*信号量的初始值为0*/</span></span><br><span class="line"><span class="keyword">while</span>(running)<span class="comment">/*运行状态为可运行*/</span></span><br><span class="line">&#123;</span><br><span class="line">usleep(<span class="number">1</span>);<span class="comment">/*等待*/</span></span><br><span class="line">sem_wait(&amp;sem);<span class="comment">/*等待信号量*/</span></span><br><span class="line">sem_getvalue(&amp;sem,&amp;semval);<span class="comment">/*获得信号量的值*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;消费，总数量:%d\n&quot;</span>,semval);<span class="comment">/*打印信息*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">生产，总数量:56</span><br><span class="line">生产，总数量:57</span><br><span class="line">消费，总数量:56</span><br><span class="line">消费，总数量:55</span><br><span class="line">生产，总数量:56</span><br><span class="line">消费，总数量:55</span><br><span class="line">生产，总数量:56</span><br><span class="line">生产，总数量:57</span><br><span class="line">消费，总数量:56</span><br><span class="line">消费，总数量:55</span><br><span class="line">生产，总数量:56</span><br><span class="line">生产，总数量:57</span><br><span class="line">消费，总数量:56</span><br><span class="line">消费，总数量:55</span><br><span class="line">生产，总数量:56</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从执行结果可以看出，以上程序建立的各个线程间存在竞争关系。而数值并未按产生一个消耗一个的顺序显示出来，而是以交叉的方式进行，有的时候产生多个再消耗多个。造成这种现象的原因是信号量的产生和消耗是对<code>CPU</code>竞争的结果。</p>]]></content>
    
    
    <summary type="html">学习操作系统的核心概念——进程和线程</summary>
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="pthread" scheme="http://example.com/tags/pthread/"/>
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="http://example.com/2021/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2021-02-24T12:16:44.000Z</published>
    <updated>2023-12-31T18:44:13.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Socket-网络通信"><a href="#Socket-网络通信" class="headerlink" title="Socket 网络通信"></a>Socket 网络通信</h1><h2 id="实现点对点通信"><a href="#实现点对点通信" class="headerlink" title="实现点对点通信"></a>实现点对点通信</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tcp_server.c</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888    <span class="comment">/*侦听端口地址*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKLOG 2    <span class="comment">/*侦听队列长度*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR_EXIT(m) do&#123;perror(m);exit(EXIT_FAILURE);&#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sign)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recv a sign: %d&quot;</span>, sign);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ss,sc;    <span class="comment">/*ss为服务器的socket描述符，sc为客户端的socket描述符*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span>    <span class="comment">/*服务器地址结构*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span>    <span class="comment">/*客户端地址结构*/</span></span><br><span class="line"><span class="keyword">int</span> err;      <span class="comment">/*返回值*/</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;    <span class="comment">/*分叉的进行ID*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*建立一个流式套接字*/</span></span><br><span class="line">ss = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ss &lt; <span class="number">0</span>)&#123;    <span class="comment">/*出错*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置服务器地址*/</span></span><br><span class="line"><span class="built_in">bzero</span>(&amp;server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr));        <span class="comment">/*清零*/</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;server_addr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;                <span class="comment">/*协议族*/</span></span><br><span class="line">server_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">/*本地地址*/</span></span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(PORT);              <span class="comment">/*服务器端口*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*绑定地址结构到套接字描述符*/</span></span><br><span class="line">err = <span class="built_in">bind</span>(ss, (struct sockaddr*)&amp;server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr));</span><br><span class="line"><span class="keyword">if</span>(err &lt; <span class="number">0</span>)&#123;    <span class="comment">/*出错*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置侦听*/</span></span><br><span class="line">err = <span class="built_in">listen</span>(ss, BACKLOG);</span><br><span class="line"><span class="keyword">if</span>(err &lt; <span class="number">0</span>)&#123;    <span class="comment">/*出错*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主循环过程*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">socklen_t</span> addrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr);</span><br><span class="line"></span><br><span class="line">sc = <span class="built_in">accept</span>(ss, (struct sockaddr*)&amp;client_addr, &amp;addrlen); </span><br><span class="line"><span class="comment">/*接收客户端连接*/</span></span><br><span class="line"><span class="keyword">if</span>(sc &lt; <span class="number">0</span>)&#123;    <span class="comment">/*出错*/</span></span><br><span class="line"><span class="built_in">ERR_EXIT</span>(<span class="string">&quot;accept error&quot;</span>);    <span class="comment">/*结束本次循环*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*建立一个新的进程处理到来的连接*/</span></span><br><span class="line">pid = fork();    <span class="comment">/*分叉进程*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子进程只管发数据</span></span><br><span class="line"><span class="keyword">if</span>( pid == <span class="number">0</span> )&#123;    <span class="comment">/*子进程中*/</span></span><br><span class="line"><span class="built_in">signal</span>(SIGUSR1, handler);    <span class="comment">/*通知子进程关闭*/</span></span><br><span class="line"><span class="keyword">char</span> sendbuffer[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">fgets</span>(sendbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(sendbuffer),stdin)!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">write</span>(sc,sendbuffer,<span class="built_in">strlen</span>(sendbuffer));</span><br><span class="line"><span class="built_in">bzero</span>(sendbuffer,<span class="built_in"><span class="keyword">sizeof</span></span>(sendbuffer));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);    <span class="comment">/*在子进程中关闭服务器的侦听*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//父进程只管读数据</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">char</span> recvbuffer[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">bzero</span>(recvbuffer,<span class="built_in"><span class="keyword">sizeof</span></span>(recvbuffer));</span><br><span class="line"><span class="keyword">int</span> size = <span class="built_in">read</span>(sc, recvbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(recvbuffer));</span><br><span class="line"><span class="keyword">if</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">fputs</span>(recvbuffer, stdout);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(sc);</span><br><span class="line"><span class="built_in">close</span>(ss);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tcp_client.c</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888    <span class="comment">/*侦听端口地址*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR_EXIT(m) do&#123;perror(m);exit(EXIT_FAILURE);&#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sign)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recv a sign: %d&quot;</span>, sign);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s;       <span class="comment">/*s为socket描述符*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span>    <span class="comment">/*服务器地址结构*/</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);    <span class="comment">/*建立一个流式套接字 */</span></span><br><span class="line"><span class="keyword">if</span>(s &lt; <span class="number">0</span>)&#123;   <span class="comment">/*出错*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置服务器地址*/</span></span><br><span class="line"><span class="built_in">bzero</span>(&amp;server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr));        <span class="comment">/*清零*/</span></span><br><span class="line">server_addr.sin_family = AF_INET;                <span class="comment">/*协议族*/</span></span><br><span class="line">server_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">/*本地地址*/</span></span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(PORT);              <span class="comment">/*服务器端口*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将用户输入的字符串类型的IP地址转为整型*/</span></span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, argv[<span class="number">1</span>], &amp;server_addr.sin_addr);</span><br><span class="line"><span class="comment">/*连接服务器*/</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">connect</span>(s, (struct sockaddr*)&amp;server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr))&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">ERR_EXIT</span>(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == pid)&#123;</span><br><span class="line"><span class="built_in">ERR_EXIT</span>(<span class="string">&quot;fork errorr&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == pid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(recvBuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(recvBuf));</span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">read</span>(s, recvBuf, <span class="built_in"><span class="keyword">sizeof</span></span>(recvBuf));</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line"><span class="built_in">ERR_EXIT</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == ret)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;peer close\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fputs</span>(recvBuf, stdout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(s);</span><br><span class="line"><span class="built_in">kill</span>(<span class="built_in">getppid</span>(), SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">signal</span>(SIGUSR1, handler);</span><br><span class="line"><span class="keyword">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">fgets</span>(sendBuf, <span class="built_in"><span class="keyword">sizeof</span></span>(sendBuf), stdin) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">write</span>(s, sendBuf, <span class="built_in">strlen</span>(sendBuf));</span><br><span class="line"><span class="built_in">memset</span>(sendBuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sendBuf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2021/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/01.png" alt="01"></p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>问题：不能处理多个客户端连接服务器</p><p>改进：select多路复用</p><h1 id="bind-函数重难点解析"><a href="#bind-函数重难点解析" class="headerlink" title="bind 函数重难点解析"></a>bind 函数重难点解析</h1><h2 id="bind-函数如何选择绑定地址"><a href="#bind-函数如何选择绑定地址" class="headerlink" title="bind 函数如何选择绑定地址"></a>bind 函数如何选择绑定地址</h2><p>bind 函数的基本用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bindaddr</span>;</span></span><br><span class="line">bindaddr.sin_family = AF_INET;</span><br><span class="line">bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">bindaddr.sin_port = htons(<span class="number">3000</span>);</span><br><span class="line"><span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;bindaddr, <span class="keyword">sizeof</span>(bindaddr)) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind listen socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 bind 的地址我们使用了一个宏叫 <strong>INADDR_ANY</strong> ，关于这个宏的解释如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">If an application does <span class="keyword">not</span> care what local address is assigned, </span><br><span class="line">specify the constant value INADDR_ANY <span class="keyword">for</span> an IPv4 local address</span><br><span class="line"><span class="keyword">or</span> the constant value in6addr_any <span class="keyword">for</span> an IPv6 local address </span><br><span class="line">in the sa_data member of the name parameter. This allows the </span><br><span class="line">underlying service provider to use any appropriate network address,</span><br><span class="line"><span class="function">potentially simplifying application programming in the presence of </span></span><br><span class="line"><span class="function">multihomed <span class="title">hosts</span> <span class="params">(that is, hosts that have more than one network </span></span></span><br><span class="line"><span class="params"><span class="function">interface <span class="keyword">and</span> address)</span>.</span></span><br></pre></td></tr></table></figure><p>意译一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果应用程序不关心bind绑定的ip地址，可以使用INADDR_ANY(如果是IPv6，</span><br><span class="line">则对应in6addr_any)，这样底层的（协议栈）服务会自动选择一个合适的ip地址，</span><br><span class="line">这样使在一个有多个网卡机器上选择ip地址问题变得简单。</span><br></pre></td></tr></table></figure><p>也就是说 <strong>INADDR_ANY</strong> 相当于地址 <strong>0.0.0.0</strong>。可能读者还是不太明白我想表达什么。这里我举个例子，假设我们在一台机器上开发一个服务器程序，使用 bind 函数时，我们有多个ip 地址可以选择。首先，这台机器对外访问的ip地址是<strong>120.55.94.78</strong>，这台机器在当前局域网的地址是<strong>192.168.1.104</strong>；同时这台机器有本地回环地址<strong>127.0.0.1</strong>。</p><p>如果你指向本机上可以访问，那么你 bind 函数中的地址就可以使用<strong>127.0.0.1</strong>; 如果你的服务只想被局域网内部机器访问，bind 函数的地址可以使用<strong>192.168.1.104</strong>；如果 希望这个服务可以被公网访问，你就可以使用地址<strong>0.0.0.0</strong>或 <strong>INADDR_ANY</strong>。</p><h2 id="bind-函数端口号问题"><a href="#bind-函数端口号问题" class="headerlink" title="bind 函数端口号问题"></a>bind 函数端口号问题</h2><p>网络通信程序的基本逻辑是客户端连接服务器，即从客户端的<strong>地址:端口</strong>连接到服务器<strong>地址:端口</strong>上，以 4.2 小节中的示例程序为例，服务器端的端口号使用 3000，那客户端连接时的端口号是多少呢？TCP 通信双方中一般服务器端端口号是固定的，而客户端端口号是连接发起时由操作系统随机分配的（不会分配已经被占用的端口）。端口号是一个 C short 类型的值，其范围是0～65535，知道这点很重要，所以我们在编写压力测试程序时，由于端口数量的限制，在某台机器上网卡地址不变的情况下压力测试程序理论上最多只能发起六万五千多个连接。注意我说的是理论上，在实际情况下，由于当时的操作系统很多端口可能已经被占用，实际可以使用的端口比这个更少，例如，一般规定端口号在1024以下的端口是保留端口，不建议用户程序使用。而对于 Windows 系统，MSDN 甚至明确地说：</p><blockquote><p>On Windows Vista and later, the dynamic client port range is a value between 49152 and 65535. This is a change from Windows Server 2003 and earlier where the dynamic client port range was a value between 1025 and 5000. Vista 及以后的Windows，可用的动态端口范围是49152～65535，而 Windows Server及更早的系统，可以的动态端口范围是1025~5000。（你可以通过修改注册表来改变这一设置，参考网址：<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-bind%EF%BC%89">https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-bind）</a></p></blockquote><p>如果将 bind 函数中的端口号设置成0，那么操作系统会随机给程序分配一个可用的侦听端口，当然服务器程序一般不会这么做，因为服务器程序是要对外服务的，必须让客户端知道确切的ip地址和端口号。</p><p>很多人觉得只有服务器程序可以调用 bind 函数绑定一个端口号，其实不然，在一些特殊的应用中，我们需要客户端程序以指定的端口号去连接服务器，此时我们就可以在客户端程序中调用 bind 函数绑定一个具体的端口。</p><p>我们用代码来实际验证一下上路所说的，为了能看到连接状态，我们将客户端和服务器关闭socket的代码注释掉，这样连接会保持一段时间。</p><ul><li><strong>情形一：客户端代码不绑定端口</strong></li></ul><p>修改后的服务器代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP服务器通信基本流程</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个侦听socket</span></span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create listen socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化服务器地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bindaddr</span>;</span></span><br><span class="line">    bindaddr.sin_family = AF_INET;</span><br><span class="line">    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    bindaddr.sin_port = htons(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;bindaddr, <span class="keyword">sizeof</span>(bindaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind listen socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.启动侦听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, SOMAXCONN) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;listen error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录所有客户端连接的容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; clientfds;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clientaddrlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="comment">//4. 接受客户端连接</span></span><br><span class="line">        <span class="keyword">int</span> clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);</span><br><span class="line">        <span class="keyword">if</span> (clientfd != <span class="number">-1</span>)</span><br><span class="line">        &#123;             </span><br><span class="line">            <span class="keyword">char</span> recvBuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="comment">//5. 从客户端接受数据</span></span><br><span class="line">            <span class="keyword">int</span> ret = recv(clientfd, recvBuf, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data from client, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">//6. 将收到的数据原封不动地发给客户端</span></span><br><span class="line">                ret = send(clientfd, recvBuf, <span class="built_in">strlen</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret != <span class="built_in">strlen</span>(recvBuf))</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data to client successfully, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//close(clientfd);</span></span><br><span class="line">            clientfds.push_back(clientfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.关闭侦听socket</span></span><br><span class="line">    close(listenfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的客户端代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP客户端通信基本流程</span></span><br><span class="line"><span class="comment"> * zhangyl 2018.12.13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_ADDRESS <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT     3000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEND_DATA       <span class="meta-string">&quot;helloworld&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个socket</span></span><br><span class="line">    <span class="keyword">int</span> clientfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (clientfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create client socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class="line">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    <span class="keyword">if</span> (connect(clientfd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;connect socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 向服务器发送数据</span></span><br><span class="line">    <span class="keyword">int</span> ret = send(clientfd, SEND_DATA, <span class="built_in">strlen</span>(SEND_DATA), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="built_in">strlen</span>(SEND_DATA))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data successfully, data: &quot;</span> &lt;&lt; SEND_DATA &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 从客户端收取数据</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ret = recv(clientfd, recvBuf, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data successfully, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data error, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 关闭socket</span></span><br><span class="line">    <span class="comment">//close(clientfd);</span></span><br><span class="line">    <span class="comment">//这里仅仅是为了让客户端程序不退出</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将程序编译好后（编译方法和上文一样），我们先启动server，再启动三个客户端。然后通过 <strong>lsof</strong> 命令查看当前机器上的 TCP 连接信息，为了更清楚地显示结果，已经将不相关的连接信息去掉了，结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsof -i -Pn</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">server   1445 root    3u  IPv4  21568      0t0  TCP *:3000 (LISTEN)</span><br><span class="line">server   1445 root    4u  IPv4  21569      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40818 (ESTABLISHED)</span><br><span class="line">server   1445 root    5u  IPv4  21570      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40820 (ESTABLISHED)</span><br><span class="line">server   1445 root    6u  IPv4  21038      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40822 (ESTABLISHED)</span><br><span class="line">client   1447 root    3u  IPv4  21037      0t0  TCP 127.0.0.1:40818-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class="line">client   1448 root    3u  IPv4  21571      0t0  TCP 127.0.0.1:40820-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class="line">client   1449 root    3u  IPv4  21572      0t0  TCP 127.0.0.1:40822-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>上面的结果显示，<strong>server</strong> 进程（进程 ID 是 <strong>1445</strong>）在 <strong>3000</strong> 端口开启侦听，有三个 <strong>client</strong> 进程（进程 ID 分别是<strong>1447</strong>、<strong>1448</strong>、<strong>1449</strong>）分别通过端口号 <strong>40818</strong>、<strong>40820</strong>、<strong>40822</strong> 连到 <strong>server</strong> 进程上的，作为客户端的一方，端口号是系统随机分配的。</p><ul><li><p><strong>情形二：客户端绑定端口号 0</strong></p><p>服务器端代码保持不变，我们修改下客户端代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP服务器通信基本流程</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_ADDRESS <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT     3000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEND_DATA       <span class="meta-string">&quot;helloworld&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//1.创建一个socket</span></span><br><span class="line">  <span class="keyword">int</span> clientfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (clientfd == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create client socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bindaddr</span>;</span></span><br><span class="line">  bindaddr.sin_family = AF_INET;</span><br><span class="line">  bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  <span class="comment">//将socket绑定到0号端口上去</span></span><br><span class="line">  bindaddr.sin_port = htons(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bind(clientfd, (struct sockaddr *)&amp;bindaddr, <span class="keyword">sizeof</span>(bindaddr)) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.连接服务器</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">  serveraddr.sin_family = AF_INET;</span><br><span class="line">  serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class="line">  serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">  <span class="keyword">if</span> (connect(clientfd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr)) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;connect socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3. 向服务器发送数据</span></span><br><span class="line">  <span class="keyword">int</span> ret = send(clientfd, SEND_DATA, <span class="built_in">strlen</span>(SEND_DATA), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret != <span class="built_in">strlen</span>(SEND_DATA))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data successfully, data: &quot;</span> &lt;&lt; SEND_DATA &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4. 从客户端收取数据</span></span><br><span class="line">  <span class="keyword">char</span> recvBuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  ret = recv(clientfd, recvBuf, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data successfully, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data error, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5. 关闭socket</span></span><br><span class="line">  <span class="comment">//close(clientfd);</span></span><br><span class="line">  <span class="comment">//这里仅仅是为了让客户端程序不退出</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      sleep(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们再次编译客户端程序，并启动三个 <strong>client</strong> 进程，然后用 <strong>lsof</strong> 命令查看机器上的 TCP 连接情况，结果如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># lsof -i -Pn</span></span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">server   1593 root    3u  IPv4  21807      0t0  TCP *:3000 (LISTEN)</span><br><span class="line">server   1593 root    4u  IPv4  21808      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:44220 (ESTABLISHED)</span><br><span class="line">server   1593 root    5u  IPv4  19311      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:38990 (ESTABLISHED)</span><br><span class="line">server   1593 root    6u  IPv4  21234      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:42365 (ESTABLISHED)</span><br><span class="line">client   1595 root    3u  IPv4  22626      0t0  TCP 127.0.0.1:44220-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class="line">client   1611 root    3u  IPv4  21835      0t0  TCP 127.0.0.1:38990-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class="line">client   1627 root    3u  IPv4  21239      0t0  TCP 127.0.0.1:42365-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>通过上面的结果，我们发现三个 <strong>client</strong> 进程使用的端口号仍然是系统随机分配的，也就是说绑定 <strong>0</strong> 号端口和没有绑定效果是一样的。</p><ul><li><p><strong>情形三：客户端绑定一个固定端口</strong></p><p>我们这里使用 <strong>20000</strong> 端口，当然读者可以根据自己的喜好选择，只要保证所选择的端口号当前没有被其他程序占用即可，服务器代码保持不变，客户端绑定代码中的端口号从 <strong>0</strong> 改成 <strong>20000</strong>。这里为了节省篇幅，只贴出修改处的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bindaddr</span>;</span></span><br><span class="line">bindaddr.sin_family = AF_INET;</span><br><span class="line">bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"><span class="comment">//将socket绑定到20000号端口上去</span></span><br><span class="line">bindaddr.sin_port = htons(<span class="number">20000</span>);</span><br><span class="line"><span class="keyword">if</span> (bind(clientfd, (struct sockaddr *)&amp;bindaddr, <span class="keyword">sizeof</span>(bindaddr)) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次重新编译程序，先启动一个客户端后，我们看到此时的 TCP 连接状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# lsof -i -Pn</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">server   1676 root    3u  IPv4  21933      0t0  TCP *:3000 (LISTEN)</span><br><span class="line">server   1676 root    4u  IPv4  21934      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:20000 (ESTABLISHED)</span><br><span class="line">client   1678 root    3u  IPv4  21336      0t0  TCP 127.0.0.1:20000-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>通过上面的结果，我们发现 <strong>client</strong> 进程确实使用 <strong>20000</strong> 号端口连接到 <strong>server</strong> 进程上去了。这个时候如果我们再开启一个 <strong>client</strong> 进程，我们猜想由于端口号 <strong>20000</strong> 已经被占用，新启动的 <strong>client</strong> 会由于调用 <strong>bind</strong> 函数出错而退出，我们实际验证一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# ./client </span><br><span class="line">bind socket error.</span><br><span class="line">[root@localhost testsocket]#</span><br></pre></td></tr></table></figure><p>结果确实和我们预想的一样。</p></li></ul><p>在技术面试的时候，有时候面试官会问 TCP 网络通信的客户端程序中的 socket 是否可以调用 bind 函数，相信读到这里，聪明的读者已经有答案了。</p><p>另外，Linux 的 <strong>nc</strong> 命令有个 <strong>-p</strong> 选项（字母 <strong>p</strong> 是小写），这个选项的作用就是 <strong>nc</strong> 在模拟客户端程序时，可以使用指定端口号连接到服务器程序上去，实现原理相信读者也明白了。我们还是以上面的服务器程序为例，这个我们不用我们的 <strong>client</strong> 程序，改用 <strong>nc</strong> 命令来模拟客户端。在 <strong>shell</strong> 终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# nc -v -p 9999 127.0.0.1 3000</span><br><span class="line">Ncat: Version 6.40 ( http://nmap.org/ncat )</span><br><span class="line">Ncat: Connected to 127.0.0.1:3000.</span><br><span class="line">My name is zhangxf</span><br><span class="line">My name is zhangxf</span><br></pre></td></tr></table></figure><p><strong>-v</strong> 选项表示输出 <strong>nc</strong> 命令连接的详细信息，这里连接成功以后，会输出“**Ncat: Connected to 127.0.0.1:3000.**” 提示已经连接到服务器的 <strong>3000</strong> 端口上去了。</p><p><strong>-p</strong> 选项的参数值是 <strong>9999</strong> 表示，我们要求 <strong>nc</strong> 命令本地以端口号 <strong>9999</strong> 连接服务器，注意不要与端口号 <strong>3000</strong> 混淆，<strong>3000</strong> 是服务器的侦听端口号，也就是我们的连接的目标端口号，<strong>9999</strong> 是我们客户端使用的端口号。我们用 <strong>lsof</strong> 命令来验证一下我们的 <strong>nc</strong> 命令是否确实以 <strong>9999</strong> 端口号连接到 <strong>server</strong> 进程上去了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# lsof -i -Pn</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">server   1676 root    3u  IPv4  21933      0t0  TCP *:3000 (LISTEN)</span><br><span class="line">server   1676 root    7u  IPv4  22405      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:9999 (ESTABLISHED)</span><br><span class="line">nc       2005 root    3u  IPv4  22408      0t0  TCP 127.0.0.1:9999-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>结果确实如我们期望的一致。</p><p>当然，我们用 <strong>nc</strong> 命令连接上 <strong>server</strong> 进程以后，我们还给服务器发了一条消息”<strong>My name is zhangxf</strong>“，<strong>server</strong> 程序收到消息后把这条消息原封不动地返还给我们，以下是 <strong>server</strong> 端运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# ./server   </span><br><span class="line">recv data from client, data: My name is zhangxf</span><br><span class="line"></span><br><span class="line">send data to client successfully, data: My name is zhangxf</span><br></pre></td></tr></table></figure><p>关于 <strong>lsof</strong> 和 <strong>nc</strong> 命令我们会在后面的系列文章中详细讲解。</p><p>参考：<a href="https://balloonwj.github.io/cpp-guide-web/articles/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/bind%E5%87%BD%E6%95%B0%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90.html">https://balloonwj.github.io/cpp-guide-web/articles/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/bind%E5%87%BD%E6%95%B0%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90.html</a></p>]]></content>
    
    
    <summary type="html">学习Socket网络编程</summary>
    
    
    
    <category term="网络编程" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Socket" scheme="http://example.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm</title>
    <link href="http://example.com/2021/02/21/Algorithm/"/>
    <id>http://example.com/2021/02/21/Algorithm/</id>
    <published>2021-02-21T13:32:33.000Z</published>
    <updated>2024-01-15T01:51:07.177Z</updated>
    
    <content type="html"><![CDATA[<p>整理分类做过的 <code>leetcode</code>，好记性不如烂笔头啊~</p><p>[TOC]</p><h1 id="HW"><a href="#HW" class="headerlink" title="HW"></a>HW</h1><h2 id="字符串分隔"><a href="#字符串分隔" class="headerlink" title="字符串分隔"></a><a href="https://www.nowcoder.com/practice/d9162298cb5a437aad722fccccaae8a7?tpId=37&tqId=21227&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=37&difficulty=undefined&judgeStatus=undefined&tags=&title=">字符串分隔</a></h2><p>•输入一个字符串，请按长度为8拆分每个输入字符串并进行输出；</p><p>•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。</p><p><strong>示例1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">abc</span><br><span class="line">输出：</span><br><span class="line">abc00000</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li>每个字符串长度小于等于100</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s) &#123; <span class="comment">// 注意 while 处理多个 case</span></span><br><span class="line">        <span class="keyword">while</span> (s.<span class="built_in">size</span>() % <span class="number">8</span>) &#123;</span><br><span class="line">            s += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>()/<span class="number">8</span>; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; s.<span class="built_in">substr</span>(i*<span class="number">8</span>, <span class="number">8</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="最长字串"><a href="#最长字串" class="headerlink" title="最长字串"></a>最长字串</h2><ul><li><p>给你一个字符串 s，字符串s首尾相连成一个环形 ，请你在环中找出 ‘o’ 字符出现了偶数次最长子字符串的长度。</p><p>输入描述：</p><p>输入是一串小写字母组成的字符串</p><p>输出描述：</p><p>输出是一个整数</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例1</span><br><span class="line">输入：</span><br><span class="line">alolobo</span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line">说明：</span><br><span class="line">最长子字符串之一是 &quot;alolob&quot;，它包含&#x27;o&#x27; 2个。</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：</span><br><span class="line">looxdolx</span><br><span class="line">输出：</span><br><span class="line">7</span><br><span class="line">说明：</span><br><span class="line">最长子字符串是 &quot;oxdolxl&quot;，由于是首尾连接在一起的，所以最后一个 &#x27;x&#x27; 和开头的 &#x27;l&#x27;是连接在一起的，此字符串包含 2 个&#x27;o&#x27; 。</span><br><span class="line"></span><br><span class="line">示例3</span><br><span class="line">输入：</span><br><span class="line">bcbcbc</span><br><span class="line">输出：</span><br><span class="line">6</span><br><span class="line">说明：</span><br><span class="line">这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为  &#x27;o&#x27; 都出现了 0 次。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>1 &lt;= s.length &lt;= 5 x 10^5</p></li><li><p>s 只包含小写英文字母。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 字符串 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c:s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; n - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数字反转打印"><a href="#数字反转打印" class="headerlink" title="数字反转打印"></a>数字反转打印</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">输入</span><br><span class="line">2</span><br><span class="line">输出</span><br><span class="line">    1***    </span><br><span class="line">3***    2***</span><br><span class="line"></span><br><span class="line">XXXX1***</span><br><span class="line">3***XXXX2***</span><br><span class="line">备注</span><br><span class="line">符号*表示数字不满4位时的补位，符号X表示数字之间的空格，实际不会打印X，直接打印空格</span><br></pre></td></tr></table></figure><p>数字反转打印规则如下:<br>a、每个数字占据4个位置，不足四位用<em>补位，如1打印为1</em>**.<br>b、数字之间相邻4空格。<br>C、数字的打印顺序按照正序逆序交替打印，奇数行正序，偶数行逆序。<br>d、最后一行数字顶格，第n-1行相对第n行缩进四个空格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个二维数组，用于存储每一行的数字</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">nums</span>(n + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> currVal = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= n; ++row) &#123; <span class="comment">// 按行遍历</span></span><br><span class="line">            <span class="keyword">if</span> (row % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123; <span class="comment">// 奇数行正序排列</span></span><br><span class="line">                    nums[row].<span class="built_in">push_back</span>(currVal++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123; <span class="comment">// 偶数行逆序排列</span></span><br><span class="line">                    nums[row].<span class="built_in">insert</span>(nums[row].<span class="built_in">begin</span>(), currVal++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string strAns;</span><br><span class="line">        <span class="keyword">int</span> blackNum = <span class="number">0</span>; <span class="comment">// 用于记录每一行的缩进空格数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从最后一行开始遍历到第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = n; k &gt;= <span class="number">1</span>; --k) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; num = nums[k];</span><br><span class="line">            stringstream ss;</span><br><span class="line">            <span class="function">string <span class="title">curr</span><span class="params">(blackNum, <span class="string">&#x27; &#x27;</span>)</span></span>; <span class="comment">// 每行缩进大小</span></span><br><span class="line">            ss &lt;&lt; curr;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 格式化数字并拼接到当前行的字符串中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">// 数组下标为size_t</span></span><br><span class="line">                ss &lt;&lt; left &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; num[i];</span><br><span class="line">                <span class="keyword">if</span> (i != num.<span class="built_in">size</span>() - <span class="number">1</span>) &#123; <span class="comment">// 不为行尾，加4个空格</span></span><br><span class="line">                    ss &lt;&lt; <span class="string">&quot;    &quot;</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 每一行结束后换行</span></span><br><span class="line">            strAns = ss.<span class="built_in">str</span>() + strAns; <span class="comment">// 将当前行的字符串加到最终结果的前面</span></span><br><span class="line">            blackNum += <span class="number">4</span>; <span class="comment">// 更新缩进空格数，使其加4，用于下一行的缩进空格数</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    Solution obj;</span><br><span class="line">    string result = obj.<span class="built_in">solve</span>(n);</span><br><span class="line">    cout &lt;&lt; result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;iomanip&gt;</span></span><br><span class="line"><span class="comment">std::setfill ：设置std::setw填充什么字符 如:std::setfill(&#x27;*&#x27;)；默认填充空格（’ &#x27;）</span></span><br><span class="line"><span class="comment">std::setw    ：需要填充多少个字符,默认填充的字符为&#x27; &#x27;空格</span></span><br><span class="line"><span class="comment">std::setbase(n)     ：将输出数据转换为n进制</span></span><br><span class="line"><span class="comment">std::setprecision() ：控制输出流显示浮点数的数字个数，C++默认的流输出数值有效位是6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分配土地"><a href="#分配土地" class="headerlink" title="分配土地"></a>分配土地</h2><ul><li>从前有个村庄，村民们喜欢在各种田地上插上小旗子，旗子上标识了各种不同的数字，某天全体村民决定将覆盖相同数字的最小矩阵形的土地的分配给为村里做出巨大贡献的村民，请问：此次分配土地，做出贡献的村民中最大会分配多大面积?</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">3 3</span><br><span class="line">1 0 1</span><br><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">土地上的旗子为1, 其坐标分别为(0,0), (2,1)以及(0,2), 为了覆盖所有旗子，矩阵需要覆盖的横坐标为0和2,纵坐标为0和2,所以面积为9,即(2-0+1)*(2-0+1)=9</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">3 3</span><br><span class="line">1 0 2</span><br><span class="line">0 0 0</span><br><span class="line">0 3 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">不存在成对的旗子，返回1</span><br></pre></td></tr></table></figure><ul><li><p>输入<br>第一行输入m和n，m代表村子的土地的长，n代表土地的宽<br>第二开始输入地图上的具体标识</p></li><li><p>输出<br>输出要分配的土地面积，包含相桐数字旗子的最小矩阵中的最大面积</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate_largest_area</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个unordered_map来存储每个数字旗子的最小矩阵边界</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, unordered_map&lt;string, <span class="keyword">int</span>&gt;&gt; flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = grid[i][j];</span><br><span class="line">            <span class="comment">// 如果当前位置有旗子</span></span><br><span class="line">            <span class="keyword">if</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果旗子是第一次出现，初始化其边界</span></span><br><span class="line">                <span class="keyword">if</span> (flags.<span class="built_in">find</span>(flag) == flags.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    flags[flag] = &#123;&#123;<span class="string">&quot;min_x&quot;</span>, i&#125;, &#123;<span class="string">&quot;max_x&quot;</span>, i&#125;, &#123;<span class="string">&quot;min_y&quot;</span>, j&#125;, &#123;<span class="string">&quot;max_y&quot;</span>, j&#125;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 更新旗子的边界</span></span><br><span class="line">                    flags[flag][<span class="string">&quot;min_x&quot;</span>] = <span class="built_in">min</span>(flags[flag][<span class="string">&quot;min_x&quot;</span>], i);</span><br><span class="line">                    flags[flag][<span class="string">&quot;max_x&quot;</span>] = <span class="built_in">max</span>(flags[flag][<span class="string">&quot;max_x&quot;</span>], i);</span><br><span class="line">                    flags[flag][<span class="string">&quot;min_y&quot;</span>] = <span class="built_in">min</span>(flags[flag][<span class="string">&quot;min_y&quot;</span>], j);</span><br><span class="line">                    flags[flag][<span class="string">&quot;max_y&quot;</span>] = <span class="built_in">max</span>(flags[flag][<span class="string">&quot;max_y&quot;</span>], j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有旗子，计算它们的最小覆盖矩阵面积，并找到最大值</span></span><br><span class="line">    <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; flag : flags) &#123;</span><br><span class="line">        <span class="keyword">int</span> area = (flag.second[<span class="string">&quot;max_x&quot;</span>] - flag.second[<span class="string">&quot;min_x&quot;</span>] + <span class="number">1</span>) * (flag.second[<span class="string">&quot;max_y&quot;</span>] - flag.second[<span class="string">&quot;min_y&quot;</span>] + <span class="number">1</span>);</span><br><span class="line">        max_area = <span class="built_in">max</span>(max_area, area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有旗子，则返回1</span></span><br><span class="line">    <span class="keyword">return</span> max_area &gt; <span class="number">0</span> ? max_area : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">grid</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算要分配的土地面积并输出</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">calculate_largest_area</span>(m, n, grid);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="篮球"><a href="#篮球" class="headerlink" title="篮球"></a>篮球</h2><ul><li>只能右进，左右都可出，最后只能左出</li><li>双端队列</li></ul><h2 id="字符串输出"><a href="#字符串输出" class="headerlink" title="字符串输出"></a>字符串输出</h2><p>如果统计的个数相同，则按照ASII码由小到大排序输出 。如果有其他字符，则对这些字符不用进行统计。<br>    输入一个字符串，对字符中的各个英文字符，数字，空格进行统计（可反复调用）<br>    按照统计个数由多到少输出统计结果，如果统计的个数相同，则按照ASII码由小到大排序输出<br>    清空目前的统计结果，重新统计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">aadddccddc</span><br><span class="line">输出例子:</span><br><span class="line">dca</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solution</span> <span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c:s) &#123;</span><br><span class="line">        <span class="comment">/* 空格 英文字符 数字 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalnum</span>(c) || c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            mp[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* sort */</span></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &gt; <span class="built_in">vec</span>(mp.<span class="built_in">begin</span>(), mp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;b) &#123;</span><br><span class="line">        <span class="comment">/* ASII码由小到大排序 */</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (a.second &gt; b.second) || ((a.second == b.second) &amp;&amp; (a.first &lt; b.first));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/* cout */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair:vec) &#123;</span><br><span class="line">        cout &lt;&lt; pair.first;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123;</span><br><span class="line">        <span class="built_in">solution</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口-双指针"><a href="#滑动窗口-双指针" class="headerlink" title="滑动窗口/双指针"></a>滑动窗口/双指针</h1><p><strong>最短或最长的子串  最多可变k次</strong></p><h2 id="LC-3-无重复字符的最长子串"><a href="#LC-3-无重复字符的最长子串" class="headerlink" title="LC-3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LC-3. 无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （一）</span></span><br><span class="line"><span class="comment"> * 这里可以建立一个 HashMap，建立每个字符和其最后出现位置之间的映射</span></span><br><span class="line"><span class="comment"> * 然后定义两个变量 res 和 left，其中 res 用来记录最长无重复子串的长度</span></span><br><span class="line"><span class="comment"> * left 指向该无重复子串左边的起始位置的前一个，所以初始化就是 -1</span></span><br><span class="line"><span class="comment"> * 然后遍历整个字符串，对于每一个遍历到的字符，如果该字符已经在 HashMap 中存在了，</span></span><br><span class="line"><span class="comment"> * 并且如果其映射值大于 left 的话，那么更新 left 为当前映射值。然后映射值更新为当前坐标i，</span></span><br><span class="line"><span class="comment"> * 这样保证了 left 始终为当前边界的前一个位置，然后计算窗口长度的时候，直接用 i-left 即可，</span></span><br><span class="line"><span class="comment"> * 用来更新结果 res。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">-1</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(s[i]) &amp;&amp; m[s[i]] &gt; left) &#123;</span><br><span class="line">                left = m[s[i]];  </span><br><span class="line">            &#125;</span><br><span class="line">            m[s[i]] = i;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - left);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种解法使用了 <code>HashSet</code>，核心算法和上面的很类似，把出现过的字符都放入<code>HashSet</code>中，遇到 <code>HashSet </code>中没有的字符就加入<code> HashSet</code> 中并更新结果 <code>res</code>，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （二）</span></span><br><span class="line"><span class="comment"> * 下面这种解法使用了 HashSet，核心算法和上面的很类似，</span></span><br><span class="line"><span class="comment"> * 把出现过的字符都放入 HashSet 中，遇到 HashSet 中没有的字符就加入 HashSet</span></span><br><span class="line"><span class="comment"> * 并更新结果 res，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, res=<span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">find</span>(s[i])!=st.<span class="built_in">end</span>())&#123;</span><br><span class="line">                st.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">            res=<span class="built_in">max</span>(res,i-left+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-76-最小覆盖子串"><a href="#LC-76-最小覆盖子串" class="headerlink" title="LC-76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">LC-76. 最小覆盖子串</a></h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p> <strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p>这道题给了我们一个原字符串<code>s</code>，还有一个目标字符串<code>t</code>，让在<code>s</code>中找到一个最短的子串，使得其包含了<code>t</code>中的所有的字母，并且限制了时间复杂度为<code> O(n)</code>。这道题的要求是要在<code>O(n) </code>的时间度里实现找到这个最小窗口字串，暴力搜索 <code>Brute Force </code>肯定是不能用的，因为遍历所有的子串的时间复杂度是平方级的。那么来想一下，时间复杂度卡的这么严，说明必须在一次遍历中完成任务，当然遍历若干次也是<code> O(n)</code>，但不一定有这个必要，尝试就一次遍历拿下！那么再来想，既然要包含T中所有的字母，那么对于T中的每个字母，肯定要快速查找是否在子串中，既然总时间都卡在了<code> O(n)</code>，肯定不想在这里还浪费时间，就用空间换时间（也就算法题中可以这么干了，七老八十的富翁就算用大别野也换不来时间啊。依依东望，望的就是时间呐），使用<code> HashMap</code>，建立T中每个字母与其出现次数之间的映射。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * step1: 确定右边界</span></span><br><span class="line"><span class="comment"> * 先用 HashMap 统计好 t 串中字母的，再遍历 s 串，对于 s 中的每个字母</span></span><br><span class="line"><span class="comment"> * 都将 HashMap 中的映射值减1，如果减1后的映射值仍大于等于0，说明当前遍历到的字母是 t 串中的字母</span></span><br><span class="line"><span class="comment"> * 使用 cnt++ 记录。当cnt 和 t 串字母个数相等时，说明此时的窗口已经包含了 t 串中的所有字母</span></span><br><span class="line"><span class="comment"> * step2: 收缩左边界</span></span><br><span class="line"><span class="comment"> * 由于遍历的时候，映射值减了1，所以此时去除字母的时候，就要把减去的1加回来，</span></span><br><span class="line"><span class="comment"> * 此时如果加1后的值大于0了，说明当前遍历到的字母是 t 串中的字母，</span></span><br><span class="line"><span class="comment"> * 那么 cnt 值就要减1了，然后移动左边界left</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; letterCnt;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++letterCnt[c];         <span class="comment">//遍历t</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--letterCnt[s[i]] &gt;= <span class="number">0</span>) ++cnt;   <span class="comment">//--letterCnt[s[i]] &gt;= 0，s[i]在t中</span></span><br><span class="line">            <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                    res = s.<span class="built_in">substr</span>(left, minLen); <span class="comment">//从left开始，长度为minLen的字符串</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收缩左边界 ++letterCnt[s[left]] &gt; 0， 0-&gt;1 该元素在t中，</span></span><br><span class="line">                <span class="keyword">if</span> (++letterCnt[s[left]] &gt; <span class="number">0</span>) --cnt;   </span><br><span class="line">                <span class="comment">//因为不在t中的本来为0，先减去，现在再增加，最终还是0.</span></span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="pa-3-寻找最靠左的匹配子串"><a href="#pa-3-寻找最靠左的匹配子串" class="headerlink" title="pa-3.寻找最靠左的匹配子串"></a><a href="https://www.papamelon.com/problem/3">pa-3.寻找最靠左的匹配子串</a></h2><p>给定一个字符串 A 长度为 N，1 &lt;= N &lt;= 2*10^5，下标从 0 开始标号，仅包含 0 到 9 这十种字符。</p><p>再给定另一个字符串 B，长度为 M，1 &lt;= M &lt;= 2*10^5，下标从 0 开始标号，也是仅包含 0 到 9 这十种字符。</p><p>例如以下字符串就是一个合法的 A或 B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">066465353473034515</span><br></pre></td></tr></table></figure><p>现在我们要在 A寻找一个连续的子串 s，使得 s包含 B中出现的所有字符，且要保证 s的<strong>长度尽可能短</strong>。如果存在多个符合上述条件的 s，<strong>返回最靠左</strong>的那个。</p><p>例如:</p><ul><li>B串：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3314</span><br></pre></td></tr></table></figure><ul><li>A串：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">563145633</span><br></pre></td></tr></table></figure><p>子串 A[2:7]为 <code>314563</code>，包含了 B串中出现的 <code>3</code>, <code>3</code>, <code>1</code>, <code>4</code>。</p><p>子串 A[3:8]为 <code>145633</code>，也包含了 B串中出现的 <code>3</code>, <code>3</code>, <code>1</code>, <code>4</code>。</p><p>两个子串长度一样，而前者更靠左，因此前者就是我们要找的答案。</p><p><strong>输入</strong></p><ul><li>每组测试数据的第一行是整数 T，$1 \leq T \leq 1000$，表示接下来有 T对 A, B串</li><li>接下来有 $2*T$行，每两行分别表示一对 A串和 B串</li><li>A<em>A</em> 串长度为 N，1 &lt;= N &lt;= 2*10^5</li><li>B<em>B</em> 串长度为 M，1 &lt;= M &lt;= 2*10^5</li><li>一组测试数据中字符总数为 C，  2 * T  &lt;= C &lt;= 2*10^6</li></ul><p><strong>输出</strong></p><ul><li>输出 T行，每行两个整数，用空格分割，表示 A的子串下标</li><li>如果不存在这样的合法子串，输出 <code>-1 -1</code></li></ul><p>样例 1</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">563145633</span><br><span class="line">3314</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>样例 2</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">678</span><br><span class="line">123</span><br><span class="line">12345</span><br><span class="line">1233</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 -1</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （一）</span></span><br><span class="line"><span class="comment"> * 核心算法继承LC-76，先确定右边界再收缩左边界</span></span><br><span class="line"><span class="comment"> * 需要注意输入输出的练习</span></span><br><span class="line"><span class="comment"> * if else规范书写，一个小bug调式了好久</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s, t;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++mp[c];        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--mp[s[i]] &gt;= <span class="number">0</span>) ++cnt;   </span><br><span class="line">            <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                    res.<span class="built_in">clear</span>();</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;left,left+minLen<span class="number">-1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++mp[s[left]] &gt; <span class="number">0</span>) --cnt;   </span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-1</span> &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; res[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>  &lt;&lt; res[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">Solution</span>().<span class="built_in">minWindow</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （二）</span></span><br><span class="line"><span class="comment"> * 核心算法继承LC-76，</span></span><br><span class="line"><span class="comment"> * 代码稍微简洁，逻辑不变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s, t;</span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++mp[c];         </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--mp[s[i]] &gt;= <span class="number">0</span>) ++cnt;   </span><br><span class="line">        <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                res.<span class="built_in">clear</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;left,left+minLen<span class="number">-1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++mp[s[left]] &gt; <span class="number">0</span>) --cnt;   </span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return res;</span></span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-1</span> &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; res[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>  &lt;&lt; res[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pa-191-优雅地分割字符串"><a href="#pa-191-优雅地分割字符串" class="headerlink" title="pa-191.优雅地分割字符串"></a><a href="https://www.papamelon.com/problem/191">pa-191.优雅地分割字符串</a></h2><p>给定一个只包含小写字母的字符串，长度不超过 100000</p><p>将字符串分割成左右两半，要求左右两半的字符种类完全相等（个数可以不同）。</p><p>有多少种不同的分割方式？</p><p><strong>输入</strong></p><ul><li>多组测试数据，以 <code>EOF</code> 结束</li><li>每组测试数据一行字符串，仅包含小写字母，长度不超过 100000</li><li>多组测试数据的字符串长度总和不超过 100000</li></ul><p><strong>输出</strong></p><ul><li>每组测试数据输出一行，一行一个整数，表示有多少种切割方式</li></ul><p>**样例 **</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">abcabc</span><br><span class="line">aaaa</span><br><span class="line">acbbbca</span><br><span class="line">输出</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-11-11 20:31:38</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-11-11 22:14:00</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(<span class="number">26</span>, INF)</span>, <span class="title">r</span><span class="params">(<span class="number">26</span>, <span class="number">-1</span>)</span>, <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// l[i] 第 i 个字符首次出现在 s 中的位置</span></span><br><span class="line">    <span class="comment">// r[i] 第 i 个字符最后出现在 s 中的位置</span></span><br><span class="line">    <span class="comment">// cnt[i] 第 i 个字符出现了多少次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = s[i] - <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// 在字母表中位置</span></span><br><span class="line">        l[k] = <span class="built_in">min</span>(l[k], i);</span><br><span class="line">        r[k] = <span class="built_in">max</span>(r[k], i);</span><br><span class="line">        cnt[k]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>, maxl = <span class="number">-1</span>, minr = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span> (cnt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i] == <span class="number">1</span>) &#123; <span class="comment">//只出现一次的字符 不满足</span></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxl = <span class="built_in">max</span>(maxl, l[i]);</span><br><span class="line">        minr = <span class="built_in">min</span>(minr, r[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割位置一定在 [maxl, minr)</span></span><br><span class="line">    <span class="comment">// max&#123;la, lb, lc ... lz&#125;  min&#123;ra, rb, rc ... rz&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (!flag || minr &lt; maxl) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minr - maxl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s) <span class="built_in">solve</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LC-1-两数之和"><a href="#LC-1-两数之和" class="headerlink" title="LC-1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">LC-1. 两数之和</a></h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em>target</em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong> 你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （一）</span></span><br><span class="line"><span class="comment"> * 笨方法</span></span><br><span class="line"><span class="comment"> * 最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</span></span><br><span class="line"><span class="comment"> * 当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，</span></span><br><span class="line"><span class="comment"> * 因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(target== nums[i]+nums[j])&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （二）</span></span><br><span class="line"><span class="comment"> * 注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，</span></span><br><span class="line"><span class="comment"> * 能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</span></span><br><span class="line"><span class="comment"> * 使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)。</span></span><br><span class="line"><span class="comment"> * 这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，</span></span><br><span class="line"><span class="comment"> * 即可保证不会让 x 和自己匹配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(target-nums[i])!=mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(mp.<span class="built_in">find</span>(target-nums[i])-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mp.insert(pair&lt;int, int&gt;(nums[i], i));</span></span><br><span class="line">            mp[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （三）再精简一下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, m[target - nums[i]]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-15-三数之和"><a href="#LC-15-三数之和" class="headerlink" title="LC-15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">LC-15. 三数之和</a></h2><p>难度中等3545收藏分享切换为英文接收动态反馈</p><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序+双指针</span></span><br><span class="line"><span class="comment"> * 固定第一个数，转化为求两数之和</span></span><br><span class="line"><span class="comment"> * 特别注意相邻元素去重</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">3</span>)   <span class="keyword">return</span> &#123;&#125;;          <span class="comment">// 特判</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;res;            <span class="comment">// 保存结果（所有不重复的三元组）</span></span><br><span class="line">        std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// 排序（默认递增）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)      <span class="comment">// 固定第一个数，转化为求两数之和</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)  <span class="keyword">return</span> res; <span class="comment">// 第一个数大于 0，后面都是递增正数，不可能相加为零</span></span><br><span class="line">            <span class="comment">// 去重：如果此数已经选取过，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 双指针在nums[i]后面的区间中寻找和为0-nums[i]的另外两个数</span></span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] &gt; -nums[i])</span><br><span class="line">                    right--;    <span class="comment">// 两数之和太大，右指针左移</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; -nums[i])</span><br><span class="line">                    left++;     <span class="comment">// 两数之和太小，左指针右移</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 找到一个和为零的三元组，添加到结果中，左右指针内缩，继续寻找</span></span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="comment">// 去重：第二个数和第三个数也不重复选取</span></span><br><span class="line">                    <span class="comment">// 例如：[-4,1,1,1,2,3,3,3], i=0, left=1, right=5</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">-1</span>])  left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>])    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-40-组合总和-II"><a href="#LC-40-组合总和-II" class="headerlink" title="LC-40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">LC-40. 组合总和 II</a></h2><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,2,2],</span><br><span class="line">[5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回溯+剪枝</span></span><br><span class="line"><span class="comment"> * 特别注意相邻元素去重</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; target-candidates[i] &gt;= <span class="number">0</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; index &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//处理节点</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            <span class="built_in">backtrack</span>(candidates, target-candidates[i], i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯，撤销处理结果</span></span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//对candidates先排序</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-451-根据字符出现频率排序"><a href="#LC-451-根据字符出现频率排序" class="headerlink" title="LC-451.根据字符出现频率排序"></a><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">LC-451.根据字符出现频率排序</a></h2><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><p>示例 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line">输出:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line">解释:</span><br><span class="line">&#x27;e&#x27;出现两次，&#x27;r&#x27;和&#x27;t&#x27;都只出现一次。</span><br><span class="line">因此&#x27;e&#x27;必须出现在&#x27;r&#x27;和&#x27;t&#x27;之前。此外，&quot;eetr&quot;也是一个有效的答案。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line">输出:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line">解释:</span><br><span class="line">&#x27;c&#x27;和&#x27;a&#x27;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。</span><br><span class="line">注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line">输出:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line">解释:</span><br><span class="line">此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。</span><br><span class="line">注意&#x27;A&#x27;和&#x27;a&#x27;被认为是两种不同的字符。。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表记录每个字符出现的频率，将字符去重后存入列表</span></span><br><span class="line"><span class="comment"> * 再将列表中的字符按照频率降序排序</span></span><br><span class="line"><span class="comment"> * 生成排序后的字符串时，遍历列表中的每个字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:s) mp[it]++;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; vec; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) vec.<span class="built_in">push_back</span>(it);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;b)&#123;<span class="keyword">return</span> a.second &gt; b.second;&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [ch, num] : vec) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vector&lt;pair&lt;int,int&gt; &gt;vec</span></span><br><span class="line"><span class="comment"> * vec.push_back(make_pair&lt;int,int&gt;(10,50));</span></span><br><span class="line"><span class="comment"> * vec.push_back(make_pair(20,30));</span></span><br><span class="line"><span class="comment"> * vector&lt;pair&lt;int,int&gt;&gt; ::iterator iter;</span></span><br><span class="line"><span class="comment"> * for(iter=vec.begin();iter!=vec.end();iter++);</span></span><br><span class="line"><span class="comment"> * 第一个数据:(*iter).first</span></span><br><span class="line"><span class="comment"> * 第二个数据:(*iter).second</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="LC-165-比较版本号"><a href="#LC-165-比较版本号" class="headerlink" title="LC-165.比较版本号"></a><a href="https://leetcode-cn.com/problems/compare-version-numbers/">LC-165.比较版本号</a></h2><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><blockquote><ul><li>如果 version1 &gt; version2 返回 1，</li><li>如果 version1 &lt; version2 返回 -1，</li><li>除此之外返回 0。</li></ul></blockquote><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：忽略前导零，&quot;01&quot; 和 &quot;001&quot; 都表示相同的整数 &quot;1&quot;</span><br><span class="line"></span><br><span class="line">输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：version1 没有指定下标为 2 的修订号，即视为 &quot;0&quot;</span><br><span class="line"></span><br><span class="line">输入：version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：version1 中下标为 0 的修订号是 &quot;0&quot;，version2 中下标为 0 的修订号是 &quot;1&quot; 。0 &lt; 1，所以 version1 &lt; version2</span><br><span class="line"></span><br><span class="line">输入：version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = version1.<span class="built_in">length</span>(), m = version2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n || j &lt; m) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; n &amp;&amp; version1[i] != <span class="string">&#x27;.&#x27;</span>; ++i) &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + version1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i; <span class="comment">// 跳过点号</span></span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; m &amp;&amp; version2[j] != <span class="string">&#x27;.&#x27;</span>; ++j) &#123;</span><br><span class="line">                y = y * <span class="number">10</span> + version2[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++j; <span class="comment">// 跳过点号</span></span><br><span class="line">            <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">                <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  stringstream + getline 分割</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">strtoint</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res1 = <span class="built_in">strtoint</span>(version1);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res2 = <span class="built_in">strtoint</span>(version2);</span><br><span class="line">        <span class="keyword">while</span>(res1.<span class="built_in">size</span>()&lt;res2.<span class="built_in">size</span>())  res1.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(res1.<span class="built_in">size</span>()&gt;res2.<span class="built_in">size</span>())  res2.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res1.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res1[i]&gt;res2[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(res1[i]&lt;res2[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-136-只出现一次的数字"><a href="#LC-136-只出现一次的数字" class="headerlink" title="LC-136.只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/">LC-136.只出现一次的数字</a></h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>**示例 **</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: 位运算</span></span><br><span class="line"><span class="comment"> * 任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a</span></span><br><span class="line"><span class="comment"> * 任何数和其自身做异或运算，结果是 0，即 a⊕a=0</span></span><br><span class="line"><span class="comment"> * 异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>给定一个数组，从数组中查找左右对称相加的和等于k的最长子数组</p><p>示例</p><p>arr = [2,4,4,5,10,5,6,9,8]   k=10</p><p>res = [4,5,10,5,6]</p><p>arr = [2,6,7,10,2,5,6,9]   k=12</p><p>res = [6,7,10,2,5,6]</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><a href="https://blog.csdn.net/yushiyi6453/article/details/76407640">时间复杂度</a></h2><p><img src="/2021/02/21/Algorithm/Projects\Gits\hexo\myblog\source_posts\Algorithm\排序.png" alt="排序"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>快速排序稳定性</strong><br>快速排序是不稳定的算法，它不满足稳定算法的定义。</p><blockquote><p>算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的</p></blockquote><p><strong>快速排序时间复杂度</strong><br>快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)。<br>这句话很好理解：假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？至少lg(N+1)次，最多N次。</p><blockquote><ul><li>为什么最少是lg(N+1)次？快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。</li><li> 为什么最多是N次？这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。</li><li>在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，它就是一棵斜树。此时需要执行n‐1次递归调用，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是枢轴的位置，因此比较次数为 n(n-1)/2,最终其时间复杂度为O(n2)</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quicksort</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=left, j=right;</span><br><span class="line">        <span class="keyword">int</span> rd = <span class="built_in">rand</span>()%(right-left+<span class="number">1</span>)+left;</span><br><span class="line">        <span class="built_in">swap</span>(arr[rd], arr[right]);</span><br><span class="line">        <span class="comment">// 先以最右侧元素为基准</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// 先从左往右遍历</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[right]) i++;</span><br><span class="line">            <span class="comment">// 再从右往左遍历</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[right]) j--;</span><br><span class="line">            <span class="comment">// i所指元素小于基准，j所指元素大于基准</span></span><br><span class="line">            <span class="comment">// 交换i和j的元素</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">            <span class="comment">// 循环进行，直到i和j指向同一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不稳定性发生在中枢元素与a[i]交换的时刻</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[right]); <span class="comment">// 将基准元素换到循环停止的位置</span></span><br><span class="line">        <span class="comment">// 此时基准左边全小于它的数，右边全是大于它的数</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">partition</span>(arr,left,right);</span><br><span class="line">            <span class="built_in">quick_sort</span>(arr,left,t<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">quick_sort</span>(arr,t+<span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>原理</strong></p><blockquote><p>冒泡排序从小到大排序：一开始交换的区间为0~N-1，将第1个数和第2个数进行比较，前面大于后面，交换两个数，否则不交换。再比较第2个数和第三个数，前面大于后面，交换两个数否则不交换。依次进行，最大的数会放在数组最后的位置。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一维数组作为参数</span></span><br><span class="line"><span class="comment"> * int sum_arr (int att[] , int size)</span></span><br><span class="line"><span class="comment"> * int sum_arr (int *att , int size)</span></span><br><span class="line"><span class="comment"> * array[]为待排序数组，n为数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=array[j];</span><br><span class="line">                array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>原理</strong></p><blockquote><p>选择排序从小到大排序：一开始从0~ n-1区间上选择一个最小值，将其放在位置0上，然后在1~n-1范围上选取最小值放在位置1上。重复过程直到剩下最后一个元素，数组即为有序。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//array[]为待排序数组，n为数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j ,min ,k;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min=i; <span class="comment">//每趟排序最小值先等于第一个数，遍历剩下的数</span></span><br><span class="line">        <span class="keyword">for</span>( j=i+<span class="number">1</span>; j&lt;n; j++) <span class="comment">//从i下一个数开始检查</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[min]&gt;array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            k=array[min];</span><br><span class="line">            array[min]=array[i];</span><br><span class="line">            array[i]=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>原理</strong></p><blockquote><p>每一轮都会从输入地数据里移除一个元素，并将其正确地插入已经排好顺序地那个范围之内。至于移除是哪一个元素，则可以随机选取，直至将所有地元素都处理完为止。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insersort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, v;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">        v = a[i];</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span>(a[j<span class="number">-1</span>]&gt;v&amp;&amp;j&gt;=<span class="number">1</span> )&#123;</span><br><span class="line">            a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>原理</strong></p><blockquote><p>希尔排序也叫递减增量排序，是对插入排序的推广。对于本身已经基本上拍好顺序的数组来说，插入排序的处理效率比较高，而希尔排序可以视为跨度为n的插入排序。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n)</span>  <span class="comment">//希尔排序函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, step;</span><br><span class="line"><span class="keyword">for</span> (step = n / <span class="number">2</span>; step &gt; <span class="number">0</span>; step = step / <span class="number">2</span>)&#123; <span class="comment">//这里的step步长是根据元素情况定义的</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; step; i++)&#123;  <span class="comment">//i是子数组的编号</span></span><br><span class="line"><span class="keyword">for</span> (j = i + step; j &lt; n; j = j + step)&#123;  <span class="comment">//数组下标j，数组步长下标j+step</span></span><br><span class="line"><span class="keyword">if</span> (array[j] &lt; array[j - step])&#123;</span><br><span class="line"><span class="keyword">int</span> temp = array[j];  <span class="comment">//把数组下标j的值放到temp中</span></span><br><span class="line"><span class="keyword">int</span> k = j - step;</span><br><span class="line"><span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; temp &lt; array[k])&#123;</span><br><span class="line">array[k + step] = array[k];  <span class="comment">//把大的值往后插入</span></span><br><span class="line">k = k - step;</span><br><span class="line">&#125;</span><br><span class="line">array[k + step] = temp;  <span class="comment">//把小的值往前插入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>原理</strong></p><blockquote><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p></blockquote><p><strong>算法描述</strong></p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#实现归并，并把数据都放在list1里面 </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merging</span><span class="params">(<span class="keyword">int</span> *list1, <span class="keyword">int</span> list1_size, <span class="keyword">int</span> *list2,  <span class="keyword">int</span> list2_size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>, m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp[MAXSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; list1_size &amp;&amp; j &lt; list2_size)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1[i]&lt;list2[j])&#123;</span><br><span class="line">            temp[k++] = list1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp[k++] = list2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;list1_size)&#123;</span><br><span class="line">        temp[k++] = list1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;list2_size)&#123;</span><br><span class="line">        temp[k++] = list2[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>; m &lt; (list1_size+list2_size); m++)&#123;</span><br><span class="line">        list1[m]=temp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果有剩下的，那么说明就是它是比前面的数组都大的，直接加入就可以了 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> *list1 = array;</span><br><span class="line">        <span class="keyword">int</span> list1_size = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> *list2 = array + n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> list2_size = n-list1_size;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">mergeSort</span>(list1, list1_size);</span><br><span class="line">        <span class="built_in">mergeSort</span>(list2, list2_size);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">merging</span>(list1, list1_size, list2, list2_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序复杂度分析：一趟归并需要将待排序列中的所有记录  </span></span><br><span class="line"><span class="comment">//扫描一遍，因此耗费时间为O(n),而由完全二叉树的深度可知，  </span></span><br><span class="line"><span class="comment">//整个归并排序需要进行[log2n],因此，总的时间复杂度为  </span></span><br><span class="line"><span class="comment">//O(nlogn),而且这是归并排序算法中平均的时间性能  </span></span><br><span class="line"><span class="comment">//空间复杂度：由于归并过程中需要与原始记录序列同样数量级的  </span></span><br><span class="line"><span class="comment">//存储空间去存放归并结果及递归深度为log2N的栈空间，因此空间  </span></span><br><span class="line"><span class="comment">//复杂度为O(n+logN)  </span></span><br><span class="line"><span class="comment">//也就是说，归并排序是一种比较占内存，但却效率高且稳定的算法 </span></span><br></pre></td></tr></table></figure><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="LC-122-买卖股票的最佳时机-II"><a href="#LC-122-买卖股票的最佳时机-II" class="headerlink" title="LC-122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LC-122. 买卖股票的最佳时机 II</a></h2><p>难度简单1290收藏分享切换为英文接收动态反馈</p><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= prices[i] &lt;= 10^4</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pa-9-套娃"><a href="#pa-9-套娃" class="headerlink" title="pa-9.套娃"></a><a href="https://www.papamelon.com/problem/9">pa-9.套娃</a></h2><p>小棒瓜瓜有 n个套娃，设第 i个套娃的体积为v_i，大套娃可以套住小套娃，同时要满足以下条件：</p><ul><li>一个大套娃想要套住另一个小套娃，体积至少是其 3 倍；例如大套娃体积为 10，小套娃体积为 3，前者是后者的 3.333… 倍，可以套住</li><li>一个大套娃只能套住一个小套娃，一旦套住后，小套娃不能再套其他更小的套娃，也就是说不能继续嵌套下去</li><li>当大套娃套住小套娃后，小套娃不再可见</li></ul><p>现在我们要帮小棒瓜瓜选择一种最优的套娃方案，使得最终可见的套娃数量最少。</p><p><strong>输入</strong></p><ul><li>第一行输入整数 T,  1 &lt;= T &lt;=1000，表示接下来有 T组数据</li><li>接下来有 T行，每行表示一组套娃的信息</li><li>对于每组套娃，第一个整数是 n，表示套娃数量，1 &lt;= n &lt;= 600；后面跟着 n个正整数，用空格分隔，表示每个套娃的体积，第 i个整数为 v_i, 1 &lt;= v_i &lt;= 10000​</li></ul><p><strong>输出</strong></p><ul><li>输出 T行，每行一个整数，表示 T组套娃经过操作，可见套娃的最小数量</li></ul><p>样例 1</p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 1 3 7</span><br><span class="line">3 1 2 3</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  |-----------------|------------------|</span></span><br><span class="line"><span class="comment"> * a[0]              a[n/2]             a[n-1]</span></span><br><span class="line"><span class="comment"> * 根据条件2，一个大娃只能套一个小娃，所以最终可见套娃数量最少为 n/2</span></span><br><span class="line"><span class="comment"> * 所以小娃在前半部分，大娃在后半部分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n ;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        a.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> res = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n/<span class="number">2</span> &amp;&amp; j&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]/a[i] &gt;=<span class="number">3</span>)&#123;</span><br><span class="line">            res--;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> j++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-18-套娃II"><a href="#pa-18-套娃II" class="headerlink" title="pa-18.套娃II"></a><a href="https://www.papamelon.com/problem/18">pa-18.套娃II</a></h2><p>小棒瓜瓜在第一次得到 <a href="https://www.papamelon.com/problem/9">套娃</a> 玩具后，喜欢上了这种玩具，这次他准备用行李箱上带着套娃去旅游。</p><p>现在有 n个套娃，设第 i 个套娃的体积为 v_i，大套娃可以套住小套娃，同时要满足以下条件：</p><ul><li>一个大套娃想要套住另一个小套娃，体积至少是其 33 倍；例如大套娃体积为 10，小套娃体积为 3，前者是后者的 3.333… 倍，可以套住</li><li>一个大套娃只能套住一个小套娃，一旦套住后，小套娃不能再套其他更小的套娃，也就是说不能继续嵌套下去</li><li>当大套娃套住小套娃后，两者的体积就是大套娃的体积</li></ul><p>小棒瓜瓜有一个行李箱，它的容积是 C，希望能用行李箱装下 <strong>最多数量</strong> 的套娃，在能装下最多套娃的情况下，选择 <strong>占用空间最小</strong> 的方案。</p><p>来看一下实际的例子：</p><p>有 66 个套娃，它们的体积分别为[1,3,4,3,12,10]，行李箱的容积为 16</p><p> <strong>第一种方案</strong></p><ul><li>第三个套娃能套住第一个套娃，套住后两者体积为 4</li><li>第五个套娃能套住第二个套娃，套住后两者体积为 12</li><li>最终选择 4 个套娃，总体积为 16</li></ul><p> <strong>第二种方案</strong></p><ul><li>第二个套娃能套住第一个套娃，套住后两者体积为 3</li><li>第六个套娃能套住第四个套娃，套住后两者体积为 10</li><li>最终选择 4 个套娃，总体积为 13</li></ul><p><strong>第三种方案</strong></p><ul><li>第二个套娃能套住第一个套娃，套住后两者体积为 3</li><li>再选择第三，四个套娃，它们两个不套住其他的任何套娃，也不被别人套住，共占用体积 7</li><li>最终选择 4 个套娃，总体积为 10</li></ul><p>上述方案能带走的套娃数量是最多的，而第三种方案占用空间更小，选择第三种方案。</p><p> <strong>输入</strong></p><ul><li><p>第一行输入整数 T, ,1≤ T ≤100，表示接下来有 T 组数据</p></li><li><p>接下来有 T 行，每行表示套娃和行李箱的信息</p><ul><li>第一个整数是 n, 1≤ n ≤12，表示套娃数量</li><li>第二个整数为 C, 1≤ C ≤105，表示行李箱容积</li><li>后面跟着 n个正整数，用空格分隔，表示每个套娃的体积，第 i 个整数为 v_i, 1≤ vi ≤10000</li></ul></li></ul><p> <strong>输出</strong></p><ul><li>输出 T 行，每行两个整数，表示最多能带走多少个套娃，以及保证套娃数量最多的情况下，占用的最小空间</li></ul><p>样例 1</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">6 16 1 3 4 3 12 10</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 10</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 二进制枚举外部套娃</span></span><br><span class="line"><span class="comment"> * 2. 枚举未选中的套娃</span></span><br><span class="line"><span class="comment"> * 3. 双指针得出最小体积</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> T, n, C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; C;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)  cin &gt;&gt; a[i] ;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxcount=<span class="number">0</span>, mincap=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxstate = <span class="number">1</span>&lt;&lt;n;  <span class="comment">// 2^n方种状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始状态压缩枚举, 枚举 2^n方种状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;maxstate; ++s)&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visted</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>, cap=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (s&gt;&gt;i) &amp; <span class="number">1</span> )&#123; <span class="comment">//第 i 个外围套娃被选中</span></span><br><span class="line">                b.<span class="built_in">push_back</span>(i);</span><br><span class="line">                count++;</span><br><span class="line">                cap += a[i];</span><br><span class="line">                visted[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cap &gt; C) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; i&lt;n &amp;&amp; j&lt;b.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visted[i])&#123;</span><br><span class="line">                <span class="comment">//从未被选中的套娃里面依次判断是否可以放入外围套娃中</span></span><br><span class="line">                <span class="keyword">while</span>( j&lt;b.<span class="built_in">size</span>() &amp;&amp; a[i]*<span class="number">3</span> &gt; a[b[j]]) j++;</span><br><span class="line">                <span class="keyword">if</span>( j&lt;b.<span class="built_in">size</span>())  count++, j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新结果</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; maxcount || (count==maxcount &amp;&amp; cap &lt; mincap))&#123;</span><br><span class="line">                maxcount = count;</span><br><span class="line">                mincap = cap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxcout==<span class="number">0</span>)  mincap=<span class="number">0</span>; <span class="comment">//特例输出</span></span><br><span class="line">    cout &lt;&lt; maxcount &lt;&lt; <span class="string">&quot;　&quot;</span> &lt;&lt; mincap &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-201-部分和问题"><a href="#pa-201-部分和问题" class="headerlink" title="pa-201.部分和问题"></a><a href="https://www.papamelon.com/problem/201">pa-201.部分和问题</a></h2><p>给定 n个整数，判断是否能选出若干个数，使得它们的和恰好为 k。</p><p><strong>输入</strong></p><ul><li>多组测试数据，以 <code>EOF</code> 结束</li><li>每组测试数据由以下部分组成：<ul><li>第一行为整数 n (1≤n≤20)</li><li>第二行为 n 个整数 a_i (−10^8 ≤a_i≤ 10^8)</li><li>第三行为整数 k (−10^8 ≤k≤ 10^8)</li></ul></li><li>数据保证多组测试数据的 n 之和不超过 2020</li></ul><p><strong>输出</strong></p><ul><li>每组测试输出一行，<code>Yes</code> 表示能成功，<code>No</code> 表示失败</li></ul><p><strong>样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">4</span><br><span class="line">1 2 4 7</span><br><span class="line">13</span><br><span class="line">4</span><br><span class="line">1 2 4 7</span><br><span class="line">15</span><br><span class="line">输出</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-11-16 10:14:16</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-11-16 10:36:03</span></span><br><span class="line"><span class="comment"> * @Description: 暴力枚举，搜索，状态压缩</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxs = <span class="number">1</span> &lt;&lt; n;    <span class="comment">// 2^n方 种状态</span></span><br><span class="line">    <span class="comment">//开始状态压缩枚举, 枚举 2^n方种状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; maxs; ++s) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            <span class="keyword">if</span> ((s &gt;&gt; i) &amp; <span class="number">1</span>) sum += a[i]; <span class="comment">//第 i 个数字被选中</span></span><br><span class="line">        <span class="keyword">if</span> (sum == k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="built_in">solve</span>();</span><br><span class="line">        cout &lt;&lt; (ret ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS/BFS"></a>DFS/BFS</h1><h2 id="LC-200-岛屿数量"><a href="#LC-200-岛屿数量" class="headerlink" title="LC-200.岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">LC-200.岛屿数量</a></h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><blockquote><p>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 300<br>grid(i)(j)的值为 ‘0’ 或 ‘1’</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. dfs+备忘录</span></span><br><span class="line"><span class="comment"> * 2. 枚举未选中的套娃</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; vis;  <span class="comment">//标记数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> dc[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; g, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; ++k)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = i + dr[k];</span><br><span class="line">            <span class="keyword">int</span> c = j + dc[k];</span><br><span class="line">            <span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;=n || c&lt;<span class="number">0</span> || c&gt;=m || g[r][c]==<span class="string">&#x27;0&#x27;</span> || vis[r][c])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(g, r, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        n = g.<span class="built_in">size</span>();</span><br><span class="line">        m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vis.<span class="built_in">assign</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[i][j]==<span class="literal">false</span> &amp;&amp; g[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    <span class="built_in">dfs</span>(g, i ,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. dfs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; g, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= g.<span class="built_in">size</span>() || j &gt;= g[<span class="number">0</span>].<span class="built_in">size</span>() || g[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        g[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//上下左右</span></span><br><span class="line">        <span class="built_in">dfs</span>(g, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(g, i, j + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(g, i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(g, i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = g.<span class="built_in">size</span>(),n = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(g, i, j);</span><br><span class="line">                    res ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-42-接雨水"><a href="#LC-42-接雨水" class="headerlink" title="LC-42.接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">LC-42.接雨水</a></h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="/2021/02/21/Algorithm/Projects\Gits\hexo\myblog\source_posts\Algorithm\接雨水.png" alt="接雨水"></p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br><span class="line"></span><br><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 维护一个单调递减的栈，使用栈来存储条形块的索引下标</span></span><br><span class="line"><span class="comment"> * 遍历数组：当栈非空且h[st.top()]&lt;h[i])</span></span><br><span class="line"><span class="comment"> * 意味着栈中元素可以被弹出。弹出栈顶元素 top</span></span><br><span class="line"><span class="comment"> * 计算当前元素和栈顶元素的距离，准备进行填充操作,distance = right-left-1</span></span><br><span class="line"><span class="comment"> * 找出界定高度,height = min(h[right], h[left])-h[cur]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;h.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="comment">// 如果栈不空并且当前索引位置的高度大于栈顶高度就一直循环</span></span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; h[st.<span class="built_in">top</span>()]&lt;h[i])&#123;</span><br><span class="line">                <span class="comment">// 栈顶的小元素出栈</span></span><br><span class="line">                <span class="keyword">int</span> cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">int</span> right = i;</span><br><span class="line">                <span class="keyword">int</span> height = <span class="built_in">min</span>(h[right], h[left])-h[cur];</span><br><span class="line">                <span class="keyword">int</span> distance = right-left<span class="number">-1</span>;</span><br><span class="line">                res = res + distance * height;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双指针，一次遍历</span></span><br><span class="line"><span class="comment"> * 初始化left 指针为 0 并且right 指针为 size-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = h.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_max =<span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h[left]&lt;h[right])&#123;</span><br><span class="line">                h[left]&gt;=left_max ? (left_max=h[left]) : res +=(left_max-h[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                h[right]&gt;=right_max ? (right_max=h[right]) : res += (right_max-h[right]);</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h1><h2 id="LC-5-最长回文子串"><a href="#LC-5-最长回文子串" class="headerlink" title="LC-5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">LC-5. 最长回文子串</a></h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= s.length &lt;= 1000</code></p></li><li><p><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （一）中心扩展法</span></span><br><span class="line"><span class="comment"> * 由于回文串的长度可奇可偶，比如 “bob” 是奇数形式的回文，”noon” 就是偶数形式的回文，</span></span><br><span class="line"><span class="comment"> * 两种形式的回文都要搜索，对于奇数形式的，我们就从遍历到的位置为中心，向两边进行扩散，</span></span><br><span class="line"><span class="comment"> * 对于偶数情况，我们就把当前位置和下一个位置当作偶数行回文的最中间两个字符，然后向两边进行搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;    <span class="comment">//记录回文子串起始位置</span></span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>;      <span class="comment">//记录回文子串终止位置</span></span><br><span class="line">        <span class="keyword">int</span> mlen=<span class="number">0</span>;     <span class="comment">//记录最大回文子串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len1=<span class="built_in">expendaroundcenter</span>(s,i,i);     <span class="comment">//一个元素为中心</span></span><br><span class="line">            <span class="keyword">int</span> len2=<span class="built_in">expendaroundcenter</span>(s,i,i+<span class="number">1</span>);   <span class="comment">//两个元素为中心</span></span><br><span class="line">            mlen=<span class="built_in">max</span>(<span class="built_in">max</span>(len1,len2),mlen);</span><br><span class="line">            <span class="keyword">if</span>(mlen&gt;end-start+<span class="number">1</span>)&#123;</span><br><span class="line">                start=i-(mlen<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                end=i+mlen/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,mlen);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expendaroundcenter</span><span class="params">(string s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//计算以left和right为中心的回文串长度</span></span><br><span class="line">        <span class="keyword">int</span> L=left;</span><br><span class="line">        <span class="keyword">int</span> R=right;</span><br><span class="line">        <span class="keyword">while</span>(L&gt;=<span class="number">0</span> &amp;&amp; R&lt;s.<span class="built_in">length</span>() &amp;&amp; s[R]==s[L])&#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R-L<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （一）中心扩展法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//以 s[left] s[right] 为中心向两端扩散的回文串</span></span><br><span class="line">    <span class="function">string <span class="title">expendaroundcenter</span><span class="params">(string &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//防止索引越界</span></span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.<span class="built_in">size</span>()&amp;&amp;s[left]==s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left+<span class="number">1</span>,right-left<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string s1=<span class="built_in">expendaroundcenter</span>(s,i,i);</span><br><span class="line">            string s2=<span class="built_in">expendaroundcenter</span>(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//res=longest(res,s1,s1)</span></span><br><span class="line">            res=res.<span class="built_in">size</span>()&gt;s1.<span class="built_in">size</span>()?res:s1;</span><br><span class="line">            res=res.<span class="built_in">size</span>()&gt;s2.<span class="built_in">size</span>()?res:s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （二）动态规划</span></span><br><span class="line"><span class="comment"> * 1.确定dp数组（dp table）以及下标的含义</span></span><br><span class="line"><span class="comment"> * 2.确定递推公式</span></span><br><span class="line"><span class="comment"> * 3.dp数组如何初始化</span></span><br><span class="line"><span class="comment"> * 4.确定遍历顺序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在确定递推公式时，就要分析如下几种情况。</span></span><br><span class="line"><span class="comment"> * 整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</span></span><br><span class="line"><span class="comment"> * 当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</span></span><br><span class="line"><span class="comment"> * 当s[i]与s[j]相等时，这就复杂一些了，又有如下三种情况</span></span><br><span class="line"><span class="comment"> *  情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</span></span><br><span class="line"><span class="comment"> *  情况二：下标i 与 j相差为1，例如aa，也是回文子串</span></span><br><span class="line"><span class="comment"> *  情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，</span></span><br><span class="line"><span class="comment"> *  我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，</span></span><br><span class="line"><span class="comment"> *  这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *     —— —— —— —— —  —— —— —— ——</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *    |             |  dp[i][j]  |</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *     —— —— —— —— —  —— —— —— ——</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *    |dp[i+1][j-1] |            |</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *     —— —— —— —— —  —— —— —— ——</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本题目是少有的动态规划非最优解的问题 （时间 O(n^2) ！空间O(n^2)）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，</span></span><br><span class="line">        <span class="comment">// 如果是dp[i][j]为true，否则为false。</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxlenth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j]由dp[i+1][j-1]确定，因此从左下向右上遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;    <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlenth) &#123;</span><br><span class="line">                    maxlenth = j - i + <span class="number">1</span>;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以上代码是为了凸显情况一二三，当然是可以简洁一下的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxlenth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlenth) &#123;</span><br><span class="line">                    maxlenth = j - i + <span class="number">1</span>;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left, maxlenth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JZ-47-礼物的最大价值"><a href="#JZ-47-礼物的最大价值" class="headerlink" title="JZ-47.礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">JZ-47.礼物的最大价值</a></h2><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。</p><p>你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。</p><p>给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p>**示例 **</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><blockquote><p> 提示：<br>0 &lt; grid.length &lt;= 200<br>0 &lt; grid[0].length &lt;= 200</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * dp状态定义：dp[i][j]表示从“start”位置走到(i,j)位置的最大权重 </span></span><br><span class="line"><span class="comment"> * dp转移方程：dp[i][j] = max(dp[i-1][j], dp[i][j-1])+grid[i][j] 只能从上面dp[i-1][j] 或 左边dp[i][j-1] 走过来</span></span><br><span class="line"><span class="comment"> * dp初始化：</span></span><br><span class="line"><span class="comment"> *  - dp[0][0] = grid[0][0]</span></span><br><span class="line"><span class="comment"> *  - dp[0][j] = dp[0][j-1] + grid[0][j]</span></span><br><span class="line"><span class="comment"> *  - dp[i][0] = dp[i-1][0] + grid[i][0]</span></span><br><span class="line"><span class="comment"> * 最终结果：res = dp[m-1][n-1] </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=grid.<span class="built_in">size</span>(), n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector &lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt; (n,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)  dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; ++i)  dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; ++j)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res=dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JZ-63-股票最大利润"><a href="#JZ-63-股票最大利润" class="headerlink" title="JZ-63.股票最大利润"></a><a href>JZ-63.股票最大利润</a></h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p>限制：</p><blockquote><p>0 &lt;= 数组长度 &lt;= 10^5</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *  maxValue保存遍历到当前日期所能达到的最大利润</span></span><br><span class="line"><span class="comment">        *  minValue保存数组中最低的股票价格</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>, minValue = INT_MAX;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="comment">// 更新股票最大利润</span></span><br><span class="line">            maxValue = <span class="built_in">max</span>(maxValue, price - minValue);</span><br><span class="line">            <span class="comment">// 更新最低股票价格</span></span><br><span class="line">            minValue = <span class="built_in">min</span>(minValue, price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 判空</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *  创建动态规划数组，全部初始为0</span></span><br><span class="line"><span class="comment">        *  dp[i]保存的是前i天的股票最大利润</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// minValue保存数组中股票的最低价格</span></span><br><span class="line">        <span class="keyword">int</span> minValue = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 更新最低股票价格</span></span><br><span class="line">            minValue = <span class="built_in">min</span>(minValue, prices[i]);</span><br><span class="line">            <span class="comment">// 更新动态规划数组</span></span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], prices[i] - minValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="pa-185-种植棒瓜"><a href="#pa-185-种植棒瓜" class="headerlink" title="pa-185.种植棒瓜"></a><a href="https://www.papamelon.com/problem/185">pa-185.种植棒瓜</a></h2><p>小棒瓜瓜在自己的果园中种植棒瓜。</p><p>每一天他都能掌握一定的种植经验，经验越丰富，种植出来的棒瓜越甜美。</p><p>但是小棒瓜瓜的记性不太好，时间一长，曾经积累下来的经验就会忘掉。</p><p>假设他的记忆力为 K，表示能记住 K 天内的事情。也就是说，在第 i 天，他能记住第 i-K, i-K+1, i-K+2 … i-1 天内的所有事情。</p><p>完成第 i 天的种植工作后，小棒瓜瓜能获得经验值 A_i</p><p>在进行第 i 天工作时，他拥有的全部经验为 A_{i-K} + A_{i-K+1} + A_{i-K+2} … + A_{i-1} 。</p><p>请问哪一天，小棒瓜瓜的种植经验是最丰富的？如果有多天的种植经验都是最丰富的，选最靠后的那天。</p><p><strong>输入</strong></p><p>多组测试数据，以 EOF 结束</p><p>每组测试数据占一行：</p><p>第一个整数是 n(1≤n≤10^5)，表示有 n 天</p><p>第二个整数是 K(1≤K≤n)，表示记忆力</p><p>后面跟着 n 个整数，第 i 个整数为 A_i(1≤A_i≤100)</p><p>数据保证：多组数据的 n 之和不超过 10^5</p><p><strong>输出</strong></p><p>输出若干行，每行一个整数，表示哪一天小棒瓜瓜的种植经验最丰富</p><p><strong>提示</strong></p><p>天数从 1 到 n 进行编号</p><blockquote><p>样例 1<br>输入<br>4 2<br>1 2 2 3</p><p>输出<br>4</p><p>提示<br>一组测试数据。<br>一共 4 天，记忆力为 2。<br>第一天种植时，掌握的经验为 0。<br>第二天种植时，掌握的经验为 1。<br>第三天种植时，掌握的经验为 1 + 2 = 3。<br>第四天种植时，掌握的经验为 2 + 2 = 4。<br>第四天的种植经验最丰富。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 状态定义: f[i] 表示执行第 i 天种植任务时掌握的经验总和</span></span><br><span class="line"><span class="comment"> * 由题意可知:</span></span><br><span class="line"><span class="comment"> * - f[i] = A[i-K] + A[i-K+1] ... + A[i-1]</span></span><br><span class="line"><span class="comment"> * - f[i+1] = A[i-K+1] + A[i-K+2] ... + A[i]</span></span><br><span class="line"><span class="comment"> * 上面两个式子相减，去掉同类项目可得：f[i+1] - f[i] = A[i] - A[i-K] </span></span><br><span class="line"><span class="comment"> * 上面式子左右移项可得：f[i+1] = f[i] + A[i] - A[i-K]</span></span><br><span class="line"><span class="comment"> * 到这里，我们得到了递推公式</span></span><br><span class="line"><span class="comment"> * 注意边界情况：前 K+1 天，f[i] = A[1] + A[2] ... + A[i-1]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; k)&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>, maxsum=<span class="number">0</span>, sum=<span class="number">0</span>, a[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre = i-k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre&gt;<span class="number">0</span>) sum-=a[pre];  <span class="comment">//sum至多为k个元素的累加和</span></span><br><span class="line">            <span class="keyword">if</span>(sum&gt;=maxsum)&#123;</span><br><span class="line">                maxsum=sum;</span><br><span class="line">                res=i;</span><br><span class="line">            &#125;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            sum+=a[i];  </span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LC-97-字符串交错"><a href="#LC-97-字符串交错" class="headerlink" title="LC-97.字符串交错"></a><a href="https://leetcode-cn.com/problems/interleaving-string/">LC-97.字符串交错</a></h2><p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</p><p>两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p><blockquote><p>s = s1 + s2 + … + sn</p><p>t = t1 + t2 + … + tm</p><p>|n - m| &lt;= 1</p><p>交错 是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …</p></blockquote><p><strong>提示</strong>：a + b 意味着字符串 a 和 b 连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">输入：s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;</span><br><span class="line">输出：true</span><br><span class="line">i/j: 0 a a b c c e</span><br><span class="line">  0[T,T,F,F,F,F,F]</span><br><span class="line">  b [F,T,T,F,F,F,F]</span><br><span class="line">  a[F,T,T,F,F,F,F]</span><br><span class="line">  c[F,F,T,T,T,T,T]</span><br><span class="line">  c[F,F,F,F,T,F,T]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 状态定义：f[i][j]表示 s1的前i个元素和s2的前j个元素是否能交错组成 s3的前i+j个元素</span></span><br><span class="line"><span class="comment"> * 转移方程：f[i][j] = (f[i-1][j] &amp;&amp; s1[i-1]==s3[i+j-1]) || (f[i][j-1] &amp;&amp; s2[j-1]==s3[i+j-1]);</span></span><br><span class="line"><span class="comment"> * 初始化：</span></span><br><span class="line"><span class="comment"> *  - f[0][0] = 1</span></span><br><span class="line"><span class="comment"> *  - f[i][0] = f[i-1][0]  &amp;&amp; s1[i-1]==s3[i-1];</span></span><br><span class="line"><span class="comment"> *  - f[0][j] = f[0][j-1]  &amp;&amp; s2[j-1]==s3[j-1];</span></span><br><span class="line"><span class="comment"> * 最终结果：f[n][m] </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s1.<span class="built_in">size</span>(), m=s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>( n+m != s3.<span class="built_in">size</span>() )  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector &lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">f</span>(n+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)  f[i][<span class="number">0</span>]= f[i<span class="number">-1</span>][<span class="number">0</span>] &amp;&amp; s1[i<span class="number">-1</span>]==s3[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; ++j)  f[<span class="number">0</span>][j]= f[<span class="number">0</span>][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>]==s3[j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; ++j)&#123;</span><br><span class="line">                f[i][j] = (f[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]) || (f[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="pa-39-数字三角形"><a href="#pa-39-数字三角形" class="headerlink" title="pa-39.数字三角形"></a><a href="https://www.papamelon.com/problem/39">pa-39.数字三角形</a></h2><p>下方是一个数字金字塔。</p><p>请查找从 <strong>最高点</strong> 到 <strong>底部任意处结束</strong> 的路径，使路径经过数字的和最大。</p><p>每一步可以走到左下方或右下方的点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">       7</span><br><span class="line">      3   8</span><br><span class="line">    8   1   0</span><br><span class="line">  2   7   4   4</span><br><span class="line">4   5   2   6   5</span><br><span class="line">解释：路径 7-&gt;3-&gt;8-&gt;7-&gt;5 产生的和最大</span><br></pre></td></tr></table></figure><p><strong>输入</strong></p><ul><li>第一个行一个正整数 r(1≤<em>r</em>≤1000)，表示行的数目。</li><li>下面 r行，每行 r个数字，用空格分隔，表示该行的数字。</li></ul><p><strong>输出</strong></p><ul><li>一行，一个整数，表示最大的路径和。</li></ul><p><strong>样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">3 8</span><br><span class="line">8 1 0</span><br><span class="line">2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br><span class="line">输出</span><br><span class="line">30</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 状态定义：dp[i]到最底层第i个元素的路径和</span></span><br><span class="line"><span class="comment"> * 状态转移：每层最左，最右只有一种选择，中间元素有两种选择</span></span><br><span class="line"><span class="comment"> * 边界条件： dp[0]=a[0][0]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[r];   <span class="comment">//底层元素个数，接下来动态更新dp</span></span><br><span class="line">    dp[<span class="number">0</span>]=a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;r; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == i)     <span class="comment">//塔层末尾值只能选择左上方元素</span></span><br><span class="line">                dp[j] = dp[j<span class="number">-1</span>] + a[i][j];  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>)  <span class="comment">//塔层首位值只能选择正上方元素</span></span><br><span class="line">                dp[j] += a[i][<span class="number">0</span>];  </span><br><span class="line">            <span class="keyword">else</span>            <span class="comment">//中间值选择正上方和左上方元素最大值</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j<span class="number">-1</span>]) + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(dp, dp+r);</span><br><span class="line">    <span class="keyword">return</span> dp[r<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;r; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; ++j)&#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">solve</span>();</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-130-合并两个序列II"><a href="#pa-130-合并两个序列II" class="headerlink" title="pa-130.合并两个序列II"></a><a href="https://www.papamelon.com/problem/130">pa-130.合并两个序列II</a></h2><p>给定两个正整数序列 a,b 长度分别为 A,B 我们要将它们合并为一个新序列，同时保证 a 的元素相对顺序不变，b 的元素相对顺序不变，例如：</p><ul><li>a=[1,2,3]</li><li>b=[4,5,6]</li><li>一种合法的合并结果为 [1,2,4,3,5,6]，因为 [1,2,3]相对顺序不变，[4,5,6]相对顺序也没变</li><li>一种 <strong>不合法</strong> 的合并结果为 [2,4,1,3,5,6]因为 [1,2,3] 的变为了 [2,1,3]</li></ul><p>现在让我们计算一下，一种有多少种合并方案</p><p><strong>输入</strong></p><ul><li>第一行输入 T, 1≤T≤10000，表示接下来有 T组测试数据</li><li>接下来 T行，每行两个整数 A,B, 0≤A,B≤1000，分别表示两个序列的长度</li></ul><p><strong>输出</strong></p><ul><li>输出 T行，每行一个正整数，表示有多少种合并方案</li><li>结果对 1e9+7 取模</li></ul><p><strong>提示</strong></p><ul><li>两个序列的长度都可能为 0</li><li>如果两者长度都为 0，答案为 1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: DP</span></span><br><span class="line"><span class="comment"> * 状态：f(a, b) 用掉了a个红球，b个蓝球，有多少种放置关系</span></span><br><span class="line"><span class="comment"> * 转移：f(a, b) = f(a-1, b) + f(a, b-1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f)); <span class="comment">//初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; ++i) f[<span class="number">0</span>][i] = f[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//边界条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;N; ++j)&#123;</span><br><span class="line">            f[i][j] = (f[i<span class="number">-1</span>][j] + f[i][j<span class="number">-1</span>]) % base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        cout &lt;&lt; f[a][b] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-131-合并两个序列III"><a href="#pa-131-合并两个序列III" class="headerlink" title="pa-131.合并两个序列III"></a><a href="https://www.papamelon.com/problem/131">pa-131.合并两个序列III</a></h2><p>给定两个正整数序列 a,b 长度分别为 A,B 我们要将它们合并为一个新序列，同时保证 a 的元素相对顺序不变，b 的元素相对顺序不变，例如：</p><ul><li>a=[1,2,3]</li><li>b=[4,5,6]</li><li>一种合法的合并结果为 [1,2,4,3,5,6]，因为 [1,2,3]相对顺序不变，[4,5,6]相对顺序也没变</li><li>一种 <strong>不合法</strong> 的合并结果为 [2,4,1,3,5,6]，因为 [1,2,3] 的变为了 [2,1,3]</li></ul><p>现在让我们计算一下，一种有多少种合并方案</p><p><strong>输入</strong></p><ul><li>第一行输入 T, 1≤T≤10000，表示接下来有 T组测试数据</li><li>接下来 T行，每行两个整数 A,B, 0≤A,B≤<strong>1e5</strong>，分别表示两个序列的长度</li></ul><p><strong>输出</strong></p><ul><li>输出 T行，每行一个正整数，表示有多少种合并方案</li><li>结果对 1e9+7 取模</li></ul><p><strong>提示</strong></p><ul><li>两个序列的长度都可能为 0</li><li>如果两者长度都为 0，答案为 1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 组合数学</span></span><br><span class="line"><span class="comment"> * (x/y)%m = x*y^(m-2)</span></span><br><span class="line"><span class="comment"> * 快速幂：二分/位运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line">ll f[<span class="number">2</span>*N];  <span class="comment">// f[i]等于 i 的阶乘</span></span><br><span class="line">ll g[<span class="number">2</span>*N];  <span class="comment">// g[i]等于 i 的阶乘的 mod - 2 次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">power</span><span class="params">(ll x, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll tmp = <span class="built_in">power</span>(x, m/<span class="number">2</span>);</span><br><span class="line">    tmp = (tmp * tmp) % mod;</span><br><span class="line">    <span class="keyword">if</span>(m &amp; <span class="number">1</span>) tmp = tmp * x %mod;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>, g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">2</span>*N; ++i)&#123;</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>] * i % mod;</span><br><span class="line">        g[i] = <span class="built_in">power</span>(f[i], mod<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * C(A, A+B) </span></span><br><span class="line"><span class="comment">         * = (A+B) * (A+B-1) .. * (B+1) / A! % MOD</span></span><br><span class="line"><span class="comment">         * = (A+B)! / B! / A! % MOD</span></span><br><span class="line"><span class="comment">         * = (A+B)! * B!^(MOD-2) * A!^(MOD-2) % MOD</span></span><br><span class="line"><span class="comment">         * f[A+B] * g[B] % MOD * g[A] % MOD</span></span><br><span class="line"><span class="comment">         */</span>        </span><br><span class="line">        cout &lt;&lt; f[a+b] * g[b] % mod * g[a] % mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高频面试系列"><a href="#高频面试系列" class="headerlink" title="高频面试系列"></a>高频面试系列</h1><h2 id="atoi-atof"><a href="#atoi-atof" class="headerlink" title="atoi atof"></a>atoi atof</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//字符型转浮点型</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myatof</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">double</span> n = <span class="number">0</span>,m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;-&#x27;</span>)&#123;<span class="comment">//处理符号</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*(s + i) != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(*(s + i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *(s + i) &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;<span class="comment">//处理整数部分</span></span><br><span class="line">            n = n * <span class="number">10</span> + (*(s + i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            i ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        i ++;</span><br><span class="line">        <span class="keyword">while</span>(*(s + i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *(s + i) &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;<span class="comment">//处理小数部分</span></span><br><span class="line">            m = m * <span class="number">10</span> + (*(s + i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            k *= <span class="number">10</span>;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        d = n + m / k ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        d = <span class="number">-1</span> * (n + m / k);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符型转整形</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myatoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>,i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;-&#x27;</span>)&#123;<span class="comment">//处理符号</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*(s + i) != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *(s + i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *(s + i) &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        n = n * <span class="number">10</span> + (*(s + i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        i ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        n = n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n = <span class="number">-1</span> * n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// char s[10];</span></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">char</span> ss[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Input a string!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="comment">// cout&lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; myatof(s.c_str())&lt;&lt;endl;</span></span><br><span class="line">    cout &lt;&lt;<span class="built_in">myatof</span>(s.<span class="built_in">c_str</span>())&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断合法IP"><a href="#判断合法IP" class="headerlink" title="判断合法IP"></a>判断合法IP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_valid_ip</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> section = <span class="number">0</span>; <span class="comment">//每一节的十进制值</span></span><br><span class="line">    <span class="keyword">int</span> dot = <span class="number">0</span>;     <span class="comment">//几个点分隔符</span></span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">-1</span>;   <span class="comment">//每一节中上一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (*ip)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*ip == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            dot++;</span><br><span class="line">            <span class="keyword">if</span> (dot &gt; <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (section &gt;= <span class="number">0</span> &amp;&amp; section &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">                section = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*ip &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *ip &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            section = section * <span class="number">10</span> + *ip - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = *ip;</span><br><span class="line">        ip++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (section &gt;= <span class="number">0</span> &amp;&amp; section &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">3</span> == dot)&#123;</span><br><span class="line">            section = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;IP address success!\n&quot;);</span></span><br><span class="line">            <span class="comment">// printf(&quot;true&quot;);</span></span><br><span class="line">            <span class="comment">//printf (&quot;%d\n&quot;,dot);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else printf(&quot;false&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> res = is_valid_ip(<span class="string">&quot;92.49.01.133&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a><a href="https://blog.csdn.net/tingyun_say/article/details/52343897">约瑟夫环</a></h2><p><strong>在一间房间总共有n个人（下标0～n-1），只能有最后一个人活命。</strong></p><p>按照如下规则去排除人：</p><ul><li>所有人围成一圈</li><li>顺时针报数，每次报到q的人将被排除掉</li><li>被排除掉的人将从房间内被移走</li><li>然后从被kill掉的下一个人重新报数，继续报q，再清除，直到剩余一人</li></ul><p><img src="/2021/02/21/Algorithm/Projects\Gits\hexo\myblog\source_posts\Algorithm\josephus.png" alt="josephus"></p><p><code>(old - q) % n = new</code>  ==&gt;  <code>old = (new + q) % n</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: 约瑟夫环</span></span><br><span class="line"><span class="comment"> * old = josephus(n), new = josephus(n-1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">josephus</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">josephus</span>(n<span class="number">-1</span>, q)+q)%n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">josephus</span>(n, q);</span><br><span class="line">    cout &lt;&lt; res+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找素数"><a href="#寻找素数" class="headerlink" title="寻找素数"></a>寻找素数</h2><p> <a href="https://leetcode-cn.com/problems/count-primes/">LC-204. 计数质数</a></p><p>统计所有小于非负整数 <em>n</em> 的质数的数量。[如果⼀个数如果只能被 1 和它本⾝整除，那么这个数就是素数]</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 5 * 10^6</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Eratosthenes筛选法</span></span><br><span class="line"><span class="comment"> * 从2开始遍历到n</span></span><br><span class="line"><span class="comment"> * i=2,并排除2的倍数</span></span><br><span class="line"><span class="comment"> * i=3,并排除3的倍数</span></span><br><span class="line"><span class="comment"> * i=5,并排除5的倍数</span></span><br><span class="line"><span class="comment"> * 。。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始默认所有数为质数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i) &#123;</span><br><span class="line">                    <span class="comment">//排除i的倍数</span></span><br><span class="line">                    res[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="模幂运算"><a href="#模幂运算" class="headerlink" title="模幂运算"></a>模幂运算</h2><p><a href="https://leetcode-cn.com/problems/super-pow/">LC-372. 超级次方</a></p><p>你的任务是计算 <code>ab</code> 对 <code>1337</code> 取模，<code>a</code> 是一个正整数，<code>b</code> 是一个非常大的正整数且会以数组形式给出。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = [3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = [1,0]</span><br><span class="line">输出：1024</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 1, b = [4,3,3,8,5,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2147483647, b = [2,0,0]</span><br><span class="line">输出：1198</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a &lt;= 231 - 1</code></li><li><code>1 &lt;= b.length &lt;= 2000</code></li><li><code>0 &lt;= b[i] &lt;= 9</code></li><li><code>b</code> 不含前导 0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1337</span>;</span><br><span class="line">    <span class="comment">//求 a 的 k 次方， 对 mod 取余</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">modPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        a %= mod;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            res *= a;</span><br><span class="line">            res %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">size</span>() == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = b.<span class="built_in">back</span>();</span><br><span class="line">        b.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 将原问题化简，缩小规模递归求解</span></span><br><span class="line">        <span class="keyword">int</span> part1 = <span class="built_in">modPow</span>(a, last);</span><br><span class="line">        <span class="keyword">int</span> part2 = <span class="built_in">modPow</span>(<span class="built_in">superPow</span>(a, b), <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 合并出结果</span></span><br><span class="line">        <span class="keyword">return</span> (part1 * part2)%mod;</span><br><span class="line">        <span class="comment">// return (modPow(a, last) * modPow(superPow(a, b), 10)) % mod;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1337</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">modPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        a %= mod;</span><br><span class="line">        <span class="comment">// k 是奇数</span></span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>)  <span class="keyword">return</span> (a * <span class="built_in">modPow</span>(a, k - <span class="number">1</span>)) % mod;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// k 是偶数</span></span><br><span class="line">            <span class="keyword">int</span> sub = <span class="built_in">modPow</span>(a, k / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> (sub * sub) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="pa-3-寻找最靠左的匹配子串-1"><a href="#pa-3-寻找最靠左的匹配子串-1" class="headerlink" title="pa-3.寻找最靠左的匹配子串"></a>pa-3.寻找最靠左的匹配子串</h2><p><a href="#%5Bpa-3.%E5%AF%BB%E6%89%BE%E6%9C%80%E9%9D%A0%E5%B7%A6%E7%9A%84%E5%8C%B9%E9%85%8D%E5%AD%90%E4%B8%B2%5D(https://www.papamelon.com/problem/3)">跳转</a></p><h2 id="pa-4-长度为-K-的回文子串"><a href="#pa-4-长度为-K-的回文子串" class="headerlink" title="pa-4.长度为 K 的回文子串"></a><a href="https://www.papamelon.com/problem/4">pa-4.长度为 K 的回文子串</a></h2><p><img src="/2021/02/21/Algorithm/pa-4.png" alt="pa-4"></p><p>样例 1</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6 3</span><br><span class="line">acdcxb</span><br><span class="line">6 5</span><br><span class="line">acdcxb</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试用例 20/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left]!=s[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> left++,right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+k<span class="number">-1</span>&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i,i+k<span class="number">-1</span>))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 字符串哈希 O(1)</span></span><br><span class="line"><span class="comment">* https://www.bilibili.com/video/BV1Tv41157YX?p=5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line">ull p[N];           <span class="comment">//k的幂次</span></span><br><span class="line">ull h0[N], h1[N];   <span class="comment">// 从左到右扫描，维护所有前缀的映射值（哈希值）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  h0[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">    h0[i] = h0[i - <span class="number">1</span>] * P + s[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">//idx 对应的是 s 的 n - i + 1 下标</span></span><br><span class="line">    <span class="keyword">int</span> idx = n - i + <span class="number">1</span>;</span><br><span class="line">    h1[i] = h1[i - <span class="number">1</span>] * P + s[idx];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">query0</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> h0[r] - h0[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function">ull <span class="title">query1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> h1[r] - h1[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  cin&gt;&gt;s;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">init</span>();   <span class="comment">//预处理哈希值，幂次</span></span><br><span class="line">  <span class="comment">//枚举回文串的左端点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + m - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> half = m &gt;&gt; <span class="number">1</span>;   <span class="comment">//int half = m/2;</span></span><br><span class="line">    ull ret1 = <span class="built_in">query0</span>(i, i + half - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = n - (i + m - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = n - (i + m - half) + <span class="number">1</span>;</span><br><span class="line">    ull ret2 = <span class="built_in">query1</span>(l, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret1 == ret2) &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  cin&gt;&gt;T;</span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-29-回文平方数"><a href="#pa-29-回文平方数" class="headerlink" title="pa-29.回文平方数"></a><a href="https://www.papamelon.com/problem/29">pa-29.回文平方数</a></h2><p>Palindromic Squares</p><p>回文数是指从左向右念和从右向左念都一样的数。如 1232112321 就是一个典型的回文数。</p><p>给定一个用十进制正整数 B<em>B</em>，在 [1, 300]中寻找所有特殊的整数 <em>X</em>，满足 X^2用 B进制表示时是回文数。</p><p>其中，2≤B≤20。大于 9 的数，用字母表示。例如用 A表示 10，B表示 11，用第 n个大写字母表示 n+9。</p><p> <strong>输入</strong></p><ul><li>输入一个正整数 B, 2≤B≤20</li></ul><p><strong>输出</strong></p><ul><li>输出多行，每行分左右两部分，用空格隔开<ul><li>左边的部分是 [1,300] 内的一个正整数 X的 B进制表示</li><li>右边的部分是 X^2 的 B进制表示</li></ul></li><li>输出的数据按左部分的十进制值从小到大排序</li></ul><p>**样例 **</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">2 4</span><br><span class="line">3 9</span><br><span class="line">11 121</span><br><span class="line">22 484</span><br><span class="line">26 676</span><br><span class="line">101 10201</span><br><span class="line">111 12321</span><br><span class="line">121 14641</span><br><span class="line">202 40804</span><br><span class="line">212 44944</span><br><span class="line">264 69696</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 十进制转 K 进制：短除法</span></span><br><span class="line"><span class="comment"> * 实际上就是一个不断模 K 除 K 的过程。我们可以举一个实际的例子，将 345 转成 6 进制数</span></span><br><span class="line"><span class="comment"> * 346÷6=57...4</span></span><br><span class="line"><span class="comment"> * 57÷6=9...3</span></span><br><span class="line"><span class="comment"> * 9÷6=1...3</span></span><br><span class="line"><span class="comment"> * 1÷6=0...1</span></span><br><span class="line"><span class="comment"> * 当商等于 0 时算法停止，然后我们将余数逆序保存，得到 1334，这就是对应的 6 进制表达</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="comment">//回文串判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left]!=s[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> left++,right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进制转换</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">char</span>&gt; <span class="title">tobint</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">char</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=a%b;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;<span class="number">9</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&#x27;A&#x27;</span>+tmp<span class="number">-10</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//int强转char--&gt; char(intval+48)</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in"><span class="keyword">char</span></span>(tmp+<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        a=a/b; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">300</span>;++i)&#123;</span><br><span class="line">        vector&lt;<span class="keyword">char</span>&gt; vec1=<span class="built_in">tobint</span>(i*i,b);</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="built_in">check</span>(vec1,<span class="number">0</span>,vec1.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">char</span>&gt; vec0=<span class="built_in">tobint</span>(i,b);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it0=vec0.<span class="built_in">begin</span>();it0!=vec0.<span class="built_in">end</span>();++it0)&#123;</span><br><span class="line">                cout&lt;&lt;*it0;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it1=vec1.<span class="built_in">begin</span>();it1!=vec1.<span class="built_in">end</span>();++it1)&#123;</span><br><span class="line">                cout&lt;&lt;*it1;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-30-双重回文数"><a href="#pa-30-双重回文数" class="headerlink" title="pa-30.双重回文数"></a><a href="https://www.papamelon.com/problem/30/submissions">pa-30.双重回文数</a></h2><p>Dual Palindromes</p><p>从左往右读和从右往左读都一样的数字叫做 <strong>回文数</strong>。例如，12321就是一个回文数，而 77778 就不是。</p><p>当然，回文数的首和尾都应是非零的，因此 0220不是回文数。</p><p>有一些数，例如 21，在十进制时不是回文数，但在其它进制，如二进制时为 10101时是回文数。</p><p>给定两个十进制数 n,s，然后找出前 n个满足大于 s且在不少于两种进制（二进制至十进制）上是回文数的十进制数。</p><p>本问题的解决方案不需要使用大于 32 位的整型数</p><p><strong>输入</strong></p><ul><li>只有一行，用空格隔开的两个正整数 n,s, 1≤<em>n</em>≤15,1≤<em>s</em>≤9999。</li></ul><p><strong>输出</strong></p><ul><li>n行, 每行一个满足上述要求的数，并按从小到大的顺序输出。</li></ul><p>样例 1</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 25</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 s+1 开始枚举</span></span><br><span class="line"><span class="comment"> * 对于每个数字，从二进制到十进制枚举，将该数转换为对应进制下的值，再看看这个值是否为回文数</span></span><br><span class="line"><span class="comment"> * 如果有至少两个进制下的值是回文数，该数就是双重回文数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="comment">//回文串判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left]!=s[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> left++,right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进制转换</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tobint</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(a%b);</span><br><span class="line">        a=a/b; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力枚举</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>,k=<span class="number">0</span>;k&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;=<span class="number">10</span>&amp;&amp;count&lt;<span class="number">2</span>; ++j)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec = <span class="built_in">tobint</span>(i,j);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(vec, <span class="number">0</span>, vec.<span class="built_in">size</span>()<span class="number">-1</span>))  count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">2</span>)&#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-27-挤牛奶"><a href="#pa-27-挤牛奶" class="headerlink" title="pa-27.挤牛奶"></a><a href="https://www.papamelon.com/problem/27/submissions">pa-27.挤牛奶</a></h2><p>这是一个关于农夫和奶牛的问题，直接来看一个实际的例子：</p><ul><li>第一个农民在 [300, 1000) 秒给奶牛挤奶</li><li>第二个农民在 [700, 1200) 秒给奶牛挤奶</li><li>第三个农民在 [1500, 2100) 秒给奶牛挤奶</li></ul><p>期间最长的至少有一个农民在挤奶的连续时间为 900 秒 (也就是 [300, 1200) 秒)。</p><p>而最长的无人挤奶的连续时间为 300 秒 (也就是 [1200, 1500) 秒)。</p><p>你的任务是编一个程序，读入 n个农民的工作时间列表，计算以下两点(均以秒为单位):</p><ul><li>最长至少有一人在挤奶的时间段。</li><li>最长的无人挤奶的时间段。（从有人挤奶开始算起）</li></ul><p><strong>输入</strong></p><ul><li>第一行一个正整数 n, 1 ≤<em>n</em>≤5000</li><li>接下来 n行，每行两个非负整数 l,r，表示一个农民的工作时间。</li></ul><p><strong>输出</strong></p><ul><li>一行，两个整数，即题目所要求的两个答案。</li></ul><p>**样例 **</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">300 1000</span><br><span class="line">700 1200</span><br><span class="line">1500 2100</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">900 300</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  【经典的区间合并问题】</span></span><br><span class="line"><span class="comment"> * 我们把农民工作的时候看作区间，每个区间用 [start_i, end_i) 表示</span></span><br><span class="line"><span class="comment"> * 对所有区间按左端点从小到大排序</span></span><br><span class="line"><span class="comment"> * 挨个遍历这些区间，并且维护一个 “当前合并区间” S，用 [resa, reab) 表示 S 的左右端点</span></span><br><span class="line"><span class="comment"> * 当遍历到第一个区间的时候，它就是 S，即 resa=start_0, resb=end_0</span></span><br><span class="line"><span class="comment"> * 当遍历到一个新区间，可能出现两种情况：</span></span><br><span class="line"><span class="comment"> *    start_i &lt;= resb, 合并区间 S，并更新右端点，resb=max(end_i, resb)</span></span><br><span class="line"><span class="comment"> *    start_i &gt; resb,  将 S 保存下来,重置区间S的左右端点，resa=start_i, resb=end_i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector &lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; ma, mi;</span><br><span class="line"><span class="keyword">int</span> resa, resb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    resa=vec[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    resb=vec[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    ma.<span class="built_in">push_back</span>(resb-resa);</span><br><span class="line">    mi.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i][<span class="number">0</span>] &lt;= resb)&#123;</span><br><span class="line">            resb=<span class="built_in">max</span>(vec[i][<span class="number">1</span>],resb);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ma.<span class="built_in">push_back</span>(resb-resa);</span><br><span class="line">            mi.<span class="built_in">push_back</span>(vec[i][<span class="number">0</span>]-resb);</span><br><span class="line">            resa=vec[i][<span class="number">0</span>];</span><br><span class="line">            resb=vec[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ma.<span class="built_in">push_back</span>(vec[n<span class="number">-1</span>][<span class="number">1</span>]-vec[n<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">    cout&lt;&lt;*<span class="built_in">max_element</span>(ma.<span class="built_in">begin</span>(),ma.<span class="built_in">end</span>()) &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; *<span class="built_in">max_element</span>(mi.<span class="built_in">begin</span>(),mi.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line">        cin &gt;&gt; start &gt;&gt; end;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(&#123;start, end&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-19-后缀0"><a href="#pa-19-后缀0" class="headerlink" title="pa-19.后缀0"></a><a href="https://www.papamelon.com/problem/19">pa-19.后缀0</a></h2><p>小棒瓜瓜得到了一个正整数 n，他需要计算 n，即要计算 1 * 2 * 3 * 4 … * n。最后让我们统计一下，这个结果有多少个后缀 0，也就是从结果的末尾往前数有多少个连续的 0。</p><p><strong>输入</strong></p><p>第一行是整数 T, 1≤T≤1000，表示接下来有 T 组数据</p><p>接下来有 TT 行，每行一个整数 n, 1≤n≤1000，表示要我们统计 n! 的后缀 0 数量</p><p><strong>输出</strong></p><p>输出 T 行，每行一个整数，表示 n! 的后缀 0 的数量</p><p>样例 1<br>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><blockquote><p> 提示<br>4 的阶乘是 24，后缀 0 数量为 0<br>8 的阶乘为 40320，后缀 0 的数量为 1</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 容斥原理</span></span><br><span class="line"><span class="comment"> * 有一对【2，5】才能产生一个 0</span></span><br><span class="line"><span class="comment"> * 在每 5 个数为一组的区间， 2^x  5^y  ====&gt; x &gt; y</span></span><br><span class="line"><span class="comment"> * 最后求[0,n]中 5 的幂次方的个数 5^a, 25^b, 125^c 625^d</span></span><br><span class="line"><span class="comment"> * 后缀0的个数即为 a+b+c+d</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>, base=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span>(base &lt;= n)&#123;</span><br><span class="line">        res += n/base;</span><br><span class="line">        base = base*<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-20-合适篮筐的数量"><a href="#pa-20-合适篮筐的数量" class="headerlink" title="pa-20.合适篮筐的数量"></a><a href="https://www.papamelon.com/problem/20">pa-20.合适篮筐的数量</a></h2><p>小棒瓜瓜现在有 m 个甜美的棒瓜，每个棒瓜都有相应的体积，设第 i 个棒瓜的体积为 v_i</p><p>现在他要寻找一个 合适的篮筐，要求这个 篮筐的容量至少是其中一个棒瓜的体积的整数倍。</p><p>小棒瓜瓜来到集市，发现有 n 个篮筐，这些篮筐的容量恰好是连续的正整数，最小的篮筐容量为 C，最大的篮筐容量为 C + n - 1，也就是说，这些篮筐的容量分别为 [C, C+1, C+2, C+3, … , C+n-1]</p><p>现在他要在这些篮筐中，找出所有合适的篮筐，请你帮忙统计合适的篮筐个数。</p><p>下面来看一个例子</p><p>一共有 3 个棒瓜，它们的体积分别为 [2,3,4]</p><p>集市里有 6 个篮筐，最小篮筐容量为 11，所有的篮筐容量为 [1,2,3,4,5,6]</p><p>合适的篮筐一共有 4 个，包括 [2,3,4,6]，它们的容量至少是一个棒瓜体积的整数倍</p><p><strong>输入</strong></p><ul><li><p>第一行是整数 T, 1≤T≤1000，表示接下来有 T 组数据</p></li><li><p>每组数据位于一行:</p><ul><li><p>前 3 个是正整数 m, n, C，分别表示棒瓜的数量和集市中篮筐的数量，以及最小的篮筐容量，其中 1≤m≤10, 1≤n≤10^6, 1≤C≤10^8</p></li><li><p>接下来是 m 个正整数，表示 m 个棒瓜的体积，设第 i 个棒瓜的体积为 1&lt;=vi&lt;=500,<strong>同时保证所有棒瓜的体积相乘不会超过</strong>10^18</p></li></ul></li></ul><blockquote><p>样例 1<br>输入<br>1<br>3 6 1 2 3 4<br>输出<br>4</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.枚举所有集合重叠的情况 </span></span><br><span class="line"><span class="comment"> *  -所谓的集合，指的是 vi 的倍数</span></span><br><span class="line"><span class="comment"> *  -&#123;v0&#125;, &#123;v1&#125;, &#123;v2&#125; ... &#123;vm-1&#125;</span></span><br><span class="line"><span class="comment"> *  -&#123;v0,v1&#125;, &#123;v0,v2&#125;... &#123;vm-2,vm-1&#125;</span></span><br><span class="line"><span class="comment"> *  -&#123;v0,v1,v2&#125; ... &#123;vm-3,vm-2,vm-1&#125;</span></span><br><span class="line"><span class="comment"> *  - ...</span></span><br><span class="line"><span class="comment"> * 2.计算重叠集合的最小公倍数， LCM = &#123;vi, vj ... vk&#125;,  n/LCM = 重叠集合的大小</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.根据容斥原理， 奇加 偶减</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n ,c;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)  cin &gt;&gt; v[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxs = <span class="number">1</span> &lt;&lt; m; <span class="comment">//总共状态数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s&lt;maxs; ++s)&#123; <span class="comment">//一共maxs-1重状态，s从1开始</span></span><br><span class="line">        ll lcm=<span class="number">1LL</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i) <span class="keyword">if</span> ((s &gt;&gt; i) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// a*b=p*q 最小公倍数于最大公约数的关系</span></span><br><span class="line">            lcm = lcm * v[i] / __gcd(lcm, <span class="number">1LL</span> * v[i]) ; <span class="comment">// &#123;vi, vj ... vk&#125;的最小公倍数</span></span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> count = (c+n<span class="number">-1</span>)/lcm - (c<span class="number">-1</span>)/lcm;</span><br><span class="line">        <span class="keyword">if</span>(cnt &amp;<span class="number">1</span> )  res += count;</span><br><span class="line">        <span class="keyword">else</span> res -= count;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="pa-9-套娃-1"><a href="#pa-9-套娃-1" class="headerlink" title="pa-9.套娃"></a>pa-9.套娃</h2><p><a href="#%5Bpa-9.%E5%A5%97%E5%A8%83%5D(https://www.papamelon.com/problem/9)">跳转</a></p><h2 id="pa-18-套娃II-1"><a href="#pa-18-套娃II-1" class="headerlink" title="pa-18.套娃II"></a>pa-18.套娃II</h2><p><a href="#%5Bpa-18.%E5%A5%97%E5%A8%83II%5D(https://www.papamelon.com/problem/18)">跳转</a></p><h2 id="pa-10-计算第k个排列"><a href="#pa-10-计算第k个排列" class="headerlink" title="pa-10.计算第k个排列"></a><a href="https://www.papamelon.com/problem/10">pa-10.计算第k个排列</a></h2><p>给定我们整数 n，表示我们有 [1,2,3,4 … n-1, n] 这 n 个数字，我们可以构造出 n! 个的升序排序的排列。</p><p>例如，n = 3，所有的排列为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><p>现在再给定我们一个整数 K, 1≤K≤n!，让我们找到第 K 个排列。</p><p>例如，n = 3, K = 1，目标排列是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p> n= 3, K = 3，目标排列是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1 3</span><br></pre></td></tr></table></figure><p><strong>输入</strong></p><p>第一行是整数 T 表示接下来有 T 组 n, K，其中 1≤T≤1000</p><p>接下来有 T 行，每行两个数字用空格分隔，分别为 n, K，1≤n≤20,1≤K≤n!</p><p><strong>输出</strong></p><p>输出 T 行，每行是相应的目标排列，每个数字间用空格相隔，注意每行最后不要输出多余空格</p><p>样例 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">2</span><br><span class="line">3 1</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出:</span><br><span class="line">1 2 3</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-08-11 21:53:14</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-08-12 10:49:45</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">ll f[N+<span class="number">5</span>];         <span class="comment">//计算阶乘 f[i]=!i</span></span><br><span class="line"><span class="keyword">bool</span> visit[N+<span class="number">5</span>];   <span class="comment">//visit[i]=true 表示 i 已经被选到排列中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ll K;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="comment">// 从左到右，按位确认被选中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pos = n; pos&gt;<span class="number">0</span>; pos--) &#123;</span><br><span class="line">        ll sum=<span class="number">0</span>;     <span class="comment">//跳过多少个排列</span></span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">1</span>;    <span class="comment">//选中的元素，pos=n时，每个分组有 f(n-1)个排列</span></span><br><span class="line">        <span class="comment">//确认分组</span></span><br><span class="line">        <span class="keyword">for</span> (; cur &lt;= n; cur++) <span class="keyword">if</span> (!visit[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + f[pos - <span class="number">1</span>] &gt;= K) <span class="keyword">break</span>;</span><br><span class="line">            sum += f[pos - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        visit[cur] = <span class="literal">true</span>;</span><br><span class="line">        cout &lt;&lt; cur &lt;&lt; (pos==<span class="number">1</span> ? <span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        K -= sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) f[i] = f[i - <span class="number">1</span>] * i;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pa-10-计算排列的编号"><a href="#pa-10-计算排列的编号" class="headerlink" title="pa-10.计算排列的编号"></a><a href="https://www.papamelon.com/problem/11">pa-10.计算排列的编号</a></h2><p>给定正整数 n，表示我们有 [1,2,3,4 … n-1, n] 这 n 个数字，我们可以构造出 n! 个升序排序的排列。</p><p>例如，n = 3，所有的排列为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><p>现在，从中选择其中一个排列，计算它的编号，例如：</p><ul><li>以下排列属于第 1 个：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure></li><li>以下排列属于第 3 个:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1 3</span><br></pre></td></tr></table></figure></li><li>以下排列属于第 5 个：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 1 2</span><br></pre></td></tr></table></figure></li><li><em>输入</em>*</li></ul><p>第一行是整数 T，表示接下来有 T 组 排列，其中 1≤T≤10000</p><p>接下来有 T 行，每行的第一个数字为 n, 1≤n≤20，后面跟着 n 个整数，是一个关于 n 的排列，所有数字用空格分 隔</p><p><strong>输出</strong></p><p>输出 T 行，每行表示排列的编号</p><blockquote><p>样例 1</p><p>输入</p><p>2</p><p>3 2 1 3</p><p>3 3 1 2</p><p>输出</p><p>3</p><p>5</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于给定的序列，按位确定</span></span><br><span class="line"><span class="comment"> * 对于当前 a[i]，先计算 a[i] 在可用的元素里面排第几位(count)</span></span><br><span class="line"><span class="comment"> * 对于当前第 i 轮，确认了 a[i] 后，其余元素可以任意排，产生的排列数量是 (n-1-i)!</span></span><br><span class="line"><span class="comment"> * 实际跳过的排列的数量 = (n-1-i)! * count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>; <span class="comment">//标记数组</span></span><br><span class="line">    </span><br><span class="line">    ll skip = <span class="number">0</span>; <span class="comment">//跳过多少个排列</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;  <span class="comment">// a[i] 在可用的数字里面，是第几个</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>; x&lt;=n &amp;&amp; x!=a[i]; x++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[x]) count++;</span><br><span class="line">        skip += f[n<span class="number">-1</span>-i]*count;</span><br><span class="line">        vis[a[i]]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; skip+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; ++i)&#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]*i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-140-公司团建"><a href="#pa-140-公司团建" class="headerlink" title="pa-140.公司团建"></a><a href="https://www.papamelon.com/problem/140">pa-140.公司团建</a></h2><p>公司终于去团建啦！这次参加团建的一共有 n 个小伙伴，为了使得团建可以愉快进行，我们保证 n 一共是 偶数，同时我们希望小伙伴们能两两组队，这样旅途中不会太无聊。</p><p>请你帮忙计算一下，一共有多少种组队方案？</p><p>请注意以下细节</p><p>(A, B) 和 (B,A) 被认为是一个队伍。也就是说，如果 n=2，只有一种组队方案</p><p>匹配后的队伍，并无前后顺序之分，例如 n=4:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以下两种组队方案被认为是同一种</span><br><span class="line">1 2  // 1 2 组队</span><br><span class="line">3 4  // 3 4 组队</span><br><span class="line"></span><br><span class="line">3 4  // 3 4 组队</span><br><span class="line">1 2  // 1 2 组队</span><br></pre></td></tr></table></figure><p><strong>输入</strong></p><p>只有一行，整数 n (2≤n≤16), 保证 n 一定是 <strong>偶数</strong></p><p><strong>输出</strong></p><p>只有一行，表示有多少种组队方案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 所有的组合都可以归结为 a_0(1) &lt; b_i(n-1) a_1(1) &lt; b_i(n-3)...</span></span><br><span class="line"><span class="comment"> * 最后的结果为(n-1)*(n-3)*(n-5)* ... * 1</span></span><br><span class="line"><span class="comment"> * 递推公式 f[i]=f[i-2]*(i-1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> f[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=N; i=i+<span class="number">2</span>)&#123;</span><br><span class="line">        f[i] = f[i<span class="number">-2</span>] * (i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; f[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-141-公司团建II"><a href="#pa-141-公司团建II" class="headerlink" title="pa-141.公司团建II"></a><a href="https://www.papamelon.com/problem/141">pa-141.公司团建II</a></h2><p>题干同140.</p><p><strong>输入</strong></p><ul><li>第一行为整数 T (1≤T≤10000)，表示有 T 组测试数据</li><li>接下来 T行，每行一个整数 n (2≤n≤10^6), 保证 n 一定是 <strong>偶数</strong></li></ul><p><strong>输出</strong></p><ul><li>输出 T行，每行一个整数，表示有多少种组队方案</li><li>结果对 <code>998244353</code> 取模</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多了取模</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">ll f[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=N; i=i+<span class="number">2</span>)&#123;</span><br><span class="line">        f[i] = f[i<span class="number">-2</span>] * (i<span class="number">-1</span>) % <span class="number">998244353</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">   </span><br><span class="line">        cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-15-刷房子"><a href="#pa-15-刷房子" class="headerlink" title="pa-15.刷房子"></a><a href="https://www.papamelon.com/problem/15">pa-15.刷房子</a></h2><p>小棒瓜瓜有 n 个房子排成一排，同时他有红黄蓝三种颜色的油漆。现在他要给每个房子刷上一种颜色的油漆，同时要求任意两个相邻房子的油漆颜色不得相同。</p><p>另外，即便是同一种颜色的油漆，刷不同的房子，所需的花费也是不同的。</p><p>现在我们得到每个房子刷上 33 种油漆的代价，请帮小棒瓜瓜计算一下，为所有房子都刷上油漆且没有任意两个相邻房子的颜色相同的最小总花费。</p><p><strong>输入</strong></p><ul><li><p>第一行是整数 T，表示接下来有 TT 组数据，1≤T≤1000</p></li><li><p>每组数据由 n + 1 行组成，第一行是整数 nn，表示有 n 个房子，1≤n≤10^5</p></li><li><p>接下来是 n 行，每行 3 个正整数。第 i 行的 3 个正整数分别为 cost[i][0], cost[i][1], cost[i][2]，表示给第 i 个房子刷上红黄蓝三种油漆的花费。1≤cost[i][j]≤1000</p></li><li><p>T 组数据中所有 n 的总和为 S, T≤S≤10^6</p></li></ul><p><strong>输出</strong></p><ul><li>输出 T 行，每行一个正整数，表示为所有房子都刷上油漆且没有任意两个相邻房子的颜色相同的最小总花费</li></ul><blockquote><p>样例 1<br>输入<br>3<br>1<br>1 2 3</p><p>2<br>1 2 1<br>2 1 2</p><p>3<br>100 200 300<br>200 300 400<br>1 2 3</p><p>输出<br>1<br>2<br>401</p><p>提示<br>第 3 组测试用例中：<br>第一个房子选用红色油漆，花费为 100<br>第二个房子选用黄色油漆，花费为 300<br>第三个房子选用红色油漆，花费为 1<br>最小总花费为 401</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  DP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; <span class="built_in">x</span>(<span class="number">3</span>,<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 初始状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)  cin &gt;&gt; x[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; ++j)&#123;<span class="comment">// 当前房子颜色状态只与前面房子颜色相关</span></span><br><span class="line">            <span class="keyword">int</span> val;</span><br><span class="line">            cin &gt;&gt; val;</span><br><span class="line">            y[j]=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">3</span>; ++k) <span class="keyword">if</span>(j!=k)&#123; <span class="comment">//当前房子处最小花费</span></span><br><span class="line">                y[j]=<span class="built_in">min</span>(y[j], x[k]+val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);  <span class="comment">// 滚动数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res=INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)&#123;</span><br><span class="line">        res=<span class="built_in">min</span>(res, x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-17-刷房子II"><a href="#pa-17-刷房子II" class="headerlink" title="pa-17.刷房子II"></a><a href="https://www.papamelon.com/problem/17">pa-17.刷房子II</a></h2><p>小棒瓜瓜在完成了第一次 刷房子 任务后，又迎来了第二个任务。</p><p>现在有 n 个房子排成一排，同时有红黄蓝三种颜色的油漆，每种油漆分别有 na, nb, nc 桶。</p><p>刷一个房子要耗费一桶油漆，同时要求任意两个相邻房子的油漆颜色不得相同。</p><p>另外，即便是同一种颜色的油漆，刷不同的房子，所需的花费也是不同的。</p><p>现在我们得到每个房子刷上 3 种油漆的代价，请帮小棒瓜瓜计算一下，为所有房子都刷上油漆且没有任意两个相邻房子的颜色相同的总花费是多少。</p><p>如果无法为每个房子都刷上油漆，花费为 -1</p><p><strong>输入</strong></p><p>第一行是整数 T，表示接下来有 T 组数据，1≤T≤10</p><p>每组数据由 n + 1 行组成</p><p>第一行是整数 n, na, nb, nc，表示有 n 个房子，红黄蓝油漆的桶数分别为 na, nb, nc, 1≤n,na,nb,nc≤25，</p><p>接下来是 n 行，每行 3 个正整数。第 i 行的 3 个正整数分别为 cost[i][0], cost[i][1], cost[i][2]，表示给第 i 个房子刷上红黄蓝三种油漆的花费。1≤cost[i][j]≤1000</p><p><strong>输出</strong></p><p>输出 T 行，每行一个正整数，表示为所有房子都刷上油漆且没有任意两个相邻房子的颜色相同的最小花费</p><p>如果无法为所有房子都刷上油漆，输出 -1</p><blockquote><p>样例 1<br>输入<br>1<br>3 1 1 1<br>1 5 10<br>15 2 20<br>25 30 3</p><p>输出<br>6</p><p>提示<br>第一个房子选择红色油漆，花费为 1<br>第二个房子选择黄色油漆，花费为 2<br>第三个房子选择蓝色油漆，花费为 3<br>总花费为 6</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  DP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">4</span>][N][N][N], vis[N][<span class="number">4</span>][N][N][N];</span><br><span class="line"><span class="keyword">int</span> n, cnt[<span class="number">3</span>], cost[N][<span class="number">3</span>];<span class="comment">//房子数量n 每个颜料数量 cnt[i] 花费数组cost[n][i];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==n) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果计算过 直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vis[cur][col][cnt[<span class="number">0</span>]][cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]])</span><br><span class="line">        <span class="keyword">return</span> f[cur][col][cnt[<span class="number">0</span>]][cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">     vis[cur][col][cnt[<span class="number">0</span>]][cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span>&amp; res = f[cur][col][cnt[<span class="number">0</span>]][cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]];<span class="comment">//引用</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;<span class="number">3</span>; c++) <span class="keyword">if</span>(c !=col &amp;&amp; cnt[c] )&#123; <span class="comment">//颜料使用限制条件</span></span><br><span class="line">         cnt[c]--;</span><br><span class="line">         res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(cur+<span class="number">1</span>, c) + cost[cur][c]);</span><br><span class="line">         cnt[c]++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)   cin &gt;&gt; cnt[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; ++j)</span><br><span class="line">            cin &gt;&gt; cost[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f3f3f3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(res == INF)  res=<span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-153-平面分割"><a href="#pa-153-平面分割" class="headerlink" title="pa-153.平面分割"></a><a href="https://www.papamelon.com/problem/153">pa-153.平面分割</a></h2><p>平面上有 n 条直线，最多把平面切割成多少块?</p><p>输入</p><p>多组测试数据，以 EOF 结束</p><p>每组测试数据一个整数 n (0≤n≤500)</p><p>输出</p><p>每组测试数据输出一个整数，表示最多把平面切割成多少块</p><p>提示</p><p>当 n=0 时，表示平面上没有直线，平面被视为一整块，答案是 1</p><blockquote><p>样例 1<br>输入<br>1<br>2</p><p>输出<br>2<br>4</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 先枚举，找找规律</span></span><br><span class="line"><span class="comment"> * f[0]=1</span></span><br><span class="line"><span class="comment"> * f[i] = f[i-1] + i （i≥1）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> f[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; ++i)&#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ( cin&gt;&gt;n )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-151-走楼梯"><a href="#pa-151-走楼梯" class="headerlink" title="pa-151.走楼梯"></a><a href="https://www.papamelon.com/problem/151">pa-151.走楼梯</a></h2><p>我们在地面上，有 n 级楼梯，能让我们上到第 n 层。</p><p>每次我们可以走 1 级或 2 级楼梯。问我们走完 n 级楼梯有多少种方案？</p><p>例：n=3，一共有 3 种可能</p><p>1,1,1，每次走一级，走三步</p><p>1,2，走两步，第一步走一级，第二步走两级</p><p>2,1，走两步，第一步走两级，第二步走一级</p><p><strong>输入</strong><br>一个整数 n(1≤n≤36)，表示有多少级楼梯</p><p><strong>输出</strong><br>一个整数，表示有多少种走法</p><blockquote><p>样例 1<br>输入<br>3</p></blockquote><blockquote><p>输出<br>3</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归，动规</span></span><br><span class="line"><span class="comment"> * f[i]=f[i−1]+f[i−2]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[n];</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>,f[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-157-拆分相等集合"><a href="#pa-157-拆分相等集合" class="headerlink" title="pa-157.拆分相等集合"></a><a href="https://www.papamelon.com/problem/157">pa-157.拆分相等集合</a></h2><p>给定正整数 n，将 1 2 3 4 5… n 这 n个数字划分到两个集合中，使得两个集合的和相等。</p><p>每个集合都不能为空。每个数字只能且必须在其中一个集合。两个集合的元素个数不必相等。</p><p>如果能成功划分则输出 <code>YES</code>，同时 <strong>输出任意一种划分方案</strong>。如果不能成功划分则输出 <code>NO</code></p><p><strong>输入</strong></p><ul><li>一个正整数 n (1≤n≤106)</li></ul><p><strong>输出</strong></p><ul><li><p>第一行输出 <code>YES</code> 或 <code>NO</code></p></li><li><p>如果答案为<code>YES</code>，接下来继续输出4行</p><ul><li>第一行为第一个集合的元素个数 C1</li></ul></li><li><p>第二行为 C1个整数，用空格分隔，表示含有哪些元素</p><ul><li>第三行为第二个集合的元素个数 C2</li><li>第四行为 C2个整数，用空格分隔，表示含有哪些元素</li></ul></li></ul><p><strong>提示</strong></p><ul><li>输出任意一种划分方案即可</li><li><strong>本题答案不是唯一，测试用例详情里的答案不予显示</strong></li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">7</span><br><span class="line">输出</span><br><span class="line">YES</span><br><span class="line">4</span><br><span class="line">1 2 4 7</span><br><span class="line">3</span><br><span class="line">3 5 6</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 证明出数组可以被平均的拆分成两半，由n(n+1)/2能被2整除条件，</span></span><br><span class="line"><span class="comment"> * 若n为偶数，那么可推导出n%4等于0,且能由偶数对的（n+1）</span></span><br><span class="line"><span class="comment"> * 若n+1为偶数，那么可推导出n%3等于0,那么就有偶数对的 n</span></span><br><span class="line"><span class="comment"> * 剩下的拆分即可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>( n%<span class="number">4</span>!=<span class="number">0</span> &amp;&amp; n%<span class="number">4</span>!=<span class="number">3</span> )&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//构造答案</span></span><br><span class="line">    <span class="comment">// n % 4 == 0，每一对的和为 n + 1</span></span><br><span class="line">    <span class="comment">// n % 4 == 3，每一对的和为 n </span></span><br><span class="line"></span><br><span class="line">    ll s = (<span class="number">1LL</span>+n)*n/<span class="number">2</span>;  <span class="comment">// 1LL 非常重要</span></span><br><span class="line">    ll h = s/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> t = n%<span class="number">4</span> ==<span class="number">0</span> ? n+<span class="number">1</span> : n;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;<span class="number">0</span> &amp;&amp; a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>()&lt;n; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h)&#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">int</span> x = t-i;</span><br><span class="line">            <span class="keyword">if</span>(x) a.<span class="built_in">push_back</span>(x);</span><br><span class="line">            h = h-t;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">int</span> x = t-i;</span><br><span class="line">            <span class="keyword">if</span>(x) b.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:a) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; b.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:b) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-194-抽签"><a href="#pa-194-抽签" class="headerlink" title="pa-194.抽签"></a><a href="https://www.papamelon.com/problem/194">pa-194.抽签</a></h2><p>一个袋子中有 n<em>n</em> 个数字纸片，每张上面都写了一个数字。</p><p>我们有 44 次机会，每次从袋子中选一个纸片，记录下数字，然后放回去（因此一个纸片可能多次被选中）。</p><p>当存在一个可能，使得 44 张纸片的数字总和等于 m<em>m</em>，则输出 <code>Yes</code>，否则输出 <code>No</code></p><p><strong>输入</strong></p><ul><li>第一行输入整数 n (1≤n≤50)</li><li>第二行输入整数 m (1≤m≤108)</li><li>第三行输入 n 个整数，表示每个纸片上的数字 k_i (1≤k_i≤108)</li></ul><p><strong>输出</strong></p><ul><li>一行，<code>Yes</code> 或 <code>No</code></li></ul><p><strong>样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">3</span><br><span class="line">10</span><br><span class="line">1 3 5</span><br><span class="line">输出</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-11-14 10:51:29</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-11-14 11:32:52</span></span><br><span class="line"><span class="comment"> * @Description: 暴力枚举  unordered_set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">k</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) cin &gt;&gt; k[i];</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(k[i] + k[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> x : res)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = m-x;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">count</span>(tmp))&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组-字符串"><a href="#数组-字符串" class="headerlink" title="数组/字符串"></a>数组/字符串</h1><h2 id="LC-14-最长公共前缀"><a href="#LC-14-最长公共前缀" class="headerlink" title="LC-14.最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">LC-14.最长公共前缀</a></h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br><span class="line"></span><br><span class="line">输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，</span></span><br><span class="line"><span class="comment"> * 如果相同则继续对下一列进行比较，</span></span><br><span class="line"><span class="comment"> * 如果不相同则当前列不再属于公共前缀，</span></span><br><span class="line"><span class="comment"> * 当前列之前的部分为最长公共前缀。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> count = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].<span class="built_in">size</span>() || strs[j][i] != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="合并k个有序数组"><a href="#合并k个有序数组" class="headerlink" title="合并k个有序数组"></a>合并k个有序数组</h2><p>假定有k个有序数组，每个数组中含有n个元素，您的任务是将它们合并为单独的一个有序数组，该数组共有kn个元素。设计和实现 一个有效的分治算法解决k-路合并操作问题，并分析时间复杂度。</p><p>时间复杂度：O(nlogk)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mergeTowArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;A,vector&lt;<span class="keyword">int</span>&gt;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">    temp.<span class="built_in">resize</span>(A.<span class="built_in">size</span>() + B.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, j = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; A.<span class="built_in">size</span>() &amp;&amp; j &lt; B.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; B[j])</span><br><span class="line">            temp[index++] = A[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[index++] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            temp[index++] = A[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            temp[index++] = B[j++];</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">kMergeSort</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;A, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span> A[start];</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;Left = <span class="built_in">kMergeSort</span>(A, start, mid);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;Right = <span class="built_in">kMergeSort</span>(A, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mergeTowArrays</span>(Left, Right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mergeSortArrays</span><span class="params">(vector &lt;vector&lt;<span class="keyword">int</span>&gt;&gt;A)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">empty</span>() || A.<span class="built_in">size</span>() == <span class="number">0</span> || A[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    temp = <span class="built_in">kMergeSort</span>(A, <span class="number">0</span>, A.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><p>从键盘输入一个string字符串  ‘’m=2,n=3’。现在要把字符串中的数字2和3提取出来分别赋值给两个 int 类型变量 a 和 b</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * c++中引入了流的概念</span></span><br><span class="line"><span class="comment"> * stringstream ss;</span></span><br><span class="line"><span class="comment"> * ss &lt;&lt; t;//向流中传值</span></span><br><span class="line"><span class="comment"> * ss &gt;&gt; res;//向res中写入值，可用作int转string</span></span><br><span class="line"><span class="comment"> * cout &lt;&lt; ss.str(); //cout 输出</span></span><br><span class="line"><span class="comment"> * printf(&quot;%s\n&quot;, ss.str().c_str()); //printf 输出</span></span><br><span class="line"><span class="comment"> * stringstream清空，ss.str(&quot;&quot;);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * getline()函数的定义</span></span><br><span class="line"><span class="comment"> * - istream&amp; getline ( istream &amp;is , string &amp;str , char delim );</span></span><br><span class="line"><span class="comment"> * - is 进行读入操作的输入流 </span></span><br><span class="line"><span class="comment"> * - str 用来存储读入的内容</span></span><br><span class="line"><span class="comment"> * - delim 终结符，遇到该字符停止读取操作，不写的话默认为回车</span></span><br><span class="line"><span class="comment"> * while(getline(cin,str)) 会一直循环，因为回车只会终止getline()函数的读入操作。</span></span><br><span class="line"><span class="comment"> * getline()函数终止后又进行while（）判断（即判断输入流是否有效，你的输入流当然有效，满足条件）</span></span><br><span class="line"><span class="comment"> * 所以又运行getline()函数，导致程序永远跳不出循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">     cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp.<span class="built_in">substr</span>(tmp.<span class="built_in">size</span>()<span class="number">-1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;data.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-01 18:45:34</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-02 10:42:23</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">     cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">int</span> idx = s.<span class="built_in">find</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(<span class="number">2</span>, idx - <span class="number">2</span>));</span><br><span class="line">    n = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(idx + <span class="number">3</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; m &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h2><p>给出一个二维字符数组和一个单词，判断单词是否在数组中出现，</p><p>单词由相邻单元格的字母连接而成，相邻单元指的是上下左右相邻。同一单元格的字母不能多次使用。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给出的字符数组=</span><br><span class="line">[</span><br><span class="line">  [&quot;XYZE&quot;],</span><br><span class="line">  [&quot;SFZS&quot;],</span><br><span class="line">  [&quot;XDEE&quot;]</span><br><span class="line">]</span><br><span class="line">单词 =&quot;XYZZED&quot;, -&gt; 返回 true,</span><br><span class="line">单词 =&quot;SEE&quot;, -&gt;返回 true,</span><br><span class="line">单词 =&quot;XYZY&quot;, -&gt; 返回 fXlse.</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ DFS backtracking 的算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOut</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c&lt;<span class="number">0</span> || c&gt;=cols || r&lt;<span class="number">0</span> || r&gt;=rows;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="keyword">int</span> r, <span class="keyword">int</span> c, string &amp;word, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=word.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isOut</span>(r, c, board.<span class="built_in">size</span>(), board[<span class="number">0</span>].<span class="built_in">size</span>())||word[start]!=board[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dx[]=&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[]=&#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> tmp=board[r][c];</span><br><span class="line">        board[r][c]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">DFS</span>(board, r+dx[i], c+dy[i], word, start+<span class="number">1</span>))</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[r][c]=tmp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt; &gt; &amp;board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows=board.<span class="built_in">size</span>(), cols=board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;rows; ++r)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;cols; ++c)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[r][c]==word[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">DFS</span>(board, r, c, word, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-4-寻找两个正序数组的中位数"><a href="#LC-4-寻找两个正序数组的中位数" class="headerlink" title="LC-4.寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">LC-4.寻找两个正序数组的中位数</a></h2><h2 id="定长子数组和"><a href="#定长子数组和" class="headerlink" title="定长子数组和!!"></a>定长子数组和!!</h2><h2 id="最大子矩阵和"><a href="#最大子矩阵和" class="headerlink" title="最大子矩阵和"></a><a href="https://blog.csdn.net/weixin_43175029/article/details/94592427">最大子矩阵和</a></h2><h1 id="链表-树"><a href="#链表-树" class="headerlink" title="链表/树"></a>链表/树</h1><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p><strong>二叉树定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*前序遍历*/</span></span><br><span class="line">    <span class="comment">//1.确定递归函数的参数和返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preordertraversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        <span class="comment">//2.确定终⽌条件</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//3.确定单层递归的逻辑</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);            <span class="comment">// 根</span></span><br><span class="line">        <span class="built_in">preordertraversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">preordertraversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*中序遍历*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inordertraversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inordertraversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);           <span class="comment">// 根</span></span><br><span class="line">        <span class="built_in">inordertraversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*后序遍历*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postordertraversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">postordertraversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">postordertraversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);             <span class="comment">// 根</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">preordertraversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>迭代</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*前序遍历*/</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; st;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">/*根入栈，出栈；右子树进栈，左子树进栈；左子树出栈，右子树出栈*/</span></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode *node = st.<span class="built_in">top</span>(); <span class="comment">// 根</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                st.<span class="built_in">push</span>(node-&gt;left);  <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*中序遍历*/</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode *&gt; st;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>)&#123; <span class="comment">//指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur);    <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left; <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出数据就是要处理的数据（放进result数组）</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 根</span></span><br><span class="line">                cur = cur-&gt;right;           <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*后序遍历*/</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; st;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode *node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                st.<span class="built_in">push</span>(node-&gt;left);  <span class="comment">// 相对于前序遍历，更改入栈顺序（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">                st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果翻转之后就是左右根的顺序</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>层序遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode *root)&#123;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size()是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-2-两数之和"><a href="#LC-2-两数之和" class="headerlink" title="LC-2.两数之和"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">LC-2.两数之和</a></h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2--&gt;4--&gt;3</span><br><span class="line">5--&gt;6--&gt;4</span><br><span class="line">----------</span><br><span class="line">7--&gt;0--&gt;8</span><br><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]       </span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br><span class="line"></span><br><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br><span class="line"></span><br><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br><span class="line">9--&gt;9--&gt;9--&gt;9--&gt;9--&gt;9--&gt;9</span><br><span class="line">9--&gt;9--&gt;9--&gt;9</span><br><span class="line">-------------------------</span><br><span class="line">8--&gt;9--&gt;9--&gt;9--&gt;0--&gt;0--&gt;0--&gt;1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur = res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( l1 || l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> val1 = l1? l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> val2 = l2? l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = (val1 + val2 +c);</span><br><span class="line">            c = sum/<span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(l1) l1=l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c) cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>); <span class="comment">//最后还有进位的情况，case3</span></span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-21-合并两个有序链表"><a href="#LC-21-合并两个有序链表" class="headerlink" title="LC-21.合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">LC-21.合并两个有序链表</a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br><span class="line"></span><br><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = preHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-23-合并k个有序升序链表"><a href="#LC-23-合并k个有序升序链表" class="headerlink" title="LC-23.合并k个有序升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">LC-23.合并k个有序升序链表</a></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  分治</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;; </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 合并两个有序链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge2</span><span class="params">(ListNode* p1, ListNode* p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p1) <span class="keyword">return</span> p2;</span><br><span class="line">        <span class="keyword">if</span>(!p2) <span class="keyword">return</span> p1;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val &lt;= p2-&gt;val)&#123;</span><br><span class="line">            p1-&gt;next = <span class="built_in">merge2</span>(p1-&gt;next, p2);</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p2-&gt;next = <span class="built_in">merge2</span>(p1, p2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span> lists[start];</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        ListNode* l1 = <span class="built_in">merge</span>(lists, start, mid);</span><br><span class="line">        ListNode* l2 = <span class="built_in">merge</span>(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JZ-24-翻转链表"><a href="#JZ-24-翻转链表" class="headerlink" title="JZ-24.翻转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">JZ-24.翻转链表</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 迭代</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next; <span class="comment">// 暂存后继节点 cur.next</span></span><br><span class="line">            cur-&gt;next = pre;           <span class="comment">// 修改 next 引用指向</span></span><br><span class="line">            pre = cur;                 <span class="comment">// pre 暂存 cur</span></span><br><span class="line">            cur = tmp;                 <span class="comment">// cur 访问下一节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">时间复杂度 <span class="built_in">O</span>(N) ： 遍历链表使用线性大小时间。</span><br><span class="line">空间复杂度 <span class="built_in">O</span>(<span class="number">1</span>) ： 变量 pre 和 cur 使用常数大小额外空间</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*递归*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* newhead=<span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next=head;</span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">时间复杂度 <span class="built_in">O</span>(N) ： 遍历链表使用线性大小时间。</span><br><span class="line">空间复杂度 <span class="built_in">O</span>(N) ： 遍历链表的递归深度达到 N，系统使用 <span class="built_in">O</span>(N) 大小额外空间。</span><br></pre></td></tr></table></figure><h2 id="LC-92-反转链表-II"><a href="#LC-92-反转链表-II" class="headerlink" title="LC-92.反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">LC-92.反转链表 II</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br><span class="line"></span><br><span class="line">输入：head = [5], left = 1, right = 1</span><br><span class="line">输出：[5]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummyNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">时间复杂度：<span class="built_in">O</span>(N)，其中 N 是链表总节点数。最多只遍历了链表一次，就完成了反转。</span><br><span class="line">空间复杂度：<span class="built_in">O</span>(<span class="number">1</span>)。只使用到常数个变量。</span><br></pre></td></tr></table></figure><h2 id="LC-141-环形链表"><a href="#LC-141-环形链表" class="headerlink" title="LC-141.环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">LC-141.环形链表</a></h2><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p><strong>进阶：</strong></p><p>你能用 *O(1)*（即，常量）内存解决此问题吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line"> 3--&gt;2--&gt;0--&gt;-4--</span><br><span class="line">  ^           |</span><br><span class="line">  |___________| </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  快慢指针，快指针每次走两步，慢指针每次走一步</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-42-环形链表-II"><a href="#LC-42-环形链表-II" class="headerlink" title="LC-42. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">LC-42. 环形链表 II</a></h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O(1) 空间解决此题？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast=head, *slow=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span> || fast-&gt;next==<span class="literal">nullptr</span>)  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快慢指针 fast  slow</span></span><br><span class="line"><span class="comment"> * 链表头到环的长度为 a，环的长度为 b</span></span><br><span class="line"><span class="comment"> * 第一次相遇时：</span></span><br><span class="line"><span class="comment"> *  - fast 走的步数是 slow 步数的 2倍，即 f = 2s</span></span><br><span class="line"><span class="comment"> *  - fast 比 slow 多走了 n 个环的长度，即 f = s + nb</span></span><br><span class="line"><span class="comment"> *  - 可推导得 f = 2s = 2nb</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果让指针从链表头部一直向前走并统计步数 k，那么所有走到链表入口节点时的步数是</span></span><br><span class="line"><span class="comment"> * k = a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）</span></span><br><span class="line"><span class="comment"> * 第一次相遇时 slow 走了 nb 步。因此只要再让 slow 走 a 步停下来，就可以到环的入口</span></span><br><span class="line"><span class="comment"> * 令 fast = head, slow不变，此时： f = 0, s = nb</span></span><br><span class="line"><span class="comment"> * 第二次相遇时：</span></span><br><span class="line"><span class="comment"> *  - f = a, s = a + nb</span></span><br><span class="line"><span class="comment"> * 返回 fast 指针指向的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="LC-146-LRU缓存机制"><a href="#LC-146-LRU缓存机制" class="headerlink" title="LC-146.LRU缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/">LC-146.LRU缓存机制</a></h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><p><strong>进阶</strong>：你是否可以在 O(1) 时间复杂度内完成这两种操作？<strong>双向链表插入、删除时间复杂度 O(1)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure><blockquote><p>提示：</p><ul><li>1 &lt;= capacity &lt;= 3000</li><li>0 &lt;= key &lt;= 10000</li><li>0 &lt;= value &lt;= 10^5</li><li>最多调用 2 * 10^5 次 get 和 put</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">      <span class="keyword">int</span> key, val;</span><br><span class="line">      Node *pre, *next;</span><br><span class="line">      <span class="built_in">Node</span>(<span class="keyword">int</span> k, <span class="keyword">int</span> v)&#123;</span><br><span class="line">          key = k;</span><br><span class="line">          val = v;</span><br><span class="line">          pre = next = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node *head, *tail;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, Node*&gt; pos;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        c = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos.<span class="built_in">count</span>(key)==<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        Node* ptr = pos[key];</span><br><span class="line">        <span class="built_in">remove</span>(ptr);   <span class="comment">//先从双向链表中删除</span></span><br><span class="line">        <span class="built_in">insert</span>(ptr);   <span class="comment">//再插入到head节点后</span></span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos.<span class="built_in">count</span>(key)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//insert (增加节点)</span></span><br><span class="line">            <span class="keyword">if</span>(pos.<span class="built_in">size</span>()==c)&#123;</span><br><span class="line">                Node* ptr = tail-&gt;pre;</span><br><span class="line">                <span class="built_in">remove</span>(ptr);</span><br><span class="line">                pos.<span class="built_in">erase</span>(ptr-&gt;key);</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            Node* ptr = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">            pos[ptr-&gt;key] = ptr;</span><br><span class="line">            <span class="built_in">insert</span>(ptr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update (不会增加节点)</span></span><br><span class="line">        Node* ptr = pos[key];</span><br><span class="line">        ptr-&gt;val = value;</span><br><span class="line">        <span class="built_in">remove</span>(ptr);</span><br><span class="line">        <span class="built_in">insert</span>(ptr); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node* ptr)</span></span>&#123;</span><br><span class="line">        Node* a = ptr-&gt;pre;</span><br><span class="line">        Node* b = ptr-&gt;next;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        b-&gt;pre = a;</span><br><span class="line"></span><br><span class="line">        ptr-&gt;pre = ptr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* ptr)</span></span>&#123;</span><br><span class="line">        Node* a = head-&gt;next;</span><br><span class="line">        a-&gt;pre = ptr;</span><br><span class="line">        ptr-&gt;next = a;</span><br><span class="line">        ptr-&gt;pre = head;</span><br><span class="line">        head-&gt;next= ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span> </span><br></pre></td></tr></table></figure><h2 id="JZ-22-链表中倒数第k个节点"><a href="#JZ-22-链表中倒数第k个节点" class="headerlink" title="JZ-22.链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">JZ-22.链表中倒数第k个节点</a></h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *former=head, *latter=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; ++i)&#123;</span><br><span class="line">            former = former-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(former!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            former = former-&gt;next;</span><br><span class="line">            latter = latter-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * head: [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"> * k: 2</span></span><br><span class="line"><span class="comment"> * former: [3,4,5]         [4,5]        [5]          []</span></span><br><span class="line"><span class="comment"> * latter: [1,2,3,4,5]     [2,3,4,5]    [3,4,5]      [4,5]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="LC-19-删除链表中倒数第k个节点"><a href="#LC-19-删除链表中倒数第k个节点" class="headerlink" title="LC-19.删除链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LC-19.删除链表中倒数第k个节点</a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br><span class="line"></span><br><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">getLength</span>(head);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JZ-40-最小的k个数"><a href="#JZ-40-最小的k个数" class="headerlink" title="JZ-40.最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">JZ-40.最小的k个数</a></h2><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><blockquote><p>0 &lt;= k &lt;= arr.length &lt;= 10000<br>0 &lt;= arr[i] &lt;= 10000</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=left, j=right;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//初始化随机数种子 </span></span><br><span class="line">        <span class="keyword">int</span> rd = <span class="built_in">rand</span>()%(right-left+<span class="number">1</span>)+left;</span><br><span class="line">        <span class="built_in">swap</span>(nums[rd], nums[right]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[i]&lt;=nums[right]) i++;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[j]&gt;=nums[right]) j--;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[right]);</span><br><span class="line">        <span class="keyword">return</span> i;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="built_in">partition</span>(arr,left,right);</span><br><span class="line">            <span class="keyword">if</span>(pos==k<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos&lt;k<span class="number">-1</span>) left=pos+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos&gt;k<span class="number">-1</span>) right=pos<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span> || k &gt; nums.<span class="built_in">size</span>()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">quick_sort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>,k);</span><br><span class="line">        res.<span class="built_in">assign</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">begin</span>()+k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JZ2-53-二叉搜索树的中序后继"><a href="#JZ2-53-二叉搜索树的中序后继" class="headerlink" title="JZ2-53.二叉搜索树的中序后继"></a><a href="https://leetcode-cn.com/problems/P5rCT8/">JZ2-53.二叉搜索树的中序后继</a></h2><p>给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null </p><p>节点 p 的后继是值比 p.val 大的节点中键值最小的节点，即按中序遍历的顺序节点 p 的下一个节点</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3], p = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：这里 1 的中序后继是 2</span><br><span class="line"></span><br><span class="line">输入：root = [5,3,6,2,4,null,null,1], p = 6</span><br><span class="line">输出：0</span><br><span class="line">解释：因为给出的节点没有中序后继，所以答案就返回 0</span><br></pre></td></tr></table></figure><p>提示：</p><blockquote><p>树中节点的数目在范围 [1, 104] 内。<br>-105 &lt;= Node.val &lt;= 105<br>树中各节点的值均保证唯一。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 二叉树的中序遍历</span></span><br><span class="line"><span class="comment"> * found 来标记是否已经遍历到节点 p, found 的初始值为 fasle</span></span><br><span class="line"><span class="comment"> * 遍历到节点 p 之后置为 true，在这个变量变为 true 之后第一个遍历到的节点就是结果</span></span><br><span class="line"><span class="comment"> * 二叉搜索树的高度为 h,节点数为 n, 时间复杂度为 O(n)，空间复杂度为 O(h)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">inorderSuccessor</span><span class="params">(TreeNode *root, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; sta;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                sta.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (found)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;val == p)&#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeNode *dummy = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">    TreeNode *tmp = dummy;</span><br><span class="line">    tmp-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    tmp-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">6</span>);</span><br><span class="line">    tmp = tmp-&gt;left;</span><br><span class="line">    tmp-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    tmp-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    tmp = tmp-&gt;left;</span><br><span class="line">    tmp-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    res = <span class="built_in">Solution</span>().<span class="built_in">inorderSuccessor</span>(dummy, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ-54-二叉搜索数的第k大节点"><a href="#JZ-54-二叉搜索数的第k大节点" class="headerlink" title="JZ-54.二叉搜索数的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">JZ-54.二叉搜索数的第k大节点</a></h2><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p><strong>示例 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><blockquote><p>1 ≤ k ≤ 二叉搜索树元素个数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  迭代</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k=k;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> res,k;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(--k==<span class="number">0</span>)&#123;</span><br><span class="line">            res=root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 递归  + 中序遍历 【 左 根 右】</span></span><br><span class="line"><span class="comment"> * 求第k大节点， 中序倒序遍历即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur -&gt; right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// ans.insert(ans.begin(), cur -&gt; val);</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur = cur -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[k <span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索数的第k小节点"><a href="#二叉搜索数的第k小节点" class="headerlink" title="二叉搜索数的第k小节点"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">二叉搜索数的第k小节点</a></h2><p><strong>示例 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = k;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res, count;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)  <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(--count==<span class="number">0</span>)&#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>小汪作为一个有数学天分的程序猿，设计了一套密码生成器来搞定自己的密码问题。<br>密码生成器由N个槽位组成，槽位的下标为0~N-1，每个槽位存储一个数。起初每个槽位都是0。<br>密码生成器会进行M轮计算，每轮计算，小汪会输入两个数L,R(L&lt;=R),密码生成器会将这两个数作为下标，将两个下标之间（包含）的所有槽位赋值为i（i为当前的轮次，i∈[1,M]）。<br>M轮计算完成后，密码生成器会根据槽位的最终值生成一条密码，密码的生成规则为：<br>（0<em>a[0] + 1</em>a[1] + 2*a[2] + … + (N-1)*a[N-1]) mod 100000009<br>其中a[i]表示第i个槽位的最终值。<br>请帮助小汪把他的密码生成器实现为代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lchild(x) ((x) &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rchild(x) (((x) &lt;&lt; 1) + 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">100000009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">9</span>)<span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">op</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="comment">//[l, r]的区间和</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sum</span><span class="params">(ll l, ll r)</span> </span>&#123;<span class="keyword">return</span> (l + r) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> x[maxn &lt;&lt; <span class="number">1</span>], x_size, realx_size, c[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> L, R;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> value, tag_Set;</span><br><span class="line">    &#125;nodes[maxn &lt;&lt; <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">SegmentTree</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(nodes, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(nodes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        nodes[root].value = nodes[<span class="built_in">Lchild</span>(root)].value + nodes[<span class="built_in">Rchild</span>(root)].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        nodes[root].tag_Set = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r)nodes[root].value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">Lchild</span>(root), l, m);</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">Rchild</span>(root), m + <span class="number">1</span>, r);</span><br><span class="line">            <span class="built_in">pushup</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nodes[root].tag_Set) &#123;</span><br><span class="line">            nodes[<span class="built_in">Lchild</span>(root)].tag_Set = nodes[<span class="built_in">Rchild</span>(root)].tag_Set = nodes[root].tag_Set;</span><br><span class="line">            nodes[<span class="built_in">Lchild</span>(root)].value = (m - l + <span class="number">1</span>) * nodes[root].tag_Set;</span><br><span class="line">            nodes[<span class="built_in">Rchild</span>(root)].value = (r - m) * nodes[root].tag_Set;</span><br><span class="line">            nodes[root].tag_Set = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">updateSet</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> curl, <span class="keyword">int</span> curr, <span class="keyword">int</span> tarl, <span class="keyword">int</span> tarr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tarr &lt; curl || curr &lt; tarl)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (tarl &lt;= curl &amp;&amp; curr &lt;= tarr) &#123;</span><br><span class="line">            nodes[root].tag_Set = k;</span><br><span class="line">            nodes[root].value = (curr - curl + <span class="number">1</span>) * k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(root, curl, curr);</span><br><span class="line">        <span class="keyword">int</span> m = (curl + curr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tarl &lt;= m) <span class="built_in">updateSet</span>(<span class="built_in">Lchild</span>(root), curl, m, tarl, tarr, k);</span><br><span class="line">        <span class="keyword">if</span> (tarr &gt; m) <span class="built_in">updateSet</span>(<span class="built_in">Rchild</span>(root), m + <span class="number">1</span>, curr, tarl, tarr, k);</span><br><span class="line">        <span class="built_in">pushup</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> curl, <span class="keyword">int</span> curr, <span class="keyword">int</span> tarl, <span class="keyword">int</span> tarr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tarr &lt; curl || curr &lt; tarl)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tarl &lt;= curl &amp;&amp; curr &lt;= tarr) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodes[root].value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(root, curl, curr);</span><br><span class="line">        <span class="keyword">int</span> m = (curl + curr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tarl &lt;= m) ret += <span class="built_in">query</span>(<span class="built_in">Lchild</span>(root), curl, m, tarl, tarr);</span><br><span class="line">        <span class="keyword">if</span> (tarr &gt; m) ret += <span class="built_in">query</span>(<span class="built_in">Rchild</span>(root), m + <span class="number">1</span>, curr, tarl, tarr);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">SegmentTree tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        x[++x_size] = a[i].l = <span class="built_in">read</span>();</span><br><span class="line">        x[++x_size] = a[i].r = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(x + <span class="number">1</span>, x + x_size + <span class="number">1</span>);</span><br><span class="line">    realx_size = <span class="built_in">unique</span>(x + <span class="number">1</span>, x + x_size + <span class="number">1</span>) - x - <span class="number">1</span>;</span><br><span class="line">    x_size = realx_size;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x_size; ++i)</span><br><span class="line">        <span class="keyword">if</span>(x[i] - x[i - <span class="number">1</span>] &gt; <span class="number">1</span>) x[++realx_size] = x[i] - <span class="number">1</span>, x[++realx_size] = x[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    x_size = realx_size;</span><br><span class="line">    <span class="built_in">sort</span>(x + <span class="number">1</span>, x + x_size + <span class="number">1</span>);</span><br><span class="line">    realx_size = <span class="built_in">unique</span>(x + <span class="number">1</span>, x + x_size + <span class="number">1</span>) - x - <span class="number">1</span>;</span><br><span class="line">    tree.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, realx_size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        L = <span class="built_in">lower_bound</span>(x + <span class="number">1</span>, x + realx_size + <span class="number">1</span>, a[i].l) - x;</span><br><span class="line">        R = <span class="built_in">lower_bound</span>(x + <span class="number">1</span>, x + realx_size + <span class="number">1</span>, a[i].r) - x;</span><br><span class="line">        tree.<span class="built_in">updateSet</span>(<span class="number">1</span>, <span class="number">1</span>, realx_size, L, R, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= realx_size; ++i)</span><br><span class="line">        c[i] = tree.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, realx_size, i, i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; realx_size; ++i)</span><br><span class="line">        ans = (ans + <span class="built_in">sum</span>(x[i], x[i + <span class="number">1</span>] - <span class="number">1</span>) * (<span class="number">1ll</span> * c[i])) % MOD;</span><br><span class="line">    ans = (ans + x[realx_size] * (<span class="number">1ll</span> * c[realx_size])) % MOD;</span><br><span class="line">    <span class="built_in">write</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><strong>接雨水</strong></p><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">LC-42.接雨水</a></p><h1 id="堆-栈"><a href="#堆-栈" class="headerlink" title="堆/栈"></a>堆/栈</h1><h2 id="LC-20-有效的括号"><a href="#LC-20-有效的括号" class="headerlink" title="LC-20.有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">LC-20.有效的括号</a></h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">输入：s = &quot;([)]&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">输入：s = &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; pairs = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pairs.<span class="built_in">count</span>(ch)) &#123; <span class="comment">//左括号为0，压入栈</span></span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != pairs[ch]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="棋盘-最短路径"><a href="#棋盘-最短路径" class="headerlink" title="棋盘 最短路径"></a>棋盘 最短路径</h1><p>重要</p><h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="0831-pdd01"><a href="#0831-pdd01" class="headerlink" title="0831-pdd01"></a>0831-pdd01</h2><p><strong>输入描述：</strong></p><blockquote><p>第一行包含一个整数 T (1&lt;=T&lt;=5)，表示有 T 组数据</p><p>接下俩魅族数据三行输入，第一行包含3个整数 n，m，k(1&lt;=n,m&lt;=10000,0&lt;=k&lt;=100)</p><p>分别表示红色方块数，蓝色方块数和能配对消除的最大数字差异</p><p>第二行包含n个整数，ai（1&lt;=ai&lt;=100）表示第 i 个红色方块上的数字</p><p>第三行包含n个整数，bi（1&lt;=bi&lt;=100）表示第 i 个蓝色方块上的数字</p></blockquote><p><strong>输出描述：</strong></p><blockquote><p>每组数据输出一行ans，表示该剧游戏最多能获得的分数</p></blockquote><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">1</span><br><span class="line">3 4 1</span><br><span class="line">5 2 3</span><br><span class="line">1 2 9 7</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">说明</span><br><span class="line">第1组数据中</span><br><span class="line">第2个红色方块和第1个蓝色方块配对消除</span><br><span class="line">第3个红色方块和第2个蓝色方块配对消除</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-08-31 23:51:48</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-01 15:54:31</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,T;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn],match[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;cin&gt;&gt;a[i];&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;cin&gt;&gt;b[i];&#125;</span><br><span class="line">        <span class="built_in">sort</span>(a,a+n);<span class="built_in">sort</span>(b,b+m);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;m) &#123;</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">abs</span>(a[i]-b[j]) &lt;= k )&#123;</span><br><span class="line">                i++,j++;</span><br><span class="line">                ans ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(b[j]-a[i] &gt; k ) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]-b[j] &gt; k ) j++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0831-pdd02"><a href="#0831-pdd02" class="headerlink" title="0831-pdd02"></a>0831-pdd02</h2><p>一个字符串，长为<code>len</code>，对于<code> 0&lt;= i &lt;= len-1</code>，字符串下标<code>i</code>和<code> len -1 -i</code>可以交换位置</p><p>给定两个字符串 a，b，a的任何状态的字典序小于 b 的任何状态的字典序，则a&lt;b</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">2</span><br><span class="line">dcba</span><br><span class="line">abcd</span><br><span class="line">输出</span><br><span class="line">dcba</span><br><span class="line">abcd</span><br><span class="line">说明：2代表接下来2行输入2个字符串，字典序相等时优先输出先输入的字符串</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">2</span><br><span class="line">abcde</span><br><span class="line">abcdeaf</span><br><span class="line">输出</span><br><span class="line">abcdeaf</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义排序</span></span><br><span class="line"><span class="comment"> * 比较待排序字符串数组的minstring</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minstring</span><span class="params">(string &amp;s)</span></span>&#123; <span class="comment">//传引用，形参修饰实参</span></span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len/<span class="number">2</span>; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[j]&gt;s[len<span class="number">-1</span>-j]) <span class="built_in">swap</span>(s[j],s[len<span class="number">-1</span>-j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(string s1, string s2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">minstring</span>(s1);</span><br><span class="line">    <span class="built_in">minstring</span>(s2);</span><br><span class="line">    <span class="keyword">return</span> s1 &lt; s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)  cin &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        cout &lt;&lt; s[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0831-pdd03"><a href="#0831-pdd03" class="headerlink" title="0831-pdd03"></a>0831-pdd03</h2><p>有n根火柴，最多能拼成多少个1*1的小正方形</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 数学模拟</span></span><br><span class="line"><span class="comment"> * 假设先凑一个边长m的正方形，则一共需要2m(m+1)根火柴</span></span><br><span class="line"><span class="comment"> * 先开根求m，然后一次模拟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll m = <span class="built_in">sqrt</span>(n / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        ll ans = m * m;</span><br><span class="line">        n -= <span class="number">2</span> * (m + <span class="number">1</span>) * m;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//一侧开始外扩</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">3</span>)</span><br><span class="line">                ans++, n -= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">2</span> * m - <span class="number">2</span>)&#123;</span><br><span class="line">                ans += m - <span class="number">1</span>;</span><br><span class="line">                n -= <span class="number">2ll</span> * m - <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans += n / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//另一侧开始外扩</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">3</span>)</span><br><span class="line">                ans++, n -= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">2</span> * m)&#123;</span><br><span class="line">                ans += m;</span><br><span class="line">                n -= <span class="number">2ll</span> * m;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans += n / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0901-小米"><a href="#0901-小米" class="headerlink" title="0901-小米"></a>0901-小米</h2><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">LC-88.合并两个有序数组(小米笔试)</a></p><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br><span class="line"></span><br><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line"></span><br><span class="line">输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><blockquote><ul><li>nums1.length == m + n</li><li>nums2.length == n</li><li>0 &lt;= m, n &lt;= 200</li><li>1 &lt;= m + n &lt;= 200</li><li>-10^9 &lt;= nums1[i], nums2[j] &lt;= 10^9</li></ul></blockquote><p><strong>设计实现一个时间复杂度为 O(m + n) 的算法解决此问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-02 22:12:46</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-02 22:35:20</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt; &amp;nums2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = m + m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span>)</span><br><span class="line">            nums1[len--] = nums2[j--];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">            nums1[len--] = nums1[i--];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j])</span><br><span class="line">            nums1[len--] = nums2[j--];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums1[len--] = nums1[i--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int idx = s.find(&#x27;,&#x27;);</span></span><br><span class="line">    <span class="comment">// m = stoi(s.substr(2, idx - 2));</span></span><br><span class="line">    <span class="comment">// n = stoi(s.substr(idx + 3, s.size() - 1));</span></span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ss,tmp,<span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp.<span class="built_in">substr</span>(<span class="number">2</span>,tmp.<span class="built_in">size</span>()<span class="number">-1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    m = data[<span class="number">0</span>], n=data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(m + n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge</span>(a, m, b, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a[a.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> * m=3,n=3</span></span><br><span class="line"><span class="comment"> * 1 2 3</span></span><br><span class="line"><span class="comment"> * 2 5 6</span></span><br><span class="line"><span class="comment"> * 输出：</span></span><br><span class="line"><span class="comment"> * 1 2 2 3 5 6</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="0906-莉莉丝01"><a href="#0906-莉莉丝01" class="headerlink" title="0906-莉莉丝01"></a>0906-莉莉丝01</h2><p>有一个链表，头节点为head，先要对链表重新排序，排序规则如下，即以链表头元素为初始节点，原链表的节点一次作为新链表的为节点和头节点插入链表，返回新的链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">输入</span><br><span class="line">1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line">输出</span><br><span class="line">5-&gt;3-&gt;1-&gt;2-&gt;4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双向队列 deque</span></span><br><span class="line"><span class="comment"> * 使用dummy节点新建链表 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">formatList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        deque&lt;ListNode *&gt; de;</span><br><span class="line">        de.<span class="built_in">push_back</span>(head);</span><br><span class="line">        ListNode *cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                de.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                de.<span class="built_in">push_front</span>(cur);</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *tmp = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; de.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            tmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(de[i]-&gt;val);</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//新建链表，并输出</span></span><br><span class="line">    <span class="comment">// ListNode *myhead = new ListNode(1);</span></span><br><span class="line">    <span class="comment">// ListNode *a = myhead, *b;</span></span><br><span class="line">    <span class="comment">// for (int i = 2; i &lt; 6; ++i)&#123;</span></span><br><span class="line">    <span class="comment">//     b = new ListNode(i);</span></span><br><span class="line">    <span class="comment">//     a-&gt;next = b;</span></span><br><span class="line">    <span class="comment">//     a = b;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// while (myhead-&gt;next)&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; myhead-&gt;val &lt;&lt; &quot;-&gt;&quot;;</span></span><br><span class="line">    <span class="comment">//     myhead = myhead-&gt;next;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; myhead-&gt;val &lt;&lt; endl;\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode *tmp = dummy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; ++i)&#123;</span><br><span class="line">        tmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i);</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    res = <span class="built_in">Solution</span>().formatList(dummy-&gt;next);</span><br><span class="line">    <span class="keyword">while</span>(res-&gt;next)&#123;</span><br><span class="line">        cout &lt;&lt; res-&gt;val &lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0906-莉莉丝02"><a href="#0906-莉莉丝02" class="headerlink" title="0906-莉莉丝02"></a>0906-莉莉丝02</h2><p>有一个链表，头节点为head，先要对链表重新排序，排序规则如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">输入</span><br><span class="line">2-&gt;1-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出</span><br><span class="line">1-&gt;2-&gt;3-&gt;1-&gt;2</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">3-&gt;2-&gt;3-&gt;1-&gt;1-&gt;3</span><br><span class="line">输出</span><br><span class="line">1-&gt;2-&gt;3-&gt;1-&gt;3-&gt;3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * max_element</span></span><br><span class="line"><span class="comment"> * vector&lt;pair&lt;int, int&gt;&gt; vec</span></span><br><span class="line"><span class="comment"> * 千万别 unordered_map&lt;ListNode*, int&gt; mp</span></span><br><span class="line"><span class="comment"> * 新建链表，输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur)&#123;</span><br><span class="line">            mp[cur-&gt;val]++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : mp)</span><br><span class="line">            vec.<span class="built_in">push_back</span>(it);</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">max_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)&#123; <span class="keyword">return</span> a.second &lt; b.second; &#125;);</span><br><span class="line">        <span class="keyword">int</span> maxnum = it-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)&#123; <span class="keyword">return</span> a.first &lt; b.first; &#125;);</span><br><span class="line"></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *tmp = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxnum; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (vec[j].second &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    tmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(vec[j].first);</span><br><span class="line">                    vec[j].second--;</span><br><span class="line">                    tmp = tmp-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode *tmp = dummy;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">8</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">        tmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(arr[i]);</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    res = <span class="built_in">Solution</span>().<span class="built_in">sortList</span>(dummy-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (res-&gt;next)&#123;</span><br><span class="line">        cout &lt;&lt; res-&gt;val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;2-&gt;4-&gt;2-&gt;4</span></span><br></pre></td></tr></table></figure><h2 id="0907-百度01"><a href="#0907-百度01" class="headerlink" title="0907-百度01"></a>0907-百度01</h2><p>大致题意为：有大小为N的方形矩阵，现将矩阵放大k倍，返回放大后的矩阵</p><p><strong>输入描述</strong></p><p>第一行输入两个整数N，K；接下来N行输入方向矩阵</p><p><strong>输出描述</strong></p><p>输出放大后的矩阵</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">2 2</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br><span class="line">输出</span><br><span class="line">0 0 1 1</span><br><span class="line">0 0 1 1 </span><br><span class="line">1 1 0 0 </span><br><span class="line">1 1 0 0 </span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">3 3</span><br><span class="line">1 0 1</span><br><span class="line">0 0 0</span><br><span class="line">1 0 1</span><br><span class="line">输出</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 模拟 先对列或行进行操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, K;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(N, vector&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            cin &gt;&gt; vec[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(K * N, vector&lt;<span class="keyword">int</span>&gt;(K * N, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; K; ++k)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; K; ++t)&#123;</span><br><span class="line">                    res[i * K + k][j * K + t] = vec[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K * N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K * N; ++j)&#123;</span><br><span class="line">            cout &lt;&lt; res[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0907-百度02"><a href="#0907-百度02" class="headerlink" title="0907-百度02"></a>0907-百度02</h2><p>大致题意为：给定一个整数N，若gcd(x,y)=1，且lcm(x,y)=N，则(x,y)为一对符合要求的答案。如N=30，(1，30)、(2，15)、(3，10)、(5，6)为满足条件的4对数。注：(2，15)和(15，2)为一对符合要求的答案</p><p><strong>输入描述</strong></p><p>第一行给出一个自然数T，表示测试用例的数量</p><p>接下来T行测试用例，每行给出一个自然数N</p><p>1 &lt;= T &lt;= 10^3    1 &lt;= N &lt;= 10^8</p><p><strong>输出描述</strong></p><p>按顺序输出每个测试用例的答案</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">1</span><br><span class="line">30</span><br><span class="line">输出</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">2</span><br><span class="line">16</span><br><span class="line">2021</span><br><span class="line">输出</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gcd(x,y) * lcm(x,y)  = x * y</span></span><br><span class="line"><span class="comment"> * __gcd(x,y)为自带求解最小公约数的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">cin&gt;&gt;N;</span><br><span class="line"><span class="keyword">int</span> count= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="built_in">sqrt</span>(N); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = N/i;</span><br><span class="line">        <span class="keyword">if</span>(__gcd(i,j)==<span class="number">1</span> &amp;&amp; N==i*j)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0911-美团01"><a href="#0911-美团01" class="headerlink" title="0911-美团01"></a>0911-美团01</h2><h2 id="091158-同城01"><a href="#091158-同城01" class="headerlink" title="091158-同城01"></a>091158-同城01</h2><p>输入一个整数数组Array，长度为len，求指定长度sublen子数组和的最大值</p><p>输出最大子数组和以及最大子数组起始下标</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[1, 2, 30, 4, 5, 6, 7, 8, 9, 10], 10, 3</span><br><span class="line">输出</span><br><span class="line">[2， 39]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双指针，滑动窗口</span></span><br><span class="line"><span class="comment"> * left 从0遍历到len-sublen，即[0, len-sublen]</span></span><br><span class="line"><span class="comment"> * right = left + sublen -1</span></span><br><span class="line"><span class="comment"> * 滑动窗口 [left, left+sublen-1]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> len, <span class="keyword">int</span> sublen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxres=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>; left&lt;=len-sublen; left++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=left; i&lt;=left + sublen - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; maxres)&#123;</span><br><span class="line">            maxres = sum;</span><br><span class="line">            res.<span class="built_in">clear</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(i-sublen);</span><br><span class="line">            res.<span class="built_in">push_back</span>(maxres);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">30</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    res = <span class="built_in">maxSub</span>(arr, arr.<span class="built_in">size</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        cout &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0912-巨人网络"><a href="#0912-巨人网络" class="headerlink" title="0912- 巨人网络"></a>0912- 巨人网络</h2><p>【==列数未知==】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">//资源数量</span><br><span class="line">5</span><br><span class="line">//资源编号，大小，依赖资源编号</span><br><span class="line">1001， 5</span><br><span class="line">1002， 10</span><br><span class="line">1000， 3， 1001， 1002</span><br><span class="line">2000， 7</span><br><span class="line">3000， 2， 2000</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">//占用资源最大的资源编号及大小</span><br><span class="line">1000， 18</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;data.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            vec[i][j] = data[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(vec[i].<span class="built_in">size</span>()==<span class="number">2</span>) sum+=vec[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;vec[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; ++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vec[i][j]==vec[k][<span class="number">0</span>])&#123;</span><br><span class="line">                    sum += vec[k][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;vec[i][<span class="number">0</span>],sum+vec[i][<span class="number">1</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), [](vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>]&gt;b[<span class="number">1</span>];&#125;);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; res[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0913-bilibili02"><a href="#0913-bilibili02" class="headerlink" title="0913-bilibili02"></a>0913-bilibili02</h2><p>【==行数，列数未知==】</p><p>给定一个二维数组，每行严格递增，找出在这些行中出现的最小的元素，如没有输出-1</p><p><strong>输入</strong></p><ul><li>每行一个数组，每个数组逗号分隔</li></ul><p><strong>输出</strong></p><ul><li>输出一个整数</li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">1,23,4,5,9</span><br><span class="line">2,4,5,8,9</span><br><span class="line">3,5,7,9,11</span><br><span class="line">1,3,5,7,9</span><br><span class="line">输出</span><br><span class="line">5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-13 18:21:43</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-13 21:52:19</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//判断 整数 n 是否在数组 arr 中出现过</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">find</span>(arr[i])==st.<span class="built_in">end</span>())&#123;</span><br><span class="line">            st.<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> res = st.<span class="built_in">count</span>(n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s))&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//跳出输入</span></span><br><span class="line">        string tmp;</span><br><span class="line">        data.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp));<span class="comment">//先存行</span></span><br><span class="line">        &#125;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(data);<span class="comment">//再存每行数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](vector&lt;<span class="keyword">int</span>&gt; a,vector&lt;<span class="keyword">int</span>&gt; b) &#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vec[<span class="number">0</span>].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;vec.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            flag = flag &amp;&amp; <span class="built_in">contain</span>(vec[j],vec[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) res.<span class="built_in">push_back</span>(vec[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; res[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0916-zoom01"><a href="#0916-zoom01" class="headerlink" title="0916-zoom01"></a>0916-zoom01</h2><p><strong>输入</strong></p><p>一个不知道列数的一维数组</p><p><strong>输出</strong></p><p>返回前3大个数，及其在原数组种的下标</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">63 23 22 28 57 46 85 71</span><br><span class="line">输出</span><br><span class="line">(7, 85) (8, 71) (1, 63) </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-16 16:39:35</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-17 14:30:04</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 列数未知， 输入一行判断结束  多行输入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">     <span class="keyword">int</span> tmp;</span><br><span class="line">     <span class="keyword">while</span>(cin&gt;&gt;tmp)&#123;</span><br><span class="line">         a.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">         <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;a[i],i+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; a.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; res.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[j].first == a[i])&#123;</span><br><span class="line">                    b = res[j].second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span>&lt;&lt; a[i] &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; res.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[j].first == a[i])&#123;</span><br><span class="line">                    b = res[j].second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span>&lt;&lt; a[i] &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0916-腾讯音乐03"><a href="#0916-腾讯音乐03" class="headerlink" title="0916 -腾讯音乐03"></a>0916 -腾讯音乐03</h2><p>k进制下 1-m 中数字1出现的次数，记作F(m, k)，例如F(5, 3) = 5，因为三进制 1-5为{1， 2， 10， 11， 12}，数字1出现了5次，先给定k和n，求使得 F(m, k) &gt;=n 的最小m，返回吗。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">5，3</span><br><span class="line">输出</span><br><span class="line">5</span><br><span class="line">说明</span><br><span class="line">F(m, 3)&gt;=5，最小的m为5</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">10，10</span><br><span class="line">输出</span><br><span class="line">17</span><br><span class="line">说明</span><br><span class="line">F(m, 10)&gt;=10，最小的m为17</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  转k进制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">intTox</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t=num%k;</span><br><span class="line">            <span class="keyword">if</span>(t&gt;=<span class="number">0</span> &amp;&amp; t&lt;<span class="number">9</span>) res += t + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> res += t<span class="number">-10</span>+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            num /= k;</span><br><span class="line">        &#125;<span class="keyword">while</span>(num!=<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == <span class="string">&#x27;1&#x27;</span>) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">intT</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t=num%k;</span><br><span class="line">            <span class="keyword">if</span>(t&gt;=<span class="number">10</span>) res += t<span class="number">-10</span>+<span class="string">&#x27;a&#x27;</span>; <span class="comment">//大于10进制</span></span><br><span class="line">            <span class="keyword">else</span> res += t + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            num /= k;</span><br><span class="line">        &#125;<span class="keyword">while</span>(num!=<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">minM</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here        </span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; res &lt; n; ++i)&#123;</span><br><span class="line">            res += <span class="built_in">intTox</span>(i, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">    ans = <span class="built_in">Solution</span>().<span class="built_in">minM</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ans;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0918电信云02"><a href="#0918电信云02" class="headerlink" title="0918电信云02"></a>0918电信云02</h2><p>实现简单计算器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="keyword">char</span>&gt; op;</span><br><span class="line">stack&lt;<span class="keyword">double</span>&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chartoint</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c - <span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isoperate</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priori</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">iswhatandcompute</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">double</span> n1, <span class="keyword">double</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">return</span> n1 * n2;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;/&#x27;</span>) <span class="keyword">return</span> n2 / n1;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> n2 + n1;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> n2 - n1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> size_s = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size_s;) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>) &#123;i++; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isoperate</span>(s[i])) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!op.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">char</span> t = op.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">priori</span>(t) &gt;= <span class="built_in">priori</span>(s[i])) &#123;</span><br><span class="line">                    <span class="keyword">double</span> n1 = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">double</span> n2 = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">double</span> n3 = <span class="built_in">iswhatandcompute</span>(t, n1, n2);</span><br><span class="line">                    num.<span class="built_in">push</span>(n3);</span><br><span class="line">                    op.<span class="built_in">pop</span>();</span><br><span class="line">                    op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> n = <span class="built_in">chartoint</span>(s[i]);</span><br><span class="line">            num.<span class="built_in">push</span>(n);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!op.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = op.<span class="built_in">top</span>(); op.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">double</span> t1 = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">double</span> t2 = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">double</span> t3 = <span class="built_in">iswhatandcompute</span>(t, t1, t2);</span><br><span class="line">            num.<span class="built_in">push</span>(t3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> n = num.<span class="built_in">top</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="built_in">compute</span>(s);</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0919寒武纪"><a href="#0919寒武纪" class="headerlink" title="0919寒武纪"></a>0919寒武纪</h2><p>为使数组有序，最少交换次数</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">5 2 1 4 3</span><br><span class="line">输出</span><br><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 更倾向getminswap方法 哈希表对重复元素不🆗</span></span><br><span class="line"><span class="comment"> * val idx      pair     交换1次   交换2次           </span></span><br><span class="line"><span class="comment"> *  5   0      1   2     3   4    5   0</span></span><br><span class="line"><span class="comment"> *  2   1      2   1     2   1    2   1</span></span><br><span class="line"><span class="comment"> *  1   2      3   4     1   2    1   2</span></span><br><span class="line"><span class="comment"> *  4   3      4   3     4   3    4   3</span></span><br><span class="line"><span class="comment"> *  3   4      5   0     5   0    3   4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getminswap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  vec.<span class="built_in">push_back</span>(&#123;arr[i], i&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[i].second == i)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(vec[i].first, vec[vec[i].second].first);</span><br><span class="line">        <span class="built_in">swap</span>(vec[i].second, vec[vec[i].second].second);</span><br><span class="line">        <span class="keyword">if</span> (i != vec[i].second)&#123;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getminswap2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  vec.<span class="built_in">push_back</span>(&#123;arr[i], i&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;b)&#123;<span class="keyword">return</span> a.first &gt; b.first;&#125;);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[i].second == i)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(vec[i].first, vec[vec[i].second].first);</span><br><span class="line">            <span class="built_in">swap</span>(vec[i].second, vec[vec[i].second].second);</span><br><span class="line">            <span class="keyword">if</span> (i != vec[i].second)&#123;</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// int n;</span></span><br><span class="line">        <span class="comment">// cin &gt;&gt; n;</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; vec(n,0);</span></span><br><span class="line">        <span class="comment">// for(int i=0; i&lt;n; ++i) cin &gt;&gt; vec[i];</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">data</span><span class="params">(vec)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) mp[data[i]] = i;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">flag</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">while</span> (!flag[j])&#123;</span><br><span class="line">                    flag[j] = <span class="literal">true</span>;</span><br><span class="line">                    j = mp[vec[j]];</span><br><span class="line">                &#125;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) mp2[data[i]] = n-i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res2=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">flag2</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag2[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">while</span> (!flag2[j])&#123;</span><br><span class="line">                    flag2[j] = <span class="literal">true</span>;</span><br><span class="line">                    j = mp2[vec[j]];</span><br><span class="line">                &#125;</span><br><span class="line">                res2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">min</span>(n - res, n - res2);</span><br><span class="line">        <span class="comment">// int ans = min(getminswap(vec, vec.size()), getminswap2(vec, vec.size()));</span></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1009京东"><a href="#1009京东" class="headerlink" title="1009京东"></a>1009京东</h2><p><strong>输入</strong></p><ul><li>第一行有一个整数n，表示产品的数量</li><li>第二行有n个空格隔开的整数，一致度为n个数中出现次数最多的个数</li></ul><p><strong>输出</strong></p><ul><li>两个下标</li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">6</span><br><span class="line">4 2 1 2 2 3</span><br><span class="line">输出</span><br><span class="line">2 5</span><br><span class="line">解释：一致性为3，所选序列 2 1 2 2，下标从2到5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-10-08 18:05:15</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-10-10 18:45:10</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// int n;</span></span><br><span class="line">    <span class="comment">// cin &gt;&gt; n;</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt; a(n);</span></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i) cin &gt;&gt; a[i];</span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">8</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:a) mp[x]++;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; ma;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:mp)&#123;</span><br><span class="line">        ma.<span class="built_in">push_back</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ma.<span class="built_in">begin</span>(), ma.<span class="built_in">end</span>(), [](pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; b)&#123;<span class="keyword">return</span> a.second &gt; b.second;&#125;);</span><br><span class="line">    <span class="comment">// int maxlen = ma[0].second;</span></span><br><span class="line">    <span class="comment">// int maxnum = ma[0].first;</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>, d=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ma[d].second=ma[d+<span class="number">1</span>].second)&#123;</span><br><span class="line">        c++;</span><br><span class="line">        d++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; left, right, len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]==ma[i].first)&#123;</span><br><span class="line">                left.<span class="built_in">push_back</span>(j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;<span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]==ma[i].first)&#123;</span><br><span class="line">                right.<span class="built_in">push_back</span>(j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len.<span class="built_in">push_back</span>(right[i]-left[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">min_element</span>(len.<span class="built_in">begin</span>(), len.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:len) cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dis = <span class="built_in">distance</span>(len.<span class="built_in">begin</span>(),it); <span class="comment">//根据迭代器求下标</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; left[dis]+<span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; right[dis]+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">整理记录刷的算法题，好记性不如烂笔头啊！题解参考了Grand Yang(https://github.com/grandyang)</summary>
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/02/14/hello-world/"/>
    <id>http://example.com/2021/02/14/hello-world/</id>
    <published>2021-02-13T16:00:00.000Z</published>
    <updated>2023-12-31T18:44:13.893Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><p>[TOC]</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-hexo"><a href="#Install-hexo" class="headerlink" title="Install hexo"></a>Install hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="Create-myblog"><a href="#Create-myblog" class="headerlink" title="Create myblog"></a>Create myblog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init myblog</span><br></pre></td></tr></table></figure><p><strong>出现 hexo init 失败问题，<a href="https://blog.csdn.net/qq_43580193/article/details/117341489?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">解决方法</a>替换Github连接</strong></p><h3 id="将Hexo部署到GitHub"><a href="#将Hexo部署到GitHub" class="headerlink" title="将Hexo部署到GitHub"></a>将Hexo部署到GitHub</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git #冒号后面有空格</span><br><span class="line">  repository: git@github.com:xuhuigeren/xuhuigeren.github.io.git  #ssh/https仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><strong>回到 myblog 文件夹中，打开 Git Bash，安装Git部署插件，输入命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><strong>然后分别输入以下三条命令：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   <span class="comment">#清除缓存文件 db.json 和已生成的静态文件 public</span></span><br><span class="line">hexo g       <span class="comment">#生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span></span><br><span class="line">hexo d       <span class="comment">#自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span></span><br></pre></td></tr></table></figure><p><strong>完成以后，打开浏览器，输入 <a href="https://xuhuigeren.github.io/">https://xuhuigeren.github.io</a>  就可以打开你的网页了</strong></p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">Welcome to Hexo</summary>
    
    
    
    <category term="我的博客" scheme="http://example.com/categories/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
