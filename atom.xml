<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>桥头打字员</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-24T06:25:11.751Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Henry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GStreamer学习笔记--GObject类对象</title>
    <link href="http://example.com/2021/07/17/gstreamer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gobject%E7%B1%BB%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2021/07/17/gstreamer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gobject%E7%B1%BB%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-07-17T08:48:47.000Z</published>
    <updated>2021-07-24T06:25:11.751Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="GStreamer学习笔记–GObject类对象"><a href="#GStreamer学习笔记–GObject类对象" class="headerlink" title="GStreamer学习笔记–GObject类对象"></a>GStreamer学习笔记–GObject类对象</h1><h2 id="Gobject类定义"><a href="#Gobject类定义" class="headerlink" title="Gobject类定义"></a>Gobject类定义</h2><p>维基百科：<strong>GObject</strong>，是一个在<a href="https://zh.wikipedia.org/wiki/LGPL">LGPL</a>下发布的<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6">自由</a><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BA%93">软件库</a>，它提供了一个轻便的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F&action=edit&redlink=1">对象系统</a>并支持透明的多语言互通。GObject被设计为可以直接使用在<a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">C</a>程序中，也可以被封装至其他语言，例如<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a>，<a href="https://zh.wikipedia.org/wiki/Java">Java</a>，<a href="https://zh.wikipedia.org/wiki/Python">Python</a>，以及可以生成C代码的<a href="https://zh.wikipedia.org/wiki/Vala">Vala</a>（由此大大简化了<code>GObject</code>代码的书写）等等。</p><p><code>Gstreamer</code>框架是基于插件的，同时插件是可以动态的注册、创建，<code>gstreamer</code>基于<code>Gobject</code>开发，下面来了解一下<code>gstreamer</code>是如何通过<code>Gobject</code>完成自定义类的注册。</p><p>在每个类的<code>c</code>文件中，都会有以下这样的一个宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G_DEFINE_TYPE (GstV4l2Allocator, gst_v4l2_allocator, GST_TYPE_ALLOCATOR);</span><br></pre></td></tr></table></figure><p><code>G_DEFINE_TYPE</code>是一个宏定义，那么这个<code>G_DEFINE_TYPE</code>宏是如何完成向<code>Gobject</code>系统完成类的注册呢？</p><p>将<code>G_DEFINE_TYPE</code>展开可以看到以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G_DEFINE_TYPE(TN, t_n, T_P)</span></span><br><span class="line"><span class="comment">/******* </span></span><br><span class="line"><span class="comment"> *TN  ---&gt; TypeName</span></span><br><span class="line"><span class="comment"> *t_n ---&gt; type_name</span></span><br><span class="line"><span class="comment"> *T_P ---&gt; TYPE_PARENT</span></span><br><span class="line"><span class="comment"> *_f_ ---&gt; 0</span></span><br><span class="line"><span class="comment"> *_c_ ---&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">******/</span></span><br><span class="line"><span class="comment">/*****   以下为宏展开   *****/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>     type_name##_init              (TypeName        *self); </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>     type_name##_class_init        (TypeName##Class *klass); </span><br><span class="line"><span class="keyword">static</span> gpointer type_name##_parent_class = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> gint     TypeName##_private_offset;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>     type_name##_class_intern_init (gpointer klass)</span><br><span class="line">&#123;</span><br><span class="line">  type_name##_parent_class = g_type_class_peek_parent (klass);</span><br><span class="line">  <span class="keyword">if</span> (TypeName##_private_offset != <span class="number">0</span>)</span><br><span class="line">    g_type_class_adjust_private_offset (klass, &amp;TypeName##_private_offset);</span><br><span class="line">  type_name##_class_init ((TypeName##Class*) klass);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> gpointer</span><br><span class="line">type_name##_get_instance_private (TypeName *self)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (G_STRUCT_MEMBER_P (self, TypeName##_private_offset));</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">GType </span><br><span class="line">type_name##_get_type (<span class="keyword">void</span>) </span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">volatile</span> gsize g_define_type_id__volatile = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Prelude goes here */</span></span><br><span class="line">  <span class="keyword">if</span> (g_once_init_enter (&amp;g_define_type_id__volatile))</span><br><span class="line">    &#123;</span><br><span class="line">      GType g_define_type_id =</span><br><span class="line">        g_type_register_static_simple (TYPE_PARENT,</span><br><span class="line">                                       g_intern_static_string (#TypeName),</span><br><span class="line">                                       <span class="keyword">sizeof</span> (TypeName##Class),</span><br><span class="line">                                       (GClassInitFunc)(<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) type_name##_class_intern_init,</span><br><span class="line">                                       <span class="keyword">sizeof</span> (TypeName),</span><br><span class="line">                                       (GInstanceInitFunc)(<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) type_name##_init,</span><br><span class="line">                                       (GTypeFlags) flags);</span><br><span class="line">      &#123; <span class="comment">/* custom code follows */</span></span><br><span class="line">      &#123;_C_;&#125;</span><br><span class="line">        <span class="comment">/* following custom code */</span></span><br><span class="line">      &#125;</span><br><span class="line">      g_once_init_leave (&amp;g_define_type_id__volatile, g_define_type_id);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> g_define_type_id__volatile;</span><br><span class="line">&#125; <span class="comment">/* closes type_name##_get_type() */</span></span><br></pre></td></tr></table></figure><h2 id="向Gobject系统注册类"><a href="#向Gobject系统注册类" class="headerlink" title="向Gobject系统注册类"></a>向Gobject系统注册类</h2><p><code>G_DEFINE_TYPE</code>定义如上，那么，最终它是如何向<code>Gobject</code>系统注册该类的呢？<br><code>Gobject</code>系统为什么知道你新添加了一个名叫<code>TypeName</code>的类，是因为你通过<code>g_type_register_static_simple()</code>函数告诉它，我这里有一个新类，你登记一下<code>g_type_register_static_simple()</code>函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLIB_AVAILABLE_IN_ALL</span></span><br><span class="line"><span class="function">GType <span class="title">g_type_register_static_simple</span>     <span class="params">(GType                       parent_type,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> gchar                *type_name,</span></span></span><br><span class="line"><span class="params"><span class="function"> guint                       class_size,</span></span></span><br><span class="line"><span class="params"><span class="function"> GClassInitFunc              class_init,</span></span></span><br><span class="line"><span class="params"><span class="function"> guint                       instance_size,</span></span></span><br><span class="line"><span class="params"><span class="function"> GInstanceInitFunc           instance_init,</span></span></span><br><span class="line"><span class="params"><span class="function"> GTypeFlags             flags)</span></span>;</span><br></pre></td></tr></table></figure><p>函数声明的前面<code>GLIB_AVAILABLE_IN_ALL</code>就是一个<code>extern</code>关键词，从函数声明我们可以了解到，向<code>Gobject</code>系统注册一个类，需要告诉<code>Gobject</code>系统，我现在需要注册一个新类，它父类的类型是<code>parent_type</code>，大小是<code>class_size</code>，类的初始化函数是<code>class_init</code>，类的实例大小以及初始化函数，还有这个类有什么<code>flags</code>，通过告诉<code>Gobject</code>，它就会将新类登记在线。</p><p>通过<code>G_DEFINE_TYPE</code>宏的展开可以知道，在<code>type_name##_get_type()</code>函数中调用到<code>g_type_register_static_simple()</code>函数，那么，究竟是什么时候，程序会向<code>Gobject</code>系统注册该新类呢？<br>比如我们是要注册一个名叫<code>TestObject</code>的类，那么就是通过<code>TestObject_get_type()</code>函数完成<code>estObject</code>的注册登记。<br>在我们需要创建一个<code>TestObject</code>的实例时，会通过调用<code>g_object_new()</code>函数完成，在调用<code>g_object_new</code>函数，需要传进相应的参数，这个时候，我们就将<code>TestObject_get_type()</code>函数的返回值传递给它，即演变成以下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestObject *testObject = （TestObject *）g_object_new (TestObject_get_type(), <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>在创建<code>TestObject</code>实例对象的时候，将会调用<code>TestObject_get_type()</code>函数得到相应的类型，而在<code>TestObject_get_type()</code>函数中，将会先通过<code>g_once_init_enter()</code>函数检查<code>TestObject_get_type()</code>中的静态变量<code>g_define_type_id_volatile</code>是否为0，如果是，则通过<code>g_type_register_static_simple()</code>函数向<code>Gobject</code>系统登记<code>TestObject</code>类，同时返回<code>object ID</code>，如果<code>g_define_type_id_volatile</code>不为0，则说明已经向<code>Gobject</code>系统注册<code>TestObjec</code>t类，直接返回<code>object ID</code>，这样，即完成了<code>TestObject</code>的注册登记。</p><h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><p>学习<code>C++</code>我们都知道，类是有构造函数的，在创建类实例的时候，会自动调用该类的构造函数，那么，在<code>Gobject</code>中，又是怎么调用类的构造函数呢？</p><p>以<code>TestObject</code>为例，在上面说到通过<code>g_type_register_static_simple()</code>函数向<code>Gobject</code>系统注册自定义类的时候，就传进了相应的参数，包括类的初始化函数<code>test_object_class_intern_init()</code>以及类实例的初始化函数<code>test_object_init()</code>，它们两个共同的相当于<code>TestObject</code>类的构造函数。从宏定义<code>G_DEFINE_TYPE</code>的展开代码中发现以下函数声明以及<code>test_object_class_intern_init()</code>函数的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>     <span class="title">test_object_init</span>              <span class="params">(TestObject      *self)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>     <span class="title">test_object_class_init</span>        <span class="params">(TestObjectClass *klass)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>     <span class="title">test_object_class_intern_init</span> <span class="params">(gpointer klass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  test_object_parent_class = g_type_class_peek_parent (klass);</span><br><span class="line">  <span class="keyword">if</span> (test_object_private_offset != <span class="number">0</span>)</span><br><span class="line">    g_type_class_adjust_private_offset (klass, &amp;TestObject_private_offset);</span><br><span class="line">  test_object_class_init ((TestObjectClass*) klass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码我们可以知道，在通过<code>G_DEFINE_TYPE</code>向<code>Gobject</code>系统注册类，还需要我们实现<code>test_object_class_init()</code>和<code>test_object_init()</code>函数的定义。<code>test_object_class_init()</code>函数是在第一次创建<code>TestObject</code>类实例对象的时候调用的，该函数只会调用一次，而<code>test_object_init()</code>函数则是每次创建<code>TestObject</code>类实例对象都会调用。</p><h2 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h2><p>在<code>G_DEFINE_TYPE</code>的展开代码中，可以看到以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> gpointer type_name##_parent_class = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>     type_name##_class_intern_init (gpointer klass)</span><br><span class="line">&#123;</span><br><span class="line">  type_name##_parent_class = g_type_class_peek_parent (klass);</span><br><span class="line">  <span class="keyword">if</span> (TypeName##_private_offset != <span class="number">0</span>)</span><br><span class="line">    g_type_class_adjust_private_offset (klass, &amp;TypeName##_private_offset);</span><br><span class="line">  type_name##_class_init ((TypeName##Class*) klass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个宏中，可以看到定义了一个静态的全局指针变量<code>type_name_parent_class</code>，而<code>type_name_parent_class</code>变量是通过<code>g_type_class_peek_parent()</code>函数赋值的，<code>type_name_parent_class</code>变量代表着什么呢，它就是父类。一般的，会在该源文件新增一个宏，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> type_name##_parent_class parent_class</span></span><br></pre></td></tr></table></figure><p>这样就可以通过宏定义<code>parent_class</code>直接调用父类函数，而该父类，就是在通过宏定义<code>G_DEFINE_TYPE</code>向<code>Gobject</code>系统注册类时传进的第三个参数<code>T_P</code>。<code>g_type_class_peek_parent()</code>函数通过传进的子类指针，查找到注册时候的相应信息，得到父类的类型，而后通过父类类型得到父类信息并返回。</p><h2 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h2><p>有了相应的构造函数，在构造函数中申请了内存、硬件等资源，自然的，也会类似<code>C++</code>的，有相应的析构函数负责资源的释放操作。那么，在<code>Gobject</code>系统中，析构函数又是什么回事呢？我们都知道，构造函数是从父类到子类，而析构函数是从子类到父类。在<code>Gobject</code>系统中的析构函数又是如何的呢？</p><p>之前说到，在通过<code>G_DEFINE_TYPE</code>向<code>Gobject</code>系统，注册<code>TestObject</code>类的时候，需要定义<code>test_object_class_init()</code>和<code>test_object_init()</code>函数，而在类实例的初始化函数<code>test_object_init()</code>中，我们可能申请了一些内存等资源，我们需要在析构函数中释放这些资源，这个时候，需要我们在<code>TestObject</code>类初始化函数<code>test_object_class_init()</code>覆盖从父类继承的析构函数，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void</span><br><span class="line">test_object_dispose (GObject * object)</span><br><span class="line">&#123;</span><br><span class="line">TestObject *testobject = TEST_OBJECT (object);</span><br><span class="line"> </span><br><span class="line">/*  资源释放*/</span><br><span class="line"> </span><br><span class="line">/*  调用父类的dispose 函数 */</span><br><span class="line">G_OBJECT_CLASS (parent_class)-&gt;dispose (object);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void</span><br><span class="line">test_object_finalize (TestObject * testobject)</span><br><span class="line">&#123;</span><br><span class="line">g_free(testobject-&gt;mem);</span><br><span class="line"></span><br><span class="line">    /*  调用父类的finalize 函数 */</span><br><span class="line">G_OBJECT_CLASS (parent_class)-&gt;finalize (object);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void test_object_init(TestObject * self)</span><br><span class="line">&#123;</span><br><span class="line">self-&gt;mem = g_malloc (1);</span><br><span class="line">&#125;</span><br><span class="line">static void test_object_class_init(TestObjectClass *klass)</span><br><span class="line">&#123;</span><br><span class="line">GObjectClass *object_class = G_OBJECT_CLASS (klass);</span><br><span class="line"> </span><br><span class="line">object_class-&gt;dispose = test_object_dispose;</span><br><span class="line">object_class-&gt;finalize = test_object_finalize;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述代码我们可以知道，在<code>TestObject</code>的初始化的时候，将会覆盖从父类继承而来的析构函数，同时在析构函数中释放类实例初始化时占用的资源，同时还有递归调用父类的析构函数。<code>dispose</code>函数主要是将在类中占用的资源释放，而<code>finalize</code>函数则是有点类似真正的析构函数，将构造函数申请的资源进行释放回收。</p><p>既然析构函数也已经有了，析构函数又会是什么时候调用呢？</p><p><code> JAVA</code>使用的是垃圾回收的机制，而<code>Gobjec</code>t则是使用引用计数的方式。当每个对象创建的时候，将会对其引用计数加一，如果期间被其他对象进行引用，也都会将它的引用计数增加；而当对象被解除引用的时候，引用计数将会减一，当引用计数减为0的时候，将会调用对象的析构函数，进行资源的回收。</p><p><code>Gobject</code>的引用计数方式大致如下：</p><ul><li>使用<code>g_object_new()</code>函数进行实例化的时候，对象的引用计数为1；</li><li>使用<code>g_object_ref()</code>函数进行引用对象的时候，对象的引用计数加1；</li><li>使用<code>g_object_unref()</code>函数解除引用的时候，对象的引用计数减1；</li><li>调用<code>g_object_unref()</code>函数进行解引用的时候，如果发现对象的引用计数为0，将会先后调用该对象的<code>dispose()</code>函数和<code>finalize()</code>函数。</li></ul><p>而为什么在<code>test_object_class_init()</code>函数中覆盖从父类继承过来的析构函数呢？<br>因为在<code>g_object_unref()</code>函数中调用<code>dispose()</code>函数和<code>finalize()</code>函数是通过宏定义<code>G_OBJECT_GET_CLASS取得OBJECT_CLASS</code>类之后，再调用它的<code>dispose()</code>函数和<code>finalize()</code>函数，所以需要在<code>TestObject</code>的类初始化函数对这两个函数指针进行覆盖，而在<code>TestObject</code>类的<code>dispose()</code>函数和<code>finalize()</code>函数再通过<code>G_OBJECT_CLASS (parent_class)</code>取得父类指针，调用父类的析构函数。</p><h2 id="类的其他设置"><a href="#类的其他设置" class="headerlink" title="类的其他设置"></a>类的其他设置</h2><p>在<code>Gobject</code>系统中，设置了很多方便的宏，使在使用对象的时候可以更加的方便，在相应的头文件，一般会有如下宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GstTestObject</span> <span class="title">TestObject</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GstTestObjectClass</span> <span class="title">GstTestObjectClass</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 获取类型 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TYPE_TEST_OBJECT      (test_object_get_type())</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 类实例类型判断 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_IS_TEST_OBJECT(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_TEST_OBJECT))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 类结构判定 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_IS_TEST_OBJECT_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_TEST_OBJECT))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 获取obj的类型，同时将其转换为GST_TYPE_TEST_OBJECT，并返回指向GstTestObjectClass的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TEST_OBJECT_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_TEST_OBJECT, GstTestObjectClass))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 检查obj是否是GST_TYPE_TEST_OBJECT类型，如果是，则将返回指向obj成员变量TestObject的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TEST_OBJECT(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_TEST_OBJECT, TestObject))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 检查klass是不是GST_TYPE_TEST_OBJECT类型，如果是，则将返回指向klass成员变量GstTestObjectClass的指针 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TEST_OBJECT_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_TEST_OBJECT, GstTestObjectClass))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 实例结构转换 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GST_TEST_OBJECT_CAST(obj) ((TestObject*)(obj))</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GstTestObject</span> &#123;</span></span><br><span class="line">  GstObject            object;</span><br><span class="line">  gchar *mem;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 类定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GstTestObjectClass</span> &#123;</span></span><br><span class="line">  GstObjectClass    object_class;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是通过上述的宏定义，可以方便的将各种类以及对象进行转换，在子类中可以调用父类的函数等操作，同时，在<code>gstreamer</code>中，还有一些属性设置函数等，进行多样化的类管理。</p><p>另外的，宏定义<code>G_DEFINE_TYPE_WITH_CODE</code>也是实现与<code>G_DEFINE_TYP</code>类似的功能，只不过是可以将一些函数内置在<code>type_name##_get_type()</code>函数中。</p>]]></content>
    
    
    <summary type="html">GObject 设计用于直接在C程序中使用以提供面向对象的基于C的API，并通过与其他语言的绑定来提供透明的跨语言互操作性，例如PyGObject。</summary>
    
    
    
    <category term="Internship" scheme="http://example.com/categories/Internship/"/>
    
    
    <category term="GStreamer" scheme="http://example.com/tags/GStreamer/"/>
    
    <category term="GObject" scheme="http://example.com/tags/GObject/"/>
    
  </entry>
  
  <entry>
    <title>Deepstream 检测安全帽👷</title>
    <link href="http://example.com/2021/07/10/week-2-2/"/>
    <id>http://example.com/2021/07/10/week-2-2/</id>
    <published>2021-07-10T05:32:29.000Z</published>
    <updated>2021-07-24T06:26:21.233Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Yolov3-检测安全帽"><a href="#Yolov3-检测安全帽" class="headerlink" title="Yolov3 检测安全帽"></a>Yolov3 检测安全帽</h1><h2 id="运行自带yolov3示例"><a href="#运行自带yolov3示例" class="headerlink" title="运行自带yolov3示例"></a>运行自带yolov3示例</h2><h3 id="环境和示例说明"><a href="#环境和示例说明" class="headerlink" title="环境和示例说明"></a>环境和示例说明</h3><p><strong>该示例是Deepstream-5.0在Jetson Xavier NX上运行，具体环境部署可以参见<a href="https://xuhuigeren.github.io/2021/07/02/week-1/">这里</a>.</strong></p><p>示例文件在<code>deepstram-5.0\sources\objectDetector_Yolo</code>目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">|-- objectDetector_Yolo</span><br><span class="line">|   |-- config_infer_primary_yoloV2.txt</span><br><span class="line">|   |-- config_infer_primary_yoloV2_tiny.txt</span><br><span class="line">|   |-- config_infer_primary_yoloV3.txt</span><br><span class="line">|   |-- config_infer_primary_yoloV3_tiny.txt</span><br><span class="line">|   |-- deepstream_app_config_yoloV2.txt</span><br><span class="line">|   |-- deepstream_app_config_yoloV2_tiny.txt</span><br><span class="line">|   |-- deepstream_app_config_yoloV3.txt</span><br><span class="line">|   |-- deepstream_app_config_yoloV3_tiny.txt</span><br><span class="line">|   |-- labels.txt</span><br><span class="line">|   |-- prebuild.sh</span><br><span class="line">|   |-- README</span><br><span class="line">|   |-- yolov3-calibration.table.trt7.0</span><br><span class="line">|   |-- nvdsinfer_custom_impl_Yolo             </span><br><span class="line">|       |-- Makefile</span><br><span class="line">|       |-- kernels.cu</span><br><span class="line">|       |-- nvdsinfer_yolo_engine.cpp</span><br><span class="line">|       |-- nvdsparsebbox_Yolo.cpp</span><br><span class="line">|       |-- trt_utils.cpp</span><br><span class="line">|       |-- trt_utils.h</span><br><span class="line">|       |-- yolo.cpp</span><br><span class="line">|       |-- yolo.h</span><br><span class="line">|       |-- yoloPlugins.cpp</span><br><span class="line">|       |-- yoloPlugins.h</span><br></pre></td></tr></table></figure><p><strong>当然是先康康<code>README</code>，果然写的非常细致详尽，介绍了文件目录中每个文件的含义</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Sample contents:</span><br><span class="line">- deepstream_app_config_yolo[V3,V3_tiny,V2,V2_tiny,tlt].txt - DeepStream reference</span><br><span class="line">  app configuration file for using YoloV2/yoloV2-tiny/yolo/yolo-tiny/tlt model</span><br><span class="line">  as the primary detector.</span><br><span class="line">- config_infer_primary_yolo[V3,V3_tiny,V2,V2_tiny,tlt].txt - Configuration file for the GStreamer</span><br><span class="line">  nvinfer plugin for the Yolo detector model.</span><br><span class="line">- yolov3-calibration.table.trt7.0 - yoloV3 INT8 calibration binary on TensorRT 7.0+</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/nvdsinfer_yolo_engine.cpp -</span><br><span class="line">  Implementation of &#x27;NvDsInferCreateModelParser&#x27;/IModelParser for nvdsinfer to</span><br><span class="line">  parse custom models. Alternatively, also contains implementation of</span><br><span class="line">  &#x27;NvDsInferYoloCudaEngineGet&#x27; for nvdsinfer to directly create cuda engine.</span><br><span class="line">  To use the &#x27;NvDsInferYoloCudaEngineGet&#x27; interface, enable the macro</span><br><span class="line">  USE_CUDA_ENGINE_GET_API in nvdsinfer_yolo_engine.cpp</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/nvdsparsebbox_Yolo.cpp - Output layer</span><br><span class="line">  parsing function for detected objects for the Yolo model.</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/yoloPlugins.h -</span><br><span class="line">  Declaration of YoloLayerV3 and YoloLayerV3PluginCreator.</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/yoloPlugins.cpp -</span><br><span class="line">  Implementation of YoloLayerV3 and YoloLayerV3PluginCreator.</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/kernels.cu - Implementation of cuda kernels for</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/trt_utils.h - Utilities to setup tensorRT networks</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/trt_utils.cpp - Implementation of Utilities to setup</span><br><span class="line">   tensorRT networks</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/yolo.h - Interface to create Yolo Cuda-Engine</span><br><span class="line">- nvdsinfer_custom_impl_Yolo/yolo.cpp - Implementation to create Yolo Cuda-Engine</span><br></pre></td></tr></table></figure><p><strong>下载权重和配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Pre-requisites:</span><br><span class="line">- Download yolo config and weights files</span><br><span class="line">  $ ./prebuild.sh         # 可以把脚本里的不需要的部分注释掉，提高下载速度。</span><br><span class="line">- Set correct yolo config/weights file in config_infer_primary_yolo[...].txt.</span><br><span class="line">    custom-network-config # path to yolo config</span><br><span class="line">    model-file # path to yolo weights</span><br><span class="line">- Enable INT8 precision detection if there is a calibration cache file, update</span><br><span class="line">  config_infer_primary_yolo[...].txt.</span><br><span class="line">    int8-calib-file=yolo[...]-calibration.table.trt5.1</span><br><span class="line">- Other INT8 precision calibration table need to be calibrated by user.</span><br><span class="line">- The yolo-tlt sample makes use of a few TensorRT OSS plugins. Download the</span><br><span class="line">  TensorRT OSS repo (https://github.com/NVIDIA/TensorRT/) and checkout the</span><br><span class="line">  &#x27;release/7.0&#x27; branch. Follow the instructions in the README to build the</span><br><span class="line">  plugin library &#x27;libnvinfer_plugin.so.7.0.0&#x27; corresponding to your dGPU/Jetson</span><br><span class="line">  platform. This library needs to be used with LD_PRELOAD to let nvinfer plugin</span><br><span class="line">  access the TRT OSS plugin layers.</span><br><span class="line">- Set the path of the etlt model (tlt-encoded-model) and the tlt model key</span><br><span class="line">  (tlt-model-key) in config_infer_primary_yolo_tlt.txt before running the sample.</span><br></pre></td></tr></table></figure><p><strong>编译工程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Compile the custom library:</span><br><span class="line">  # Based on the API to use &#x27;NvDsInferCreateModelParser&#x27; or &#x27;NvDsInferCudaEngineGet&#x27;</span><br><span class="line">  # set the macro USE_CUDA_ENGINE_GET_API to 0 or 1 in</span><br><span class="line">  # nvdsinfer_custom_impl_Yolo/nvdsinfer_yolo_engine.cpp</span><br><span class="line"></span><br><span class="line">  # Export correct CUDA version (e.g. 10.2, 10.1)</span><br><span class="line">  $ export CUDA_VER=10.2</span><br><span class="line">  $ make -C nvdsinfer_custom_impl_Yolo</span><br><span class="line">  这时候会在nvdsinfer_custom_impl_Yolo文件夹里生成.so文件</span><br></pre></td></tr></table></figure><p><strong>运行示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Run the sample:</span><br><span class="line">The &quot;nvinfer&quot; config file config_infer_primary_yolo.txt specifies the path to</span><br><span class="line">the custom library and the custom output parsing function through the properties</span><br><span class="line">&quot;custom-lib-path&quot; and &quot;parse-bbox-func-name&quot; respectively.</span><br><span class="line">The first-time a &quot;model_b1_int8.engine&quot; would be generated as the engine-file</span><br><span class="line"></span><br><span class="line">- With deepstream-app</span><br><span class="line">  $ deepstream-app -c deepstream_app_config_yoloV3.txt</span><br><span class="line">  $ deepstream-app -c deepstream_app_config_yoloV3_tiny.txt</span><br><span class="line">  $ deepstream-app -c deepstream_app_config_yoloV2.txt</span><br><span class="line">  $ deepstream-app -c deepstream_app_config_yoloV2_tiny.txt</span><br><span class="line">  $ LD_PRELOAD=&lt;path-to-TRT-OSS-libnvinfer_plugin.so.7.0.0&gt; deepstream-app -c deepstream_app_config_yolo_tlt.txt</span><br></pre></td></tr></table></figure><p><strong>检测结果</strong></p><p><img src="/2021/07/10/week-2-2/2-1.png" alt="1"></p><h3 id="程序注释和理解"><a href="#程序注释和理解" class="headerlink" title="程序注释和理解"></a>程序注释和理解</h3><p>该程序分为两个部分：</p><ul><li><p>一部分是<code>tensorRT</code>部分 就是<code>sources\objectDetector_Yolo</code>文件夹里的，编译后会生产动态库文件。也就是<code>libnvdsinfer_custom_impl_Yolo.so</code></p></li><li><p>另一部分是<code>deepstream</code>的文件，在<code>sources\apps\sample_apps\deepstream-app</code>文件夹里。</p></li></ul><p>首先说明下<code>tensorRT</code>几个文件的关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- kernels.cucuda核最底层的实现</span><br><span class="line">|-- nvdsinfer_yolo_engine.cpp根据网络类型创建引擎,生成tensorrt engine</span><br><span class="line">|-- nvdsparsebbox_Yolo.cppyolo目标检测结果的输出,推理后的后处理部分</span><br><span class="line">|-- trt_utils.cpp建立tensorRT网络的部分</span><br><span class="line">|-- trt_utils.h</span><br><span class="line">|-- yolo.cpp创建引擎、创建网络等的具体实现</span><br><span class="line">|-- yolo.h</span><br><span class="line">|-- yoloPlugins.cpp模型搭建的一些组件以及相应的实现</span><br><span class="line">|-- yoloPlugins.h</span><br></pre></td></tr></table></figure><p><img src="/2021/07/10/week-2-2/2-2.png" alt="1"></p><p>其中yolo.cpp实现了网络层的搭建，是核心代码部分,下面代码实现了卷积层的搭建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是卷积层</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_ConfigBlocks.at(i).at(<span class="string">&quot;type&quot;</span>) == <span class="string">&quot;convolutional&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">//获取tensor的大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> inputVol = dimsToString(previous-&gt;getDimensions());</span><br><span class="line">    nvinfer1::ILayer* out;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> layerType;<span class="comment">//保存网络类型</span></span><br><span class="line">    <span class="comment">// check if batch_norm enabled</span></span><br><span class="line">    <span class="keyword">if</span> (m_ConfigBlocks.at(i).find(<span class="string">&quot;batch_normalize&quot;</span>) !=</span><br><span class="line">    m_ConfigBlocks.at(i).end()) &#123;</span><br><span class="line">    <span class="comment">//有BN的卷积层</span></span><br><span class="line">    out = netAddConvBNLeaky(i, m_ConfigBlocks.at(i), weights,</span><br><span class="line">    m_TrtWeights, weightPtr, channels, previous, &amp;network);</span><br><span class="line">    layerType = <span class="string">&quot;conv-bn-leaky&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    out = netAddConvLinear(i, m_ConfigBlocks.at(i), weights,</span><br><span class="line">    m_TrtWeights, weightPtr, channels, previous, &amp;network);</span><br><span class="line">    layerType = <span class="string">&quot;conv-linear&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    previous = out-&gt;getOutput(<span class="number">0</span>);<span class="comment">//获取该层的输出</span></span><br><span class="line">    assert(previous != <span class="literal">nullptr</span>);</span><br><span class="line">    channels = getNumChannels(previous);</span><br><span class="line">    <span class="comment">//获取tensor的大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> outputVol = dimsToString(previous-&gt;getDimensions());</span><br><span class="line">    <span class="comment">//保存相应的层输出</span></span><br><span class="line">    tensorOutputs.push_back(out-&gt;getOutput(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//打印参数</span></span><br><span class="line">    printLayerInfo(layerIndex, layerType, inputVol, outputVol, <span class="built_in">std</span>::to_string(weightPtr));</span><br></pre></td></tr></table></figure><p>下面说明一下deepstream部分代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- deepstream-app</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- README</span><br><span class="line">|   |-- deepstream_app.cpipeline的一些操作在这里</span><br><span class="line">|   |-- deepstream_app.h</span><br><span class="line">|   |-- deepstream_app_config_parser.c 配置文件的解析</span><br><span class="line">|   |-- deepstream_app_main.c deepstream主函数</span><br><span class="line"></span><br><span class="line">deepstream会调用动态库文件libnvdsinfer_custom_impl_Yolo.so实现网络层的搭建等功能</span><br></pre></td></tr></table></figure><p>再来看下deepstream_app_main.c主函数部分的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GOptionContext *ctx = <span class="literal">NULL</span>;</span><br><span class="line">  GOptionGroup *group = <span class="literal">NULL</span>;</span><br><span class="line">  GError *error = <span class="literal">NULL</span>;</span><br><span class="line">  guint i;</span><br><span class="line">  ctx = g_option_context_new (<span class="string">&quot;Nvidia DeepStream Demo&quot;</span>);</span><br><span class="line">  group = g_option_group_new (<span class="string">&quot;abc&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  g_option_group_add_entries (group, entries);  <span class="comment">//把entries添加到group</span></span><br><span class="line">  g_option_context_set_main_group (ctx, group); <span class="comment">//group添加到ctx</span></span><br><span class="line">  g_option_context_add_group (ctx, gst_init_get_option_group ());</span><br><span class="line">  GST_DEBUG_CATEGORY_INIT (NVDS_APP, <span class="string">&quot;NVDS_APP&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);   </span><br><span class="line">  <span class="comment">// 解析命令行参数，识别已添加到上下文的选项</span></span><br><span class="line">  <span class="keyword">if</span> (!g_option_context_parse (ctx, &amp;argc, &amp;argv, &amp;error)) &#123;</span><br><span class="line">    NVGSTDS_ERR_MSG_V (<span class="string">&quot;%s&quot;</span>, error-&gt;message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (print_version) &#123;</span><br><span class="line">    g_print (<span class="string">&quot;deepstream-app version %d.%d.%d\n&quot;</span>,</span><br><span class="line">        NVDS_APP_VERSION_MAJOR, NVDS_APP_VERSION_MINOR, NVDS_APP_VERSION_MICRO);</span><br><span class="line">    nvds_version_print ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (print_dependencies_version) &#123;</span><br><span class="line">    g_print (<span class="string">&quot;deepstream-app version %d.%d.%d\n&quot;</span>,</span><br><span class="line">        NVDS_APP_VERSION_MAJOR, NVDS_APP_VERSION_MINOR, NVDS_APP_VERSION_MICRO);</span><br><span class="line">    nvds_version_print ();</span><br><span class="line">    nvds_dependencies_version_print ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cfg_files) &#123;<span class="comment">//一般执行这项</span></span><br><span class="line">    num_instances = g_strv_length (cfg_files);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (input_files) &#123;</span><br><span class="line">    num_input_files = g_strv_length (input_files);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!cfg_files || num_instances == <span class="number">0</span>) &#123;</span><br><span class="line">    NVGSTDS_ERR_MSG_V (<span class="string">&quot;Specify config file with -c option&quot;</span>);</span><br><span class="line">    return_value = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">    appCtx[i] = g_malloc0 (<span class="keyword">sizeof</span> (AppCtx));</span><br><span class="line">    appCtx[i]-&gt;person_class_id = <span class="number">-1</span>;</span><br><span class="line">    appCtx[i]-&gt;car_class_id = <span class="number">-1</span>;</span><br><span class="line">    appCtx[i]-&gt;index = i;</span><br><span class="line">    appCtx[i]-&gt;active_source_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (show_bbox_text) &#123;</span><br><span class="line">      appCtx[i]-&gt;show_bbox_text = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (input_files &amp;&amp; input_files[i]) &#123;</span><br><span class="line">      appCtx[i]-&gt;config.multi_source_config[<span class="number">0</span>].uri =</span><br><span class="line">          g_strdup_printf (<span class="string">&quot;file://%s&quot;</span>, input_files[i]);</span><br><span class="line">      g_free (input_files[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 解析配置文件内容，这是个重点函数</span></span><br><span class="line">    <span class="keyword">if</span> (!parse_config_file (&amp;appCtx[i]-&gt;config, cfg_files[i])) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;Failed to parse config file &#x27;%s&#x27;&quot;</span>, cfg_files[i]);</span><br><span class="line">      appCtx[i]-&gt;return_value = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 针对配置进行创建pipeline，这里是关键部分deepstream部分</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!create_pipeline (appCtx[i], <span class="literal">NULL</span>,</span><br><span class="line">            all_bbox_generated, perf_cb, overlay_graphics)) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;Failed to create pipeline&quot;</span>);</span><br><span class="line">      return_value = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  main_loop = g_main_loop_new (<span class="literal">NULL</span>, FALSE);</span><br><span class="line">  _intr_setup ();</span><br><span class="line">  g_timeout_add (<span class="number">400</span>, check_for_interrupt, <span class="literal">NULL</span>);</span><br><span class="line">  g_mutex_init (&amp;disp_lock);</span><br><span class="line">  <span class="comment">// 这部分是显示相关的内容</span></span><br><span class="line">  display = XOpenDisplay (<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">    guint j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gst_element_set_state (appCtx[i]-&gt;pipeline.pipeline,</span><br><span class="line">            GST_STATE_PAUSED) == GST_STATE_CHANGE_FAILURE) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;Failed to set pipeline to PAUSED&quot;</span>);</span><br><span class="line">      return_value = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!appCtx[i]-&gt;config.tiled_display_config.enable)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; appCtx[i]-&gt;config.num_sink_sub_bins; j++) &#123;</span><br><span class="line">      XTextProperty xproperty;</span><br><span class="line">      gchar *title;</span><br><span class="line">      guint width, height;</span><br><span class="line">      XSizeHints hints = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="keyword">if</span> (!GST_IS_VIDEO_OVERLAY (appCtx[i]-&gt;pipeline.instance_bins[<span class="number">0</span>].</span><br><span class="line">              sink_bin.sub_bins[j].sink)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!display) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;Could not open X Display&quot;</span>);</span><br><span class="line">        return_value = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">// 显示设置</span></span><br><span class="line">      <span class="keyword">if</span> (appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.width)</span><br><span class="line">        width =</span><br><span class="line">            appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.width;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        width = appCtx[i]-&gt;config.tiled_display_config.width;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.height)</span><br><span class="line">        height =</span><br><span class="line">            appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.height;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        height = appCtx[i]-&gt;config.tiled_display_config.height;</span><br><span class="line">      width = (width) ? width : DEFAULT_X_WINDOW_WIDTH;</span><br><span class="line">      height = (height) ? height : DEFAULT_X_WINDOW_HEIGHT;</span><br><span class="line">      hints.flags = PPosition | PSize;</span><br><span class="line">      hints.x = appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.offset_x;</span><br><span class="line">      hints.y = appCtx[i]-&gt;config.sink_bin_sub_bin_config[j].render_config.offset_y;</span><br><span class="line">      hints.width = width;</span><br><span class="line">      hints.height = height;</span><br><span class="line">      windows[i] =</span><br><span class="line">          XCreateSimpleWindow (display, RootWindow (display,</span><br><span class="line">              DefaultScreen (display)), hints.x, hints.y, width, height, <span class="number">2</span>,</span><br><span class="line">              <span class="number">0x00000000</span>, <span class="number">0x00000000</span>);</span><br><span class="line">      XSetNormalHints(display, windows[i], &amp;hints);</span><br><span class="line">      <span class="keyword">if</span> (num_instances &gt; <span class="number">1</span>)</span><br><span class="line">        title = g_strdup_printf (APP_TITLE <span class="string">&quot;-%d&quot;</span>, i);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        title = g_strdup (APP_TITLE);</span><br><span class="line">      <span class="keyword">if</span> (XStringListToTextProperty ((<span class="keyword">char</span> **) &amp;title, <span class="number">1</span>, &amp;xproperty) != <span class="number">0</span>) &#123;</span><br><span class="line">        XSetWMName (display, windows[i], &amp;xproperty);</span><br><span class="line">        XFree (xproperty.value);</span><br><span class="line">      &#125;</span><br><span class="line">      XSetWindowAttributes attr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">      <span class="keyword">if</span> ((appCtx[i]-&gt;config.tiled_display_config.enable &amp;&amp;</span><br><span class="line">              appCtx[i]-&gt;config.tiled_display_config.rows *</span><br><span class="line">              appCtx[i]-&gt;config.tiled_display_config.columns == <span class="number">1</span>) ||</span><br><span class="line">          (appCtx[i]-&gt;config.tiled_display_config.enable == <span class="number">0</span> &amp;&amp;</span><br><span class="line">              appCtx[i]-&gt;config.num_source_sub_bins == <span class="number">1</span>)) &#123;</span><br><span class="line">        attr.event_mask = KeyPress;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        attr.event_mask = ButtonPress | KeyRelease;</span><br><span class="line">      &#125;</span><br><span class="line">      XChangeWindowAttributes (display, windows[i], CWEventMask, &amp;attr);</span><br><span class="line"></span><br><span class="line">      Atom wmDeleteMessage = XInternAtom (display, <span class="string">&quot;WM_DELETE_WINDOW&quot;</span>, False);</span><br><span class="line">      <span class="keyword">if</span> (wmDeleteMessage != None) &#123;</span><br><span class="line">        XSetWMProtocols (display, windows[i], &amp;wmDeleteMessage, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      XMapRaised (display, windows[i]);</span><br><span class="line">      XSync (display, <span class="number">1</span>);       <span class="comment">//discard the events for now</span></span><br><span class="line">      gst_video_overlay_set_window_handle (GST_VIDEO_OVERLAY (appCtx</span><br><span class="line">              [i]-&gt;pipeline.instance_bins[<span class="number">0</span>].sink_bin.sub_bins[j].sink),</span><br><span class="line">          (gulong) windows[i]);</span><br><span class="line">      gst_video_overlay_expose (GST_VIDEO_OVERLAY (appCtx[i]-&gt;</span><br><span class="line">              pipeline.instance_bins[<span class="number">0</span>].sink_bin.sub_bins[j].sink));</span><br><span class="line">      <span class="keyword">if</span> (!x_event_thread)</span><br><span class="line">        x_event_thread = g_thread_new (<span class="string">&quot;nvds-window-event-thread&quot;</span>,</span><br><span class="line">            nvds_x_event_thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Dont try to set playing state if error is observed */</span> </span><br><span class="line">  <span class="comment">// 发生错误的处理</span></span><br><span class="line">  <span class="keyword">if</span> (return_value != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (gst_element_set_state (appCtx[i]-&gt;pipeline.pipeline,</span><br><span class="line">              GST_STATE_PLAYING) == GST_STATE_CHANGE_FAILURE) &#123;</span><br><span class="line"></span><br><span class="line">        g_print (<span class="string">&quot;\ncan&#x27;t set pipeline to playing state.\n&quot;</span>);</span><br><span class="line">        return_value = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  print_runtime_commands ();</span><br><span class="line">  changemode (<span class="number">1</span>);</span><br><span class="line">  g_timeout_add (<span class="number">40</span>, event_thread_func, <span class="literal">NULL</span>);</span><br><span class="line">  g_main_loop_run (main_loop);</span><br><span class="line">  changemode (<span class="number">0</span>);</span><br><span class="line">done:</span><br><span class="line">  g_print (<span class="string">&quot;Quitting\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 下面是释放资源</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_instances; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (appCtx[i]-&gt;return_value == <span class="number">-1</span>)</span><br><span class="line">      return_value = <span class="number">-1</span>;</span><br><span class="line">    destroy_pipeline (appCtx[i]);</span><br><span class="line"></span><br><span class="line">    g_mutex_lock (&amp;disp_lock);</span><br><span class="line">    <span class="keyword">if</span> (windows[i])</span><br><span class="line">      XDestroyWindow (display, windows[i]);</span><br><span class="line">    windows[i] = <span class="number">0</span>;</span><br><span class="line">    g_mutex_unlock (&amp;disp_lock);</span><br><span class="line">    g_free (appCtx[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  g_mutex_lock (&amp;disp_lock);</span><br><span class="line">  <span class="keyword">if</span> (display)</span><br><span class="line">    XCloseDisplay (display);</span><br><span class="line">  display = <span class="literal">NULL</span>;</span><br><span class="line">  g_mutex_unlock (&amp;disp_lock);</span><br><span class="line">  g_mutex_clear (&amp;disp_lock);</span><br><span class="line">  <span class="keyword">if</span> (main_loop) &#123;</span><br><span class="line">    g_main_loop_unref (main_loop);<span class="comment">//执行循环推理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ctx) &#123;</span><br><span class="line">    g_option_context_free (ctx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (return_value == <span class="number">0</span>) &#123;</span><br><span class="line">    g_print (<span class="string">&quot;App run successful\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    g_print (<span class="string">&quot;App run failed\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  gst_deinit ();</span><br><span class="line">  <span class="keyword">return</span> return_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>deepstream_app_config_parser.c</code>解析配置文件的代码，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">gboolean</span></span><br><span class="line"><span class="function"><span class="title">parse_config_file</span> <span class="params">(NvDsConfig *config, gchar *cfg_file_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GKeyFile *cfg_file = g_key_file_new ();</span><br><span class="line">  GError *error = <span class="literal">NULL</span>;</span><br><span class="line">  gboolean ret = FALSE;</span><br><span class="line">  gchar **groups = <span class="literal">NULL</span>;</span><br><span class="line">  gchar **group;</span><br><span class="line">  guint i, j;</span><br><span class="line"></span><br><span class="line">  config-&gt;source_list_enabled = FALSE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!APP_CFG_PARSER_CAT) &#123;</span><br><span class="line">    GST_DEBUG_CATEGORY_INIT (APP_CFG_PARSER_CAT, <span class="string">&quot;NVDS_CFG_PARSER&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!g_key_file_load_from_file (cfg_file, cfg_file_path, G_KEY_FILE_NONE,</span><br><span class="line">          &amp;error)) &#123;</span><br><span class="line">    GST_CAT_ERROR (APP_CFG_PARSER_CAT, <span class="string">&quot;Failed to load uri file: %s&quot;</span>,</span><br><span class="line">        error-&gt;message);</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (g_key_file_has_group (cfg_file, CONFIG_GROUP_SOURCE_LIST)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!parse_source_list (config, cfg_file, cfg_file_path)) &#123;</span><br><span class="line">      GST_CAT_ERROR (APP_CFG_PARSER_CAT, <span class="string">&quot;Failed to parse &#x27;%s&#x27; group&quot;</span>,</span><br><span class="line">          CONFIG_GROUP_SOURCE_LIST);</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    config-&gt;num_source_sub_bins = config-&gt;total_num_sources;</span><br><span class="line">    config-&gt;source_list_enabled = TRUE;</span><br><span class="line">    <span class="keyword">if</span> (!g_key_file_has_group (cfg_file, CONFIG_GROUP_SOURCE_ALL)) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;[source-attr-all] group not present.&quot;</span>);</span><br><span class="line">      ret = FALSE;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    g_key_file_remove_group (cfg_file, CONFIG_GROUP_SOURCE_LIST, &amp;error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (g_key_file_has_group (cfg_file, CONFIG_GROUP_SOURCE_ALL)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!parse_source (&amp;global_source_config,</span><br><span class="line">            cfg_file, CONFIG_GROUP_SOURCE_ALL, cfg_file_path)) &#123;</span><br><span class="line">      GST_CAT_ERROR (APP_CFG_PARSER_CAT, <span class="string">&quot;Failed to parse &#x27;%s&#x27; group&quot;</span>,</span><br><span class="line">          CONFIG_GROUP_SOURCE_LIST);</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!set_source_all_configs (config, cfg_file_path)) &#123;</span><br><span class="line">      ret = FALSE;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    g_key_file_remove_group (cfg_file, CONFIG_GROUP_SOURCE_ALL, &amp;error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 信息存储在里cfg_file里面</span></span><br><span class="line">  groups = g_key_file_get_groups (cfg_file, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//这里对应的是8项  </span></span><br><span class="line">  <span class="comment">//group[0]=application</span></span><br><span class="line">  <span class="comment">//group[1]=tiled-display</span></span><br><span class="line">  <span class="comment">//group[2]=source0</span></span><br><span class="line">  <span class="comment">//group[3]=sink0</span></span><br><span class="line">  <span class="comment">//group[4]=osd</span></span><br><span class="line">  <span class="comment">//group[5]=streammux</span></span><br><span class="line">  <span class="comment">//group[6]=primary-gie</span></span><br><span class="line">  <span class="comment">//group[7]=tracker</span></span><br><span class="line">  <span class="comment">//group[8]=tests</span></span><br><span class="line">  <span class="keyword">for</span> (group = groups; *group; group++) &#123;</span><br><span class="line">    gboolean parse_err = FALSE;</span><br><span class="line">    GST_CAT_DEBUG (APP_CFG_PARSER_CAT, <span class="string">&quot;Parsing group: %s&quot;</span>, *group);</span><br><span class="line">    <span class="comment">// application </span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_APP)) &#123;</span><br><span class="line">      parse_err = !parse_app (config, cfg_file, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// source0  </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*group, CONFIG_GROUP_SOURCE,</span><br><span class="line">            <span class="keyword">sizeof</span> (CONFIG_GROUP_SOURCE) - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;num_source_sub_bins == MAX_SOURCE_BINS) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d sources&quot;</span>, MAX_SOURCE_BINS);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      gchar *source_id_start_ptr = *group + <span class="built_in">strlen</span> (CONFIG_GROUP_SOURCE);</span><br><span class="line">      gchar *source_id_end_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      guint index =</span><br><span class="line">          g_ascii_strtoull (source_id_start_ptr, &amp;source_id_end_ptr, <span class="number">10</span>);</span><br><span class="line">      <span class="keyword">if</span> (source_id_start_ptr == source_id_end_ptr</span><br><span class="line">          || *source_id_end_ptr != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V</span><br><span class="line">            (<span class="string">&quot;Source group \&quot;[%s]\&quot; is not in the form \&quot;[source&lt;%%d&gt;]\&quot;&quot;</span>,</span><br><span class="line">            *group);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      guint source_id = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;source_list_enabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= config-&gt;total_num_sources) &#123;</span><br><span class="line">          NVGSTDS_ERR_MSG_V</span><br><span class="line">              (<span class="string">&quot;Invalid source group index %d, index cannot exceed %d&quot;</span>, index,</span><br><span class="line">              config-&gt;total_num_sources);</span><br><span class="line">          ret = FALSE;</span><br><span class="line">          <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        source_id = index;</span><br><span class="line">        NVGSTDS_INFO_MSG_V (<span class="string">&quot;Some parameters to be overwritten for group [%s]&quot;</span>,</span><br><span class="line">            *group);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        source_id = config-&gt;num_source_sub_bins;</span><br><span class="line">      &#125;</span><br><span class="line">      parse_err = !parse_source (&amp;config-&gt;multi_source_config[source_id],</span><br><span class="line">          cfg_file, *group, cfg_file_path);</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;source_list_enabled</span><br><span class="line">          &amp;&amp; config-&gt;multi_source_config[source_id].type ==</span><br><span class="line">          NV_DS_SOURCE_URI_MULTIPLE) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V</span><br><span class="line">            (<span class="string">&quot;MultiURI support not available if [source-list] is provided&quot;</span>);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;multi_source_config[source_id].enable</span><br><span class="line">          &amp;&amp; !config-&gt;source_list_enabled) &#123;</span><br><span class="line">        config-&gt;num_source_sub_bins++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// streammux</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_STREAMMUX)) &#123;</span><br><span class="line">      <span class="comment">// 存储到config-&gt;streammux_config中</span></span><br><span class="line">      parse_err = !parse_streammux (&amp;config-&gt;streammux_config, cfg_file, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// osd</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_OSD)) &#123;</span><br><span class="line">      parse_err = !parse_osd (&amp;config-&gt;osd_config, cfg_file);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// primary_gie</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_PRIMARY_GIE)) &#123;</span><br><span class="line">      parse_err =</span><br><span class="line">          !parse_gie (&amp;config-&gt;primary_gie_config, cfg_file,</span><br><span class="line">          CONFIG_GROUP_PRIMARY_GIE, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_TRACKER)) &#123;</span><br><span class="line">      parse_err = !parse_tracker (&amp;config-&gt;tracker_config, cfg_file, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*group, CONFIG_GROUP_SECONDARY_GIE,</span><br><span class="line">                  <span class="keyword">sizeof</span> (CONFIG_GROUP_SECONDARY_GIE) - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;num_secondary_gie_sub_bins == MAX_SECONDARY_GIE_BINS) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d secondary GIEs&quot;</span>, MAX_SECONDARY_GIE_BINS);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      parse_err =</span><br><span class="line">          !parse_gie (&amp;config-&gt;secondary_gie_sub_bin_config[config-&gt;</span><br><span class="line">                                  num_secondary_gie_sub_bins],</span><br><span class="line">                                  cfg_file, *group, cfg_file_path);</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;secondary_gie_sub_bin_config[config-&gt;num_secondary_gie_sub_bins].enable)&#123;</span><br><span class="line">        config-&gt;num_secondary_gie_sub_bins++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*group, CONFIG_GROUP_SINK, <span class="keyword">sizeof</span> (CONFIG_GROUP_SINK) - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;num_sink_sub_bins == MAX_SINK_BINS) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d sinks&quot;</span>, MAX_SINK_BINS);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      parse_err =</span><br><span class="line">          !parse_sink (&amp;config-&gt;</span><br><span class="line">          sink_bin_sub_bin_config[config-&gt;num_sink_sub_bins], cfg_file, *group,</span><br><span class="line">          cfg_file_path);</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;</span><br><span class="line">          sink_bin_sub_bin_config[config-&gt;num_sink_sub_bins].enable)&#123;</span><br><span class="line">        config-&gt;num_sink_sub_bins++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span> (*group, CONFIG_GROUP_MSG_CONSUMER,</span><br><span class="line">        <span class="keyword">sizeof</span> (CONFIG_GROUP_MSG_CONSUMER) - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;num_message_consumers == MAX_MESSAGE_CONSUMERS) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d consumers&quot;</span>, MAX_MESSAGE_CONSUMERS);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">      parse_err = !parse_msgconsumer (</span><br><span class="line">                    &amp;config-&gt;message_consumer_config[config-&gt;num_message_consumers],</span><br><span class="line">                    cfg_file, *group, cfg_file_path);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (config-&gt;message_consumer_config[config-&gt;num_message_consumers].enable) &#123;</span><br><span class="line">        config-&gt;num_message_consumers++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tiled-display</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_TILED_DISPLAY)) &#123;</span><br><span class="line">      parse_err = !parse_tiled_display (&amp;config-&gt;tiled_display_config, cfg_file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_IMG_SAVE)) &#123;</span><br><span class="line">      parse_err = !parse_image_save (&amp;config-&gt;image_save_config , cfg_file, *group, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_DSANALYTICS)) &#123;</span><br><span class="line">      parse_err = !parse_dsanalytics (&amp;config-&gt;dsanalytics_config, cfg_file, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_DSEXAMPLE)) &#123;</span><br><span class="line">      parse_err = !parse_dsexample (&amp;config-&gt;dsexample_config, cfg_file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_MSG_CONVERTER)) &#123;</span><br><span class="line">      parse_err = !parse_msgconv (&amp;config-&gt;msg_conv_config, cfg_file, *group, cfg_file_path);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// tests</span></span><br><span class="line">    <span class="keyword">if</span> (!g_strcmp0 (*group, CONFIG_GROUP_TESTS)) &#123;</span><br><span class="line">      parse_err = !parse_tests (config, cfg_file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parse_err) &#123;</span><br><span class="line">      GST_CAT_ERROR (APP_CFG_PARSER_CAT, <span class="string">&quot;Failed to parse &#x27;%s&#x27; group&quot;</span>, *group);</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 二级网络处理</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; config-&gt;num_secondary_gie_sub_bins; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (config-&gt;secondary_gie_sub_bin_config[i].unique_id ==</span><br><span class="line">        config-&gt;primary_gie_config.unique_id) &#123;</span><br><span class="line">      NVGSTDS_ERR_MSG_V (<span class="string">&quot;Non unique gie ids found&quot;</span>);</span><br><span class="line">      ret = FALSE;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; config-&gt;num_secondary_gie_sub_bins; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; config-&gt;num_secondary_gie_sub_bins; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;secondary_gie_sub_bin_config[i].unique_id ==</span><br><span class="line">          config-&gt;secondary_gie_sub_bin_config[j].unique_id) &#123;</span><br><span class="line">        NVGSTDS_ERR_MSG_V (<span class="string">&quot;Non unique gie id %d found&quot;</span>,</span><br><span class="line">                            config-&gt;secondary_gie_sub_bin_config[i].unique_id);</span><br><span class="line">        ret = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 多输入源处理</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; config-&gt;num_source_sub_bins; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (config-&gt;multi_source_config[i].type == NV_DS_SOURCE_URI_MULTIPLE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (config-&gt;multi_source_config[i].num_sources &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        config-&gt;multi_source_config[i].num_sources = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; config-&gt;multi_source_config[i].num_sources; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (config-&gt;num_source_sub_bins == MAX_SOURCE_BINS) &#123;</span><br><span class="line">          NVGSTDS_ERR_MSG_V (<span class="string">&quot;App supports max %d sources&quot;</span>, MAX_SOURCE_BINS);</span><br><span class="line">          ret = FALSE;</span><br><span class="line">          <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span> (&amp;config-&gt;multi_source_config[config-&gt;num_source_sub_bins],</span><br><span class="line">            &amp;config-&gt;multi_source_config[i],</span><br><span class="line">            <span class="keyword">sizeof</span> (config-&gt;multi_source_config[i]));</span><br><span class="line">        config-&gt;multi_source_config[config-&gt;num_source_sub_bins].type =</span><br><span class="line">            NV_DS_SOURCE_URI;</span><br><span class="line">        config-&gt;multi_source_config[config-&gt;num_source_sub_bins].uri =</span><br><span class="line">            g_strdup_printf (config-&gt;multi_source_config[config-&gt;</span><br><span class="line">                num_source_sub_bins].uri, j);</span><br><span class="line">        config-&gt;num_source_sub_bins++;</span><br><span class="line">      &#125;</span><br><span class="line">      config-&gt;multi_source_config[i].type = NV_DS_SOURCE_URI;</span><br><span class="line">      config-&gt;multi_source_config[i].uri =</span><br><span class="line">          g_strdup_printf (config-&gt;multi_source_config[i].uri, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = TRUE;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">  <span class="keyword">if</span> (cfg_file) &#123;</span><br><span class="line">    g_key_file_free (cfg_file);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (groups) &#123;</span><br><span class="line">    g_strfreev (groups);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    g_error_free (error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">    NVGSTDS_ERR_MSG_V (<span class="string">&quot;%s failed&quot;</span>, __func__);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是建立<code>pipeline</code>的代码，建立<code>pipeline</code>是属于<code>deepstream</code>的部分，里面包含了<code>tensorRT</code>的调用。配置文件当中的<code>[primary-gie]</code>是对推理引擎的相关配置。修改配置文件可以对模型参数进行设置。</p><h2 id="使用yolov3检测安全帽👷"><a href="#使用yolov3检测安全帽👷" class="headerlink" title="使用yolov3检测安全帽👷"></a>使用yolov3检测安全帽👷</h2><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>模型配置文件：<code>yolov3_half_helmet.cfg</code><br>模型权重文件：<code>yolov3_half_helmet.weights</code><br>模型类别：3  ， 0-正常头肩，1-保安头肩，2-安全帽头肩 见<code>helmet.names</code><br>测试视频文件：<code>test_helmet_1.mp4</code>    <code> test_personcount.mp4</code></p><h3 id="检测任务"><a href="#检测任务" class="headerlink" title="检测任务"></a>检测任务</h3><p>①使用<code>deepstream</code>构建一个<code>pipeline</code>，检测<code>test_helmet_1.mp4</code>，输出画面中正常头肩画红框，保安头肩画蓝框，安全帽头肩画绿框<br>②测试安全帽检测 前处理，推理，后处理所用的时间<br>③使用<code>deepstream</code>构建多线程<code>pipeline</code>，使用安全帽检测模型同时检测2个视频文件</p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>对于自定义数据的检测，需根据自己检测的类别修改如下文件</p><p>修改<code>nvdsinfer_custom_impl_Yolo/nvdsparsebbox_Yolo.cpp</code>文件中检测类别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 默认检测coco数据集80个类别，修改为你自己检测的类别</span><br><span class="line">static const int NUM_CLASSES_YOLO = 3;</span><br></pre></td></tr></table></figure><p>注意，修改完需要重新编译和运行生成链接的<code>.so</code>文件</p><p>修改<code>config_infer_primary_yoloV3.txt</code>文件，修改<code>cfg</code>和<code>weights</code>等文件，根据自己检测的类别设置<code>num-detected-classes</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[property]</span><br><span class="line">gpu-id=0</span><br><span class="line">net-scale-factor=0.0039215697906911373</span><br><span class="line">#0=RGB, 1=BGR</span><br><span class="line">model-color-format=0</span><br><span class="line">#修改cfg文件</span><br><span class="line">custom-network-config=yolov3_half_helmet_20200607.cfg</span><br><span class="line">#修改weights文件</span><br><span class="line">model-file=yolov3_half_helmet_20200607.weights</span><br><span class="line">#model-engine-file=yolov3_b1_gpu0_int8.engine</span><br><span class="line">#修改label文件</span><br><span class="line">labelfile-path=helmet_names.txt</span><br><span class="line">int8-calib-file=yolov3-calibration.table.trt7.0</span><br><span class="line">## 0=FP32, 1=INT8, 2=FP16 mode</span><br><span class="line">network-mode=1</span><br><span class="line">#模型类别:3 0-正常头肩，1-保安头肩，2-安全帽头肩</span><br><span class="line">num-detected-classes=3</span><br><span class="line">gie-unique-id=1</span><br><span class="line">network-type=0</span><br><span class="line">is-classifier=0</span><br><span class="line">## 0=Group Rectangles, 1=DBSCAN, 2=NMS, 3= DBSCAN+NMS Hybrid, 4 = None(No clustering)</span><br><span class="line">cluster-mode=2</span><br><span class="line">maintain-aspect-ratio=1</span><br><span class="line">parse-bbox-func-name=NvDsInferParseCustomYoloV3</span><br><span class="line"># 编译的动态库路径</span><br><span class="line">custom-lib-path=nvdsinfer_custom_impl_Yolo/libnvdsinfer_custom_impl_Yolo.so</span><br><span class="line">engine-create-func-name=NvDsInferYoloCudaEngineGet</span><br><span class="line">#scaling-filter=0</span><br><span class="line">#scaling-compute-hw=0</span><br><span class="line"></span><br><span class="line">[class-attrs-all]</span><br><span class="line">nms-iou-threshold=0.3# NMS的阈值</span><br><span class="line">#threshold=0.7</span><br><span class="line">pre-cluster-threshold=0.7   # 检测框的过滤阈值</span><br></pre></td></tr></table></figure><p>修改<code>deepstream_app_config_yoloV3.txt</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">[application]</span><br><span class="line">enable-perf-measurement=1</span><br><span class="line">perf-measurement-interval-sec=5</span><br><span class="line">#gie-kitti-output-dir=streamscl</span><br><span class="line"></span><br><span class="line">[tiled-display]</span><br><span class="line">enable=1</span><br><span class="line">rows=1</span><br><span class="line">columns=1</span><br><span class="line">width=1280</span><br><span class="line">height=720</span><br><span class="line">gpu-id=0</span><br><span class="line">#(0): nvbuf-mem-default - Default memory allocated, specific to particular platform</span><br><span class="line">#(1): nvbuf-mem-cuda-pinned - Allocate Pinned/Host cuda memory, applicable for Tesla</span><br><span class="line">#(2): nvbuf-mem-cuda-device - Allocate Device cuda memory, applicable for Tesla</span><br><span class="line">#(3): nvbuf-mem-cuda-unified - Allocate Unified cuda memory, applicable for Tesla</span><br><span class="line">#(4): nvbuf-mem-surface-array - Allocate Surface Array memory, applicable for Jetson</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"></span><br><span class="line">[source0]</span><br><span class="line">enable=1</span><br><span class="line">#Type - 1=CameraV4L2 2=URI 3=MultiURI</span><br><span class="line">type=3</span><br><span class="line"># 修改文件位置</span><br><span class="line">uri=file://../../samples/streams/test_helmet_1.mp4</span><br><span class="line">num-sources=1</span><br><span class="line">gpu-id=0</span><br><span class="line"># (0): memtype_device   - Memory type Device</span><br><span class="line"># (1): memtype_pinned   - Memory type Host Pinned</span><br><span class="line"># (2): memtype_unified  - Memory type Unified</span><br><span class="line">cudadec-memtype=0</span><br><span class="line"></span><br><span class="line">[sink0]</span><br><span class="line">enable=1</span><br><span class="line">#Type - 1=FakeSink 2=EglSink 3=File</span><br><span class="line">type=2</span><br><span class="line">sync=0</span><br><span class="line">source-id=0</span><br><span class="line">gpu-id=0</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"></span><br><span class="line">[osd]</span><br><span class="line">enable=1</span><br><span class="line">gpu-id=0</span><br><span class="line">border-width=1</span><br><span class="line">text-size=15</span><br><span class="line">text-color=1;1;1;1;</span><br><span class="line">text-bg-color=0.3;0.3;0.3;1</span><br><span class="line">font=Serif</span><br><span class="line">show-clock=0</span><br><span class="line">clock-x-offset=800</span><br><span class="line">clock-y-offset=820</span><br><span class="line">clock-text-size=12</span><br><span class="line">clock-color=1;0;0;0</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"></span><br><span class="line">[streammux]</span><br><span class="line">gpu-id=0</span><br><span class="line">##Boolean property to inform muxer that sources are live</span><br><span class="line">live-source=0</span><br><span class="line">batch-size=1</span><br><span class="line">##time out in usec, to wait after the first buffer is available</span><br><span class="line">##to push the batch even if the complete batch is not formed</span><br><span class="line">batched-push-timeout=40000</span><br><span class="line">## Set muxer output width and height</span><br><span class="line">width=1920</span><br><span class="line">height=1080</span><br><span class="line">##Enable to maintain aspect ratio wrt source, and allow black borders, works</span><br><span class="line">##along with width, height properties</span><br><span class="line">enable-padding=0</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"></span><br><span class="line"># config-file property is mandatory for any gie section.</span><br><span class="line"># Other properties are optional and if set will override the properties set in</span><br><span class="line"># the infer config file.</span><br><span class="line">[primary-gie]</span><br><span class="line">enable=1</span><br><span class="line">gpu-id=0</span><br><span class="line">#model-engine-file=model_b1_gpu0_int8.engine</span><br><span class="line"># 修改标签文件</span><br><span class="line">labelfile-path=helmet_names.txt</span><br><span class="line">batch-size=1</span><br><span class="line">#Required by the app for OSD, not a plugin property</span><br><span class="line">bbox-border-color0=1;0;0;1</span><br><span class="line">bbox-border-color1=0;1;1;1</span><br><span class="line">bbox-border-color2=0;0;1;1</span><br><span class="line">bbox-border-color3=0;1;0;1</span><br><span class="line">interval=2</span><br><span class="line">gie-unique-id=1</span><br><span class="line">nvbuf-memory-type=0</span><br><span class="line"># 修改config文件</span><br><span class="line">config-file=config_infer_helmet_yoloV3.txt</span><br><span class="line"></span><br><span class="line">[tracker]</span><br><span class="line">enable=1</span><br><span class="line">tracker-width=640</span><br><span class="line">tracker-height=384</span><br><span class="line">ll-lib-file=/opt/nvidia/deepstream/deepstream-5.0/lib/libnvds_mot_klt.so</span><br><span class="line"></span><br><span class="line">[tests]</span><br><span class="line">file-loop=0</span><br></pre></td></tr></table></figure><p>如果要检测多个视频，只要在<code>deepstream_app_config_yoloV3.txt</code>文件中添加<code>source</code>和<code>sink</code>并且一一对应即可。</p><h3 id="检测结果"><a href="#检测结果" class="headerlink" title="检测结果"></a>检测结果</h3><p>安全帽检测</p><p><img src="/2021/07/10/week-2-2/2-3.png" alt="18"></p><p>使用安全帽检测模型同时检测2个视频文件</p><p><img src="/2021/07/10/week-2-2/2-4.png" alt="18"></p><p>第一次运行生成<code>engine</code>，这是最耗时的地方，<code>engine</code>只在第一次运行生成，然后可以把<code>config_infer_primary_yoloV3.txt</code>文件中配置打开，多次运行时不必再生成<code>engine</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当这项配置打开时，这样只会在第一次生成引擎，后续启动会很快。</span><br><span class="line">model-engine-file=yolov3_b1_gpu0_int8.engine</span><br></pre></td></tr></table></figure><h2 id="测试时间"><a href="#测试时间" class="headerlink" title="测试时间"></a>测试时间</h2><p>测试安全帽检测 前处理，推理，后处理所用的时间这部分还没有完成。。。</p><p>尽量尽快补充完成！</p>]]></content>
    
    
    <summary type="html">Deepstream YoloV3检测安全帽</summary>
    
    
    
    <category term="Internship" scheme="http://example.com/categories/Internship/"/>
    
    
    <category term="Jetson" scheme="http://example.com/tags/Jetson/"/>
    
    <category term="Deepstreeam" scheme="http://example.com/tags/Deepstreeam/"/>
    
  </entry>
  
  <entry>
    <title>Installing  GStreamer</title>
    <link href="http://example.com/2021/07/09/week-2-1/"/>
    <id>http://example.com/2021/07/09/week-2-1/</id>
    <published>2021-07-09T13:01:50.000Z</published>
    <updated>2021-07-24T06:26:12.464Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Installing-GStreamer"><a href="#Installing-GStreamer" class="headerlink" title="Installing  GStreamer"></a>Installing  GStreamer</h1><h2 id="Installing-on-Linux"><a href="#Installing-on-Linux" class="headerlink" title="Installing on Linux"></a>Installing on Linux</h2><p><strong>系统：Ubuntu 16.04</strong></p><p>参照<a href="https://gstreamer.freedesktop.org/documentation/installing/on-linux.html?gi-language=c">官方文档</a>，运行以下命令，但是在我的笔记本和公司的台式机上似乎不太ok…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libgstreamer-plugins-bad1.0-dev gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio</span><br></pre></td></tr></table></figure><p><a href="https://samwhelp.github.io/note-ubuntu-18.04/read/howto/install-tool/gstreamer/">参考</a>了一位湾湾网友，运行以下命令成功安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools</span><br></pre></td></tr></table></figure><p><strong>Package</strong></p><ul><li><a href="https://packages.ubuntu.com/bionic/libgstreamer1.0-0">libgstreamer1.0-0</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-plugins-base">gstreamer1.0-plugins-base</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-plugins-good">gstreamer1.0-plugins-good</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-plugins-bad">gstreamer1.0-plugins-bad</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-plugins-ugly">gstreamer1.0-plugins-ugly</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-libav">gstreamer1.0-libav</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-doc">gstreamer1.0-doc</a></li><li><a href="https://packages.ubuntu.com/bionic/gstreamer1.0-tools">gstreamer1.0-tools</a></li></ul><p><strong>验证安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep gstreamer</span><br></pre></td></tr></table></figure><p><strong>使用 GStreamer 构建应用程序</strong></p><p>为了编译 GStreamer 并使用 GStreamer 核心库的代码，需在<code>gcc</code>后添加以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --cflags --libs gstreamer-1.0</span><br></pre></td></tr></table></figure><p>如果使用其他 GStreamer 库，例如视频库，则必须在上述 gstreamer-1.0 之后添加其他包（例如，视频库的 gstreamer-video-1.0）</p><p><strong>获取tutorial’s source code</strong></p><p>可以使用以下命令git到本地，可以在文件目录<code>gst/examples/tutorials</code>中找到例程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.freedesktop.org/gstreamer/gst-docs</span><br></pre></td></tr></table></figure><p><strong>Building the tutorials</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc basic-tutorial-1.c -o basic-tutorial-1 `pkg-config --cflags --libs gstreamer-1.0`</span><br></pre></td></tr></table></figure><p><strong>Running the tutorials</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./basic-tutorial-1</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="/2021/07/09/week-2-1/2_1.png" alt="1"></p><p><strong>nice</strong>！</p><h2 id="Installing-on-Windows"><a href="#Installing-on-Windows" class="headerlink" title="Installing on Windows"></a>Installing on Windows</h2><p>首先参照<a href="https://gstreamer.freedesktop.org/documentation/installing/on-windows.html?gi-language=c">官方文档</a>安装，真的蛮心累的，英文我都能看懂，但就是搞不定。记录一下GStreamer on Windows的崎岖之路。</p><p><strong>环境：Win 10 + VS2017</strong></p><p><strong>1. 下载GStreamer</strong></p><p>选择MSVC 64-bit(有mingw可选)</p><p><a href="https://gstreamer.freedesktop.org/data/pkg/windows/1.18.4/msvc/gstreamer-1.0-msvc-x86_64-1.18.4.msi">gstreamer-1.0-msvc-x86_64-1.18.4.msi</a>               先装</p><p><a href="https://gstreamer.freedesktop.org/data/pkg/windows/1.18.4/msvc/gstreamer-1.0-devel-msvc-x86_64-1.18.4.msi">gstreamer-1.0-devel-msvc-x86_64-1.18.4.msi</a>    后装</p><p>安装的时候都选择<code>Complete</code>完整安装，默认会安装在剩余空间最大的盘符</p><p><strong>2. 配置系统变量</strong></p><p>首先将<code>glibconfig.h</code>文件拷贝到<code>include/glib-2.0</code>以及<code>include/glib-2.0/glib</code>目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|-- lib</span><br><span class="line">|   |-- glib-2.0</span><br><span class="line">|   |    -- include</span><br><span class="line">|   |        -- glibconfig.h 此文件拷贝到</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- include</span><br><span class="line">|     --glib-2.0 此目录下</span><br><span class="line">|        -- glib 以及此目录下</span><br></pre></td></tr></table></figure><p>添加用户变量</p><p><img src="/2021/07/09/week-2-1/2_3.png" alt="3"></p><p>添加系统变量</p><p><img src="/2021/07/09/week-2-1/2_4.png" alt="4"></p><p>Path中添加路径</p><p><img src="/2021/07/09/week-2-1/2_5.png" alt="5"></p><p><strong>3. 环境测试</strong></p><ul><li><p>影像测试，打开cmd运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-launch-1.0 videotestsrc ! videoconvert ! autovideosink</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2021/07/09/week-2-1/2_6.png" alt="6"></p><ul><li><p>撞球测试，打开cmd运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-launch-1.0 -v videotestsrc pattern=ball ! video/x-raw,width=320,height=240 ! videoconvert ! tee ! autovideosink device=0</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_7.png" alt="7"></p></li></ul><p>至此，GStreamer的MSCV环境ok，接下来在VS2017配置GStreamer</p><p><strong>4. VS2017配置GStreamer</strong></p><p>还是之前下载的<a href="https://medium.com/r/?url=https://gitlab.freedesktop.org/gstreamer/gst-docs/">gst-docs</a>，用VS打开，双击<code>tutorials.sln</code></p><p><img src="/2021/07/09/week-2-1/2_8.png" alt="8"></p><p><code>tutorials</code>给的是<code>VS2010</code>的例程，当然要升级一下啦</p><p><img src="/2021/07/09/week-2-1/2_9.png" alt="9"></p><p>打开后是这样滴</p><p><img src="/2021/07/09/week-2-1/2_9_1.png" alt="9_1"></p><p>站起来活动一下，直直腰可以开始啦，一上来全是<code>Errors</code>，能运行才奇怪捏。。。</p><p><img src="/2021/07/09/week-2-1/2_10.png" alt="10"></p><p>重点来了，第一次给<code>VS2017</code>配置第三方库</p><p>① 解决方案资源管理器里选择项目名，右键项目，选择属性</p><p>在配置属性——调试——工作目录 增加如下目录(选择活动(x64)平台哦，接下来都是)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\gstreamer\1.0\msvc_x86_64\bin</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_11.png" alt="11"></p><p>②在C/C++ —— 常规——附加包含目录 增加如下目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\gstreamer\1.0\msvc_x86_64\include\gstreamer-1.0</span><br><span class="line">D:\gstreamer\1.0\msvc_x86_64\include\glib-2.0</span><br><span class="line">D:\gstreamer\1.0\msvc_x86_64\include\libxml2</span><br><span class="line">D:\gstreamer\1.0\msvc_x86_64\include</span><br><span class="line">D:\gstreamer\1.0\msvc_x86_64\lib\glib-2.0\include</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_12.png" alt="12"></p><p>③在链接器—-常规—-附加库目录，增加 如下目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\gstreamer\1.0\msvc_x86_64\lib</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_13.png" alt="13"></p><p>④在链接器—-输入—–附加依赖性 增加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gobject-2.0.lib</span><br><span class="line">glib-2.0.lib</span><br><span class="line">gstreamer-1.0.lib</span><br></pre></td></tr></table></figure><p><img src="/2021/07/09/week-2-1/2_14.png" alt="14"></p><p>测试一下，运行一下<code>basic-tutorial-1.c</code>，没有报错了，撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> </p><p><img src="/2021/07/09/week-2-1/2_15.png" alt="15"></p><p>运行结果</p><p><img src="/2021/07/09/week-2-1/2_17.png" alt="17"></p><p><code>basic-tutorial-1.c</code>的代码就先不解读啦，里面注释很清晰了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GstElement *pipeline;</span><br><span class="line">GstBus *bus;</span><br><span class="line">GstMessage *msg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize GStreamer */</span></span><br><span class="line">gst_init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Build the pipeline */</span></span><br><span class="line">pipeline =</span><br><span class="line">gst_parse_launch</span><br><span class="line">(<span class="string">&quot;playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm&quot;</span>,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Start playing */</span></span><br><span class="line">gst_element_set_state(pipeline, GST_STATE_PLAYING);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait until error or EOS */</span></span><br><span class="line">bus = gst_element_get_bus(pipeline);</span><br><span class="line">msg =</span><br><span class="line">gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE,</span><br><span class="line">GST_MESSAGE_ERROR | GST_MESSAGE_EOS);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free resources */</span></span><br><span class="line"><span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">gst_message_unref(msg);</span><br><span class="line">gst_object_unref(bus);</span><br><span class="line">gst_element_set_state(pipeline, GST_STATE_NULL);</span><br><span class="line">gst_object_unref(pipeline);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>GStreamer on Windows的安装至此算是搞定了，还是有花蛮多精力的！No pains, no gains. 接下来还要学写GStreamer插件，能写好的再记录一下！</p><p><strong>参考</strong></p><p><a href="https://gstreamer.freedesktop.org/data/pkg/windows/1.18.4/msvc/">https://gstreamer.freedesktop.org/data/pkg/windows/1.18.4/msvc/</a></p><p><a href="https://gstreamer.freedesktop.org/documentation/installing/index.html?gi-language=c">https://gstreamer.freedesktop.org/documentation/installing/index.html?gi-language=c</a></p><p><a href="https://www.cnblogs.com/0-lingdu/p/12718613.html">https://www.cnblogs.com/0-lingdu/p/12718613.html</a></p><p><a href="https://blog.csdn.net/kongxingxing/article/details/104270463">https://blog.csdn.net/kongxingxing/article/details/104270463</a></p><p><a href="https://blog.csdn.net/fly_bear_unknown/article/details/113917633">https://blog.csdn.net/fly_bear_unknown/article/details/113917633</a></p>]]></content>
    
    
    <summary type="html">GStreamer在Ubuntu和Windows上安装</summary>
    
    
    
    <category term="Internship" scheme="http://example.com/categories/Internship/"/>
    
    
    <category term="GStreamer" scheme="http://example.com/tags/GStreamer/"/>
    
  </entry>
  
  <entry>
    <title>Jetson 部署 Deepstream</title>
    <link href="http://example.com/2021/07/02/week-1/"/>
    <id>http://example.com/2021/07/02/week-1/</id>
    <published>2021-07-02T12:13:16.000Z</published>
    <updated>2021-07-24T06:25:56.273Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Jetson-部署-Deep-stream"><a href="#Jetson-部署-Deep-stream" class="headerlink" title="Jetson 部署 Deep stream"></a>Jetson 部署 Deep stream</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="查看Jetson信息"><a href="#查看Jetson信息" class="headerlink" title="查看Jetson信息"></a><strong>查看Jetson信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo pip3 install jetson-stats</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jtop</span></span><br></pre></td></tr></table></figure><p><img src="/2021/07/02/week-1/01.png" alt="01"></p><h3 id="Jetson-Setup"><a href="#Jetson-Setup" class="headerlink" title="Jetson Setup"></a><strong>Jetson Setup</strong></h3><p>如果是 Jetson Nano 或者 Jetson Xavier NX developer kit, 从<a href="https://developer.nvidia.com/embedded/jetpack">JetPack SDK</a>下载 SD card image，这其中包含了 CUDA, TensorRT and cuDNN.</p><h3 id="命令行工具nvpmodel"><a href="#命令行工具nvpmodel" class="headerlink" title="命令行工具nvpmodel"></a><strong>命令行工具nvpmodel</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo nvpmodel --query</span></span><br><span class="line">NV Fan Mode:cool</span><br><span class="line">NV Power Mode: MODE_15W_2CORE</span><br><span class="line">0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到模式2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo nvpmodel -m 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最大化Xavier性能</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo jetson_clocks</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前设置：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo jetson_clocks --show</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复以前的设置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo jetson_clocks --restore</span></span><br></pre></td></tr></table></figure><h3 id="查看操作系统信息"><a href="#查看操作系统信息" class="headerlink" title="查看操作系统信息"></a><strong>查看操作系统信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux查看版本当前操作系统 内核信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> uname --a</span></span><br><span class="line">Linux name-desktop 4.9.140-tegra #1 SMP PREEMPT Thu Jun 25 21:22:12 PDT 2020 aarch64 aarch64 aarch64 GNU/Linux</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux查看当前操作系统 版本信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/version</span></span><br><span class="line">Linux version 4.9.140-tegra (buildbrain@mobile-u64-3357) (gcc version 7.3.1 20180425 [linaro-7.3-2018.05 revision d29120a424ecfbc167ef90065c0eeb7f91977701] (Linaro GCC 7.3-2018.05) ) #1 SMP PREEMPT Thu Jun 25 21:22:12 PDT 2020</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux查看版本当前操作系统 发行版信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/issue</span></span><br><span class="line">Ubuntu 18.04.5 LTS \n \l</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看cpu的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/cpuinfo</span></span><br><span class="line">processor: 0</span><br><span class="line">model name: ARMv8 Processor rev 0 (v8l)</span><br><span class="line">BogoMIPS: 62.50</span><br><span class="line">Features: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp</span><br><span class="line">CPU implementer: 0x4e</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant: 0x0</span><br><span class="line">CPU part: 0x004</span><br><span class="line">CPU revision: 0</span><br><span class="line">MTS version: 50168445</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line">processor: 5</span><br><span class="line">model name: ARMv8 Processor rev 0 (v8l)</span><br><span class="line">BogoMIPS: 62.50</span><br><span class="line">Features: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp</span><br><span class="line">CPU implementer: 0x4e</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant: 0x0</span><br><span class="line">CPU part: 0x004</span><br><span class="line">CPU revision: 0</span><br><span class="line">MTS version: 50168445</span><br></pre></td></tr></table></figure><h3 id="DeepStream-Setup"><a href="#DeepStream-Setup" class="headerlink" title="DeepStream Setup"></a>DeepStream Setup</h3><ol><li><p><a href="https://developer.nvidia.com/deepstream-sdk">NVIDIA DeepStream SDK</a>官网下载 <code>deepstream_sdk_v5.0.1_jetson.tbz2</code></p></li><li><p>命令行执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tar -xvf deepstream_sdk_v5.0.1_jetson.tbz2 -C /</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/nvidia/deepstream/deepstream-5.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ./install.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ldconfig</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/2021/07/02/week-1/02.png" alt="02"></p><h3 id="Run-deepstream-app"><a href="#Run-deepstream-app" class="headerlink" title="Run deepstream-app"></a>Run deepstream-app</h3><ol><li><p>导航到示例目录(samples)。</p></li><li><p>输入以下命令以运行参考应用程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> deepstream-app -c &lt;path_to_config_file&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;path_to_config_file&gt;</code>可以在<code>configs/deepstream-app/</code>中找到</p></li><li><p>在源文件目录中找到源码，编译并运行demo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 源文件目录（deepstream-test1）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 都需要make编译，具体请参阅其中的README文档</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/nvidia/deepstream/deepstream-5.0/sources/apps/sample_apps/deepstream-test1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">deepstream_test1_app.c  dstest1_pgie_config.txt  Makefile  README</span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">deepstream-test1-app    deepstream_test1_app.o   Makefile</span><br><span class="line">deepstream_test1_app.c  dstest1_pgie_config.txt  README</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行deepstream-test1-app</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./deepstream-test1-app /opt/nvidia/deepstream/deepstream-5.0/samples/streams/sample_720p.h264</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Reference test application</th><th align="center">Path inside sources directory</th><th>Description</th></tr></thead><tbody><tr><td align="center">Sample test application 1</td><td align="center">apps/sample_apps/deepstream-test1</td><td>Sample of how to use DeepStream elements for a single H.264 stream: filesrc → decode → nvstreammuH264 containerized streamx → nvinfer (primary detector) → nvdsosd → renderer.</td></tr><tr><td align="center">Sample test application 2</td><td align="center">apps/sample_apps/deepstream-test2</td><td>Sample of how to use DeepStream elements for a single H.264 stream: filesrc → decode → nvstreammux → nvinfer (primary detector) → nvtracker → nvinfer (secondary classifier) → nvdsosd → renderer.</td></tr><tr><td align="center">Sample test application 3</td><td align="center">apps/sample_apps/deepstream-test3</td><td>Builds on deepstream-test1 (simple test application 1) to demonstrate how to:Use multiple sources in the pipelineUse a uridecodebin to accept any type of input (e.g. RTSP/File), any GStreamer supported container format, and any codecConfigure Gst-nvstreammux to generate a batch of frames and infer on it for better resource utilizationExtract the stream metadata, which contains useful information about the frames in the batched buffer</td></tr><tr><td align="center">Sample test application 4</td><td align="center">apps/sample_apps/deepstream-test4</td><td>Builds on deepstream-test1 for a single H.264 stream: filesrc, decode, nvstreammux, nvinfer, nvdsosd, renderer to demonstrate how to:Use the Gst-nvmsgconv and Gst-nvmsgbroker plugins in the pipelineCreate NVDS_META_EVENT_MSG type metadata and attach it to the bufferUse NVDS_META_EVENT_MSG for different types of objects, e.g. vehicle and personImplement “copy” and “free” functions for use if metadata is extended through the extMsg field</td></tr><tr><td align="center">Sample test application 5</td><td align="center">apps/sample_apps/deepstream-test5</td><td>Builds on top of deepstream-app. Demonstrates:Use of Gst-nvmsgconv and Gst-nvmsgbroker plugins in the pipeline for multistreamHow to configure Gst-nvmsgbroker plugin from the config file as a sink plugin (for KAFKA, Azure, etc.)How to handle the RTCP sender reports from RTSP servers or cameras and translate the Gst Buffer PTS to a UTC timestamp.For more details refer the RTCP Sender Report callback function <code>test5_rtcp_sender_report_callback()</code> registration and usage in <code>deepstream_test5_app_main.c</code>. GStreamer callback registration with rtpmanager element’s “handle-sync” signal is documented in <code>apps-common/src/deepstream_source_bin.c</code>.</td></tr></tbody></table></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">|-- opt</span><br><span class="line">    |-- nvidia</span><br><span class="line">        |-- deepstream</span><br><span class="line">            |-- deepstream</span><br><span class="line">            |-- deepstream-5.0</span><br><span class="line">                |-- bin</span><br><span class="line">                |-- doc</span><br><span class="line">                |-- lib</span><br><span class="line">                |-- samples</span><br><span class="line">                |   |-- configs</span><br><span class="line">                |   |   |-- deepstream-app</span><br><span class="line">                |   |   |   |-- config_infer_primary.txt#将nvinfer配置为主要检测器</span><br><span class="line">                |   |   |   |-- config_infer_primary_nano.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_carcolor.txt#将nvinfer配置为辅助分类器</span><br><span class="line">                |   |   |   |-- config_infer_secondary_carmake.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_vehicletypes.txt</span><br><span class="line">                |   |   |   |-- iou_config.txt#配置一个低级的IOU跟踪器。</span><br><span class="line">                |   |   |   |-- source12_1080p_dec_infer-resnet_tracker_tiled_display_fp16_tx2.txt</span><br><span class="line">                |   |   |   |-- source1_csi_dec_infer_resnet_int8.txt   #演示一个CSI摄像机作为输入；仅适用于Jetson</span><br><span class="line">                |   |   |   |-- source1_usb_dec_infer_resnet_int8.txt#演示一个USB摄像机作为输入</span><br><span class="line">                |   |   |   |-- source2_csi_usb_dec_infer_resnet_int8.txt</span><br><span class="line">                                #演示30个具有主要推理功能的流解码（仅适用于dGPU和Jetson AGX Xavier平台）</span><br><span class="line">                |   |   |   |-- source30_1080p_dec_infer-resnet_tiled_display_int8.txt </span><br><span class="line">                #演示具有主要推理，对象跟踪和三个不同辅助分类器的四个流解码（仅适用于dGPU和Jetson AGX Xavier平台）</span><br><span class="line">                |   |   |   |-- source4_1080p_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt</span><br><span class="line">                |   |   |   |-- source6_csi_dec_infer_resnet_int8.txt</span><br><span class="line">                |   |   |   |-- source8_1080p_dec_infer-resnet_tracker_tiled_display_fp16_nano.txt</span><br><span class="line">                |   |   |   |-- source8_1080p_dec_infer-resnet_tracker_tiled_display_fp16_tx1.txt</span><br><span class="line">                |   |   |   |-- tracker_config.yml#配置NvDCF跟踪器</span><br><span class="line">                |   |   |-- deepstream-app-trtis</span><br><span class="line">                |   |   |-- tlt_pretrained_models</span><br><span class="line">                |   |-- models</span><br><span class="line">                |   |-- streams</span><br><span class="line">                |   |   |-- sample_1080p_h264.mp4#H264 containerized stream</span><br><span class="line">                |   |   |-- sample_1080p_h265.mp4#H265 containerized stream</span><br><span class="line">                |   |   |-- sample_720p.h264#H264 elementary stream</span><br><span class="line">                |   |   |-- sample_720p.jpg#JPEG image</span><br><span class="line">                |   |   |-- sample_720p.mjpeg#MJPEG stream</span><br><span class="line">                |   |   |-- sample_720p.mp4</span><br><span class="line">                |   |   |-- sample_cam6.mp4#H264 containerized stream(360D camera stream)</span><br><span class="line">                |   |   |-- sample_industrial.jpg</span><br><span class="line">                |   |   |-- sample_qHD.h264</span><br><span class="line">                |   |   |-- sample_qHD.mp4</span><br><span class="line">                |   |   |-- yoga.jpg</span><br><span class="line">                |   |   |-- yoga.mp4</span><br><span class="line">                |   |-- trtis_model_repo</span><br><span class="line">                |-- sources</span><br><span class="line">                    |-- apps</span><br><span class="line">                    |   |-- apps-common</span><br><span class="line">                    |   |   |-- includes</span><br><span class="line">                    |   |-- sample_apps</span><br><span class="line">                    |       |-- deepstream-app#端到端示例演示了4级联神经网络(1个一级检测器和3个二级分类器)的多相机流，并显示平铺输出。</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- deepstream_app.c</span><br><span class="line">                    |       |   |-- deepstream_app.h</span><br><span class="line">                    |       |   |-- deepstream_app_config_parser.c</span><br><span class="line">                    |       |   |-- deepstream_app_main.c</span><br><span class="line">                    |       |-- deepstream-test1#对单一H264视频流，应用filesrc→decode→nvstreammuH264 containerized streamx→nvinfer(主检测器)→nvdsosd→renderer</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                 Builds on deepstream-test1 (simple test application 1) to demonstrate how to:Use multiple sources in the pipelineUse a uridecodebin to accept any type of input (e.g. RTSP/File), any GStreamer supported container format, and any codecConfigure Gst-nvstreammux to generate a batch of frames and infer on it for better resource utilizationExtract the stream metadata, which contains useful information about the frames in the batched buffer   |       |   |-- deepstream-test1-app</span><br><span class="line">                    |       |   |-- deepstream_test1_app.c</span><br><span class="line">                    |       |   |-- deepstream_test1_app.o</span><br><span class="line">                    |       |   |-- dstest1_pgie_config.txt</span><br><span class="line">                    |       |-- deepstream-test2#建立在test1之上，显示额外的属性，如跟踪和二级分类属性。</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- deepstream_test2_app.c</span><br><span class="line">                    |       |   |-- dstest2_pgie_config.txt</span><br><span class="line">                    |       |   |-- dstest2_sgie1_config.txt</span><br><span class="line">                    |       |   |-- dstest2_sgie2_config.txt</span><br><span class="line">                    |       |   |-- dstest2_sgie3_config.txt</span><br><span class="line">                    |       |   |-- dstest2_tracker_config.txt</span><br><span class="line">                    |       |   |-- tracker_config.yml</span><br><span class="line">                    |       |-- deepstream-test3#建立在test1的基础上，显示多个输入源和批处理使用nvstreammuxer。</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- deepstream_test3_app.c</span><br><span class="line">                    |       |   |-- dstest3_pgie_config.txt</span><br><span class="line">                    |       |-nfer_primary.txt</span><br><span class="line">                |   |   |   |-- config_infer_primary_nano.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_carcolor.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_carmake.txt</span><br><span class="line">                |   |   |   |-- config_infer_secondary_vehicletypes.txt</span><br><span class="line">                |   |   |   |-- iou_config.txt</span><br><span class="line">                |   |   |   |-- source12_1080p_dec_infer-resnet_tracker_tiled_display_fp16_tx2.txt</span><br><span class="line">                |   |   |   |-- source1_csi_dec_infer_resnet_int8.txt</span><br><span class="line">                |   |   |   |-- source1_usb_dec_infer_resnet_int8.txt</span><br><span class="line">                |   |   |   |-- source2_cs- deepstream-test4</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- cfg_amqp.txt</span><br><span class="line">                    |       |   |-- cfg_azure.txt</span><br><span class="line">                    |       |   |-- cfg_kafka.txt</span><br><span class="line">                    |       |   |-- deepstream_test4_app.c</span><br><span class="line">                    |       |   |-- dstest4_msgconv_config.txt</span><br><span class="line">                    |       |   |-- dstest4_pgie_config.txt</span><br><span class="line">                    |       |-- deepstream-test5</span><br><span class="line">                    |       |   |-- Makefile</span><br><span class="line">                    |       |   |-- README</span><br><span class="line">                    |       |   |-- deepstream_test5_app.h</span><br><span class="line">                    |       |   |-- deepstream_test5_app_main.c</span><br><span class="line">                    |       |   |-- deepstream_utc.c</span><br><span class="line">                    |       |   |-- configs</span><br><span class="line">                    |       |       |-- dstest5_msgconv_sample_config.txt</span><br><span class="line">                    |       |       |-- test5_config_file_src_infer.txt</span><br><span class="line">                    |       |       |-- test5_config_file_src_infer_azure_iotedge.txt</span><br><span class="line">                    |       |       |-- test5_config_file_src_infer_tiler_demux.txt</span><br><span class="line">                    |       |       |-- test5_config_file_src_infer_tracker_sgie.txt</span><br><span class="line">                    |       |       |-- test5_dec_infer-resnet_tracker_sgie_tiled_display_int8.txt</span><br><span class="line">                    |       |       |-- test5_ota_override_config.txt</span><br><span class="line">                    |-- gst-plugins</span><br><span class="line">                    |-- includes</span><br><span class="line">                    |-- libs</span><br><span class="line">                    |-- objectDetector_FasterRCNN</span><br><span class="line">                    |-- objectDetector_SSD</span><br><span class="line">                    |-- objectDetector_Yolo</span><br><span class="line">                    |-- tools</span><br></pre></td></tr></table></figure><p>日志信息：</p><p><img src="/2021/07/02/week-1/04.png" alt="04"><br>结果显示：</p><p><img src="/2021/07/02/week-1/05.png" alt="05"></p><p><img src="/2021/07/02/week-1/08.png" alt="08"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.nvidia.com/metropolis/deepstream/dev-guide/index.html">NVIDIA DeepStream SDK开发指南</a></p><p><a href="https://docs.nvidia.com/metropolis/deepstream/plugin-manual/index.html">NVIDIA DeepStream插件手册</a></p><p><a href="https://docs.nvidia.com/metropolis/deepstream/dev-guide/">NVIDIA DeepStream SDK API参考文档</a></p>]]></content>
    
    
    <summary type="html">Jetson Xavier NX部署 Deepstream</summary>
    
    
    
    <category term="Internship" scheme="http://example.com/categories/Internship/"/>
    
    
    <category term="Jetson" scheme="http://example.com/tags/Jetson/"/>
    
    <category term="Deepstreeam" scheme="http://example.com/tags/Deepstreeam/"/>
    
  </entry>
  
  <entry>
    <title>webserver</title>
    <link href="http://example.com/2021/04/11/webserver/"/>
    <id>http://example.com/2021/04/11/webserver/</id>
    <published>2021-04-11T13:32:24.000Z</published>
    <updated>2021-08-11T13:46:40.269Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="TinyWebserver"><a href="#TinyWebserver" class="headerlink" title="TinyWebserver"></a>TinyWebserver</h1><h2 id="什么是Web-Server（网络服务器）"><a href="#什么是Web-Server（网络服务器）" class="headerlink" title="什么是Web Server（网络服务器）"></a>什么是Web Server（网络服务器）</h2>]]></content>
    
    
    <summary type="html">Linux网络编程项目实践。参考游双《Linux高性能服务器编程》和https://github.com/qinguoyi/TinyWebServer/tree/master。</summary>
    
    
    
    <category term="服务器" scheme="http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CMake&amp;Meson 边学边记</title>
    <link href="http://example.com/2021/04/10/cmake-notes/"/>
    <id>http://example.com/2021/04/10/cmake-notes/</id>
    <published>2021-04-10T12:32:42.000Z</published>
    <updated>2021-07-24T06:24:58.207Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="CMake笔记"><a href="#CMake笔记" class="headerlink" title="CMake笔记"></a>CMake笔记</h1><p><strong>一开始是记录CMake的学习，7月份实习用到了Meson，故也记录在了这篇文章中。</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><ul><li>网址：<a href="https://cmake.org/download/">https://cmake.org/download/</a></li></ul><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><ul><li><p>直接安装 <code>apt install cmake</code></p></li><li><p>网址：<a href="https://cmake.org/download/">https://cmake.org/download/</a>     下载对应版本的CMake（32位或者64位）</p></li><li><p>输入以下命令进行解压</p><p><code>    tar -zxvf cmake-3.10.0-rc4-Linux-x86_64.tar.gz</code></p></li><li><p>把解压后的目录改名为：cmake</p><p><code>mv cmake-3.10.0-rc4-Linux-x86_64 cmake</code></p></li><li><p>安装完毕，命令行输入：<code>cmake --version</code>检测是否安装成功</p></li></ul><h2 id="CMake初探"><a href="#CMake初探" class="headerlink" title="CMake初探"></a>CMake初探</h2><p><strong>基本都在我的阿里云服务器上倒腾，环境为Ubuntu 16.04</strong></p><h3 id="CMake基础知识"><a href="#CMake基础知识" class="headerlink" title="CMake基础知识"></a>CMake基础知识</h3><ul><li><p>最低版本</p><ul><li><p><code>CMakeLists.txt</code>的第一行都会写：<code>cmake_minimum_required(VERSION 3.1)</code>，该命令指定了CMake的最低版本是3.1</p></li><li><p>命令名称<code>cmake_minimum_required</code>不区分大小写</p></li><li><p>设置版本范围：<code>cmake_minimum_required(VERSION 3.1...3.12)</code></p></li><li><p>判断CMake版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#该命令表示：如果CMake版本小于3.12，则if块将为true，然后将设置为当前CMake版本</span><br><span class="line">#如果CMake版本高于3.12，if块为假，cmake_minimum_required将被正确执行</span><br><span class="line">if($&#123;CMAKE_VERSION&#125; VERSION_LESS 3.12)     </span><br><span class="line">    cmake_policy(VERSION $&#123;CMAKE_MAJOR_VERSION&#125;.$&#123;CMAKE_MINOR_VERSION&#125;) </span><br><span class="line">endif() </span><br></pre></td></tr></table></figure></li><li><p>注意：如果需要支持非命令行Windows版本则需在上面的if判断加上else分支，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.1)</span><br><span class="line">if($&#123;CMAKE_VERSION&#125; VERSION_LESS 3.12)</span><br><span class="line">    cmake_policy(VERSION $&#123;CMAKE_MAJOR_VERSION&#125;.$&#123;CMAKE_MINOR_VERSION&#125;)</span><br><span class="line">else()</span><br><span class="line">    cmake_policy(VERSION 3.12)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置生成项目名称</p><ul><li><p>命令：<code>project（MyProject）</code>,表示生成的工程名字叫做：<code>MyProject</code></p></li><li><p>命令还可以标识项目支持的语言，写法：<code>project（MyProject[C] [C++]）</code>,不过通常将后面的参数省掉，因为默认支持所有语言</p></li><li><p>使用该指令之后系统会自动创建两个变量：<code>&lt;projectname&gt;_BINARY_DIR</code>  二进制文件保存路径、<code>&lt;projectname&gt;_SOURCE_DIR</code>  源代码路径</p></li><li><p>执行<code>project(MyProject)</code>，就是定义了一个项目的名称为<code>MyProject</code>，对应的就会生成两个变量：<code>_BINARY_DIR</code>和<code>_SOURCE_DIR</code>，但是<code>cmake</code>中其实已经有两个预定义的变量：<code>PROJECT_BINARY_DIR</code> 和 <code>PROJECT_SOURCR_DIR</code></p></li><li><p>关于两个变量是否相同，涉及到是内部构建还是外部构建</p><ul><li><p>内部构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake ./</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>外部构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd ./build</span><br><span class="line">cmake ../</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>内部构建和外部构建的不同在于：<code>cmake </code>的工作目录不同。内部构建会将<code>cmake</code>生成的中间文件和可执行文件放在和项目同一目录；外部构建的话，中间文件和可执行文件会放在<code>build</code>目录</p></li><li><p><code>PROJECT_SOURCE_DIR</code>和<code>_SOURCE_DIR</code>无论内部构建还是外部构建，指向的内容都是一样的，都指向工程的根目录</p></li><li><p><code>PROJECT_BINARY_DIR</code>和<code>_BINARY_DIR</code>指向的相同内容，内部构建的时候指向<code>CMakeLists.txt</code>文件的目录，外部构建指向<code>target</code>编译的目录</p></li></ul></li></ul></li><li><p>生成可执行文件</p><ul><li><p>语法：<code>add_executable(exename srcname)</code></p><blockquote><ul><li>exename:生成的可执行文件的名字</li><li>srcname:原来的源文件</li></ul></blockquote></li><li><p>该命令指定生成可执行文件的名字以及指出需要依赖的源文件的文件名</p></li><li><p>获取文件路径中的所有源文件</p><ul><li>命令：<code>aux_sourcr_directory(&lt;dir&gt; &lt;variable&gt;)</code></li><li>例子：<code>aux_sourcr_directory(. DIR_SRCS)</code>，将当前目录下的源文件名字存放到变量<code>DIR_SRCS</code>里面 ，如果源文件比较多，直接用<code>DIR_SRCS</code>变量即可</li></ul></li><li><p>生成可执行文件：<code>add_executable(Demo $&#123;DIR_SRCS&#125;)</code>，将生成的可执行文件命名为：<code>Demo</code></p></li></ul></li><li><p>生成<code>lib</code>库</p><ul><li><p>命令：<code>add_library(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)</code></p><blockquote><ul><li><code>libname</code>:生成的库文件的名字</li><li><code>[SHARED|STATIC|MODULE]</code>：生成库文件的类型（动态库|静态库|模块）</li><li><code>[EXCLUDE_FROM_ALL]</code>：有这个参数表示该库不会被默认构建</li><li><code>source2 ... sourceN</code>：生成库依赖的源文件，如果源文件比较多，可以使用</li><li><code>aux_sourcr_directory</code>命令获取路径下所有源文件，具体章节参见：<code>CMake</code>初探-&gt;生成可执行文件-&gt;获取路径中所有源文件</li></ul></blockquote></li><li><p>例子：<code>add_library(ALib SHARE alib.cpp)</code></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_executable(demo demo.cpp) # 生成可执行文件</span><br><span class="line">add_library(common STATIC util.cpp) # 生成静态库</span><br><span class="line">add_library(common SHARED util.cpp) # 生成动态库或共享库</span><br></pre></td></tr></table></figure><blockquote><p><code>add_library</code> 默认生成是静态库，通过以上命令生成文件名字，</p><ul><li>在 Linux 下是：<br>demo<br>libcommon.a<br>libcommon.so</li><li>在 Windows 下是：<br>demo.exe<br>common.lib<br>common.dll</li></ul></blockquote><ul><li><p>添加头文件目录</p><ul><li><p>命令1：<code>target_include_directories(&lt;target&gt; [SYSTEM] [BEFORE]   &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]   [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</code></p><blockquote><p>当我们添加子项目之后还需要设置一个<code>include</code>路径，例子：<br>eg:<code>target_include_directories(RigelEditor PUBLIC ./include/rgeditor)</code>，表示给<code>RigelEditor</code> 这个子项目添加一个库文件的路径</p></blockquote></li><li><p>命令2：<code>include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 …])</code></p><blockquote><p>参数解析：</p><ul><li>[AFTER|BEFORE]：指定了要添加路径是添加到原有列表之前还是之后</li><li>[SYSTEM]：若指定了<code>system</code>参数，则把被包含的路径当做系统包含路径来处理</li><li>dir1 [dir2 …]把这些路径添加到<code>CMakeLists</code>及其子目录的<code>CMakeLists</code>的头文件包含项目中<br>相当于<code>g++</code>选项中的-l的参数的作用</li><li>举例：<code>include_directories(&quot;/opt/MATLAB/R2012a/extern/include&quot;)</code></li></ul></blockquote></li></ul><ul><li>两条指令的作用都是讲将<code>include</code>的目录添加到目标区别在于<code>include_directorie</code>s是<code>CMake</code>编译所有目标的目录进行添加，<code>target_include_directories</code>是将<code>CMake</code>编译的指定的特定目标的包含目录进行添加</li></ul></li><li><p>添加需要链接的库文件路径</p><ul><li><p>命令1:<code>target_link_libraries(&lt;target&gt; [item1 [item2 [...]]] [[debug|optimized|general] &lt;item&gt;] ...)</code></p><blockquote><ul><li>作用：为给定的目标设置链接时使用的库（设置要链接的库文件的名称）</li><li>eg:target_link_libraries(MyProject a b.a <a href="http://c.so/">c.so</a>)    //将若干库文件链接到hello中，target_link_libraries里的库文件的顺序符合gcc/g++链接顺序规则，即：被依赖的库放在依赖他的库的后面，如果顺序有错，链接将会报错</li><li>关键字：debug对应于调试配置</li><li>关键字：optimized对应于所有其他的配置类型</li><li>关键字：general对应于所有的配置（该属性是默认值）</li></ul></blockquote></li><li><p>命令2：<code>link_libraries</code></p><blockquote><ul><li>作用：给当前工程链接需要的库文件（全路径）</li><li>eg:<code>link_libraries((&quot;/opt/MATLAB/R2012a/bin/glnxa64/libeng.so&quot;)</code>//必须添加带名字的全路径</li></ul></blockquote></li><li><p>区别：<code>target_link_libraries</code>可以给工程或者库文件设置其需要链接的库文件，而且不需要填写全路径，但是<code>link_libraries</code>只能给工程添加依赖的库，而且必须添加全路径</p></li><li><p>添加需要链接的库文件目录</p><blockquote><ul><li><p>命令：link_directories（添加需要链接的库文件目录）</p></li><li><p>语法：link_directories(directory1 directory2 …)</p></li><li><p>例子：link_directories(“/opt/MATLAB/R2012a/bin/glnxa64”)</p></li></ul></blockquote></li><li><p>指令的区别：指令的前缀带<code>target</code>，表示针对某一个目标进行设置，必须指明设置的目标；<code>include_directories</code>是在编译时用，指明<code>.h</code>文件的路径；<code>link_directoeies</code>是在链接时用的，指明链接库的路径；<code>target_link_libraries</code>是指明链接库的名字，也就是具体谁链接到哪个库。<code>link_libraries</code>不常用，因为必须指明带文件名全路径</p></li></ul></li><li><p>控制目标属性</p><ul><li><p>以上的几条命令的区分都是：是否带<code>target</code>前缀，在<code>CMake</code>里面，一个<code>target</code>有自己的属性集，如果我们没有显示的设置这些<code>target</code>的属性的话，<code>CMake</code>默认是由相关的全局属性来填充<code>target</code>的属性，我们如果需要单独的设置<code>target</code>的属性，需要使用命令：<code>set_target_properties()</code></p></li><li><p>命令格式:</p><blockquote><p>set_target_properties(target1 target2 …<br>PROPERTIES<br>属性名称1  值<br>属性名称2  值<br>…<br>)</p></blockquote></li><li><p>控制编译选项的属性是：<code>COMPILE_FLAGS</code></p></li><li><p>控制链接选项的属性是：<code>LINK_FLAGS</code></p></li><li><p>控制输出路径的属性：<code>EXECUTABLE_OUTPUT_PATH</code>（exe的输出路径）、<code>LIBRARY_OUTPUT_PATH</code>（库文件的输出路径）</p></li><li><p>举例：</p><blockquote><p>set_target_properties(exe<br>PROPERTIES<br>LINK_FLAGS          -static<br>LINK_FLAGS_RELEASE  -s<br>)</p></blockquote><p>这条指令会使得<code>exe</code>这个目标在所有的情况下都采用<code>-static</code>选项，而且在<code>release build</code>的时候<code>-static -s</code>选项。但是这个属性仅仅在<code>exe</code>这个<code>target</code>上面有效</p></li></ul></li></ul><h3 id="Cmake构建示例"><a href="#Cmake构建示例" class="headerlink" title="Cmake构建示例"></a>Cmake构建示例</h3><p>经典的<code>helloworld</code>必须出现啊，首先创建一个<code>main.cpp</code>包含源的文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> parameter_size, <span class="keyword">char</span> **parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = a + <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello word  &quot;</span> &lt;&lt; parameter_size &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们创建一个 <code>CMakeLists.txt</code>同一个目录中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.5)</span><br><span class="line">#项目名称</span><br><span class="line">project(test_cmaka)</span><br><span class="line">#代码路径</span><br><span class="line">aux_source_directory(. DIR_TOOT_SRCS)</span><br><span class="line">#dubug 模式</span><br><span class="line">set (CMAKE_CXX_FLAGS  &quot;$&#123;CMAKE_CXX_FLAGS&#125; -g&quot;)</span><br><span class="line">#将可执行文件放入bin目录</span><br><span class="line">set( EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line">#生成可执行的文件</span><br><span class="line">add_executable(main $&#123;DIR_TOOT_SRCS&#125;)</span><br></pre></td></tr></table></figure><p>文件目录 如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- test_cmake</span><br><span class="line">    |-- main.cpp</span><br><span class="line">    |-- CMakeLists.txt</span><br></pre></td></tr></table></figure><p>现在准备构建我们的应用程序，导航到文件目录下，创建<code>build</code>文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build</span><br></pre></td></tr></table></figure><p>进入<code>build</code>目录，执行外部构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd build</span><br><span class="line"># cmake ../</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- The C compiler identification is GNU 7.5.0</span><br><span class="line">-- The CXX compiler identification is GNU 7.5.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /root/share/C++/test_cmake/build</span><br></pre></td></tr></table></figure><p>再看看目录下的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMakeCache.txt  CMakeFiles  cmake_install.cmake  Makefile</span><br></pre></td></tr></table></figure><p>可以看到成功生成了Makefile，还有一些cmake运行时自动生成的文件<br>然后在终端下输入make并回车,输出以下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanning dependencies of target main</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/main.dir/main.cpp.o</span><br><span class="line">[100%] Linking CXX executable ../bin/main</span><br><span class="line">[100%] Built target main</span><br></pre></td></tr></table></figure><p>此时，文件目录如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-- test_cmake</span><br><span class="line">    |-- bin</span><br><span class="line">    |-- build</span><br><span class="line">    |-- main.cpp</span><br><span class="line">    |-- CMakeLists.txt</span><br></pre></td></tr></table></figure><p>生成的可执行文件在<code>bin</code>目录下，导航到该目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ../bin</span><br><span class="line">./main</span><br></pre></td></tr></table></figure><p>产生预期的输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello word  1 </span><br></pre></td></tr></table></figure><p><code>github</code>上有不错的<code>CMake——examples</code>  链接：<a href="https://github.com/ttroy50/cmake-examples">https://github.com/ttroy50/cmake-examples</a></p><h1 id="Meson笔记"><a href="#Meson笔记" class="headerlink" title="Meson笔记"></a>Meson笔记</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux安装-1"><a href="#Linux安装-1" class="headerlink" title="Linux安装"></a>Linux安装</h3><ul><li><p>Meson基于Python3运行，要求Python版本3.5以上</p></li><li><p>安装依赖 <code>ninja-build</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ninja-build</span><br></pre></td></tr></table></figure></li><li><p>安装<code>Meson</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install meson #root      </span><br><span class="line"></span><br><span class="line">pip3 install --user meson #user 官方推荐</span><br></pre></td></tr></table></figure></li><li><p>也从<code>git</code>下载安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/mesonbuild/meson.git /path/to/sourcedir</span><br></pre></td></tr></table></figure></li></ul><h3 id="Meson构建示例"><a href="#Meson构建示例" class="headerlink" title="Meson构建示例"></a>Meson构建示例</h3><p>依然经典的<code>helloworld</code>，首先创建一个<code>main.c</code>包含源的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello there.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们创建一个 <code>meson.build</code>同一个目录中调用的文中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">project(&#x27;tutorial&#x27;, &#x27;c&#x27;)</span><br><span class="line">executable(&#x27;main&#x27;, &#x27;main.c&#x27;)</span><br></pre></td></tr></table></figure><p>文件目录如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-- test_meson</span><br><span class="line">    |-- main.c</span><br><span class="line">    |-- meson.build</span><br></pre></td></tr></table></figure><p>现在准备构建我们的应用程序，导航到文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#构建程序</span><br><span class="line">$ meson build</span><br></pre></td></tr></table></figure><p>创建一个单独的构建目录<code>build</code>来保存所有编译器输出。<code>Meson</code> 与其他一些构建系统的不同之处在于它不允许源代码构建。您必须始终创建一个单独的构建目录。常见的约定是将默认构建目录放在顶级源目录的子目录中</p><p>当 <code>Meson</code> 运行时，它会打印以下输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">The Meson build system</span><br><span class="line">Version: 0.58.1</span><br><span class="line">Source dir: /root/share/C++/test_meson</span><br><span class="line">Build dir: /root/share/C++/test_meson/build</span><br><span class="line">Build type: native build</span><br><span class="line">Project name: tutorial</span><br><span class="line">Project version: undefined</span><br><span class="line">C compiler for the host machine: cc (gcc 7.5.0 &quot;cc (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;)</span><br><span class="line">C linker for the host machine: cc ld.bfd 2.30</span><br><span class="line">Host machine cpu family: x86_64</span><br><span class="line">Host machine cpu: x86_64</span><br><span class="line">Build targets in project: 1</span><br></pre></td></tr></table></figure><p>现在已经准备好构建我们的代码了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd buildd</span><br><span class="line">$ ninja</span><br></pre></td></tr></table></figure><p>如果您的 <code>Meson</code> 版本高于 <code>0.55.0</code>，您可以使用新的后端不可知构建命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd build</span><br><span class="line">$ meson compile</span><br></pre></td></tr></table></figure><p>一旦构建了可执行文件，我们就可以运行它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure><p>这会产生预期的输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello there.</span><br></pre></td></tr></table></figure><p>​    </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mubu.com/doc/t1VDCEn4O0#o-17f166a665726b18d">https://mubu.com/doc/t1VDCEn4O0#o-17f166a665726b18d</a></p><p><a href="https://cmake.org/documentation">https://cmake.org/documentation</a></p><p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">https://cmake.org/cmake/help/latest/guide/tutorial/index.html</a></p><p><a href="https://mesonbuild.com/">https://mesonbuild.com/</a></p>]]></content>
    
    
    <summary type="html">学习生产力工具CMake、Meson</summary>
    
    
    
    <category term="Tools" scheme="http://example.com/categories/Tools/"/>
    
    
    <category term="CMake" scheme="http://example.com/tags/CMake/"/>
    
    <category term="Meson" scheme="http://example.com/tags/Meson/"/>
    
  </entry>
  
  <entry>
    <title>多路复用-select、poll、epoll</title>
    <link href="http://example.com/2021/03/29/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select%E3%80%81poll%E3%80%81epoll/"/>
    <id>http://example.com/2021/03/29/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select%E3%80%81poll%E3%80%81epoll/</id>
    <published>2021-03-29T02:04:11.000Z</published>
    <updated>2021-09-06T08:23:04.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多路复用之select、poll、epoll详解"><a href="#多路复用之select、poll、epoll详解" class="headerlink" title="多路复用之select、poll、epoll详解"></a>多路复用之select、poll、epoll详解</h1><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p><blockquote><ol><li>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。</li><li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li><li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li><li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li><li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li></ol></blockquote><p>与多进程和多线程技术相比，<code>I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程</code>，也不必维护这些进程/线程，从而大大减小了系统的开销。</p><p>目前支持I/O多路复用的系统调用有 <code>select，pselect，poll，epoll</code>，I/O多路复用就是<code>通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</code>。<code>但select，pselect，poll，epoll本质上都是同步I/O</code>，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><h2 id="select、poll、epoll简介"><a href="#select、poll、epoll简介" class="headerlink" title="select、poll、epoll简介"></a>select、poll、epoll简介</h2><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，<code>其中epoll是Linux所特有，而select则应该是POSIX所规定</code>，一般操作系统均有实现。</p><h3 id="selsect"><a href="#selsect" class="headerlink" title="selsect"></a>selsect</h3><p><strong>基本原理</strong></p><blockquote><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p></blockquote><p><strong>基本流程，如图所示：</strong></p><p><img src="/2021/03/29/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select%E3%80%81poll%E3%80%81epoll/03.png" alt="01"></p><blockquote><ol><li>使用copy_from_user从用户空间拷贝fd_set到内核空间</li><li>注册回调函数__pollwait</li><li>遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</li><li>以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。</li><li>__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</li><li>poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</li><li>如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</li><li>把fd_set从内核空间拷贝到用户空间。</li></ol></blockquote><p>select目前几乎在所有的平台上支持，<code>其良好跨平台支持也是它的一个优点</code>。<code>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制</code>，在Linux上一般为<code>1024</code>，<code>可以通过修改宏定义甚至重新编译内核的方式提升这一限制</code>，但是这样也会造成效率的降低。</p><p><code>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理</code>。这样所带来的缺点是：</p><ol><li><strong>单个进程可监视的fd数量被限制，即能监听端口的大小有限。。</strong></li></ol><blockquote><p>单个用户的文件描述符上限<code>ulimit -n //1024</code> ，linux系统本身就有文件描述符上限和系统内存关系很大，<code>具体数目可以cat /proc/sys/fs/file-max 查看</code>。</p></blockquote><ol start="2"><li><strong>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</strong></li></ol><blockquote><p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。<code>如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询</code>，这正是epoll与kqueue做的。</p><p><strong>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p><p><strong>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></p></blockquote><ol start="3"><li><strong>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</strong></li></ol><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><strong>基本原理：</strong></p><blockquote><p>poll的实现和select非常相似，只是描述fd集合的方式不同，<code>poll使用pollfd结构而不是select的fd_set结构</code>，其他的都差不多,管理多个描述符也是进行轮询，根据描述符的状态进行处理，<strong>但是poll没有最大文件描述符数量的限制</strong>。poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><p><code>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间</code>，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p></blockquote><p><strong>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：</strong></p><blockquote><ol><li><code>大量的fd的数组被整体复制于用户态和内核地址空间之间</code>，而不管这样的复制是不是有意义。</li><li><code>poll还有一个特点是“水平触发”</code>，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li></ol></blockquote><p><strong>注意：</strong></p><blockquote><p>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，<code>同时连接的大量客户端在一时刻可能只有很少的处于就绪状态</code>，因此随着监视的描述符数量的增长，其效率也会线性下降。</p></blockquote><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><strong>基本流程，如图所示：</strong></p><p><img src="/2021/03/29/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select%E3%80%81poll%E3%80%81epoll/04.png" alt="01"></p><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本，可以理解位<code>event poll</code>。相对于select和poll来说，epoll更加灵活，没有描述符限制。<code>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次</code>。</p><p><strong>基本原理：</strong></p><blockquote><p><code>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次</code>。还有一个特点是，<code>epoll使用“事件”的就绪通知方式</code>，通过epoll_ctl注册fd，<code>一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd</code>，epoll_wait便可以收到通知。</p></blockquote><p><strong>epoll的优点：</strong></p><blockquote><ol><li><code>没有最大并发连接的限制</code>，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li><li><code>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降</code>。只有活跃可用的FD才会调用callback函数；<code>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关</code>，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li><li><code>内存拷贝</code>，利用mmap()文件映射内存加速与内核空间的消息传递；<code>即epoll使用mmap减少复制开销</code>。</li></ol></blockquote><p><strong>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</strong></p><blockquote><p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。若就绪的事件一次没有处理完要做的事件，就会一直去处理。即就会将没有处理完的事件继续放回到就绪队列之中（即那个内核中的链表）</p><p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。就绪的事件只能处理<strong>一次</strong>，若没有处理完会在下次的其它事件就绪时再进行处理。而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失。 </p></blockquote><ol><li><strong>LT模式</strong></li></ol><blockquote><p><code>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket</code>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。<code>如果你不作任何操作，内核还是会继续通知你的</code>。</p></blockquote><ol start="2"><li><strong>ET模式</strong></li></ol><blockquote><p><code>ET(edge-triggered)是高速工作方式，只支持no-block socket</code>。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。<code>但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</code>。</p><p><code>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高</code>。epoll工作在ET模式的时候，<code>必须使用非阻塞套接口</code>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p></blockquote><ol start="3"><li>在select/poll中，<code>进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描</code>，而epoll事先通过epoll_ctl()来注册一个文件描述符，<code>一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制</code>，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。</code>)</li></ol><p><strong>注意：</strong></p><blockquote><p>如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll。</p></blockquote><p><strong>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</strong></p><blockquote><ol><li>表面上看epoll的性能最好，<code>但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好</code>，毕竟epoll的通知机制需要很多函数回调。</li><li><code>select低效是因为每次它都需要轮询</code>。但低效也是相对的，视情况而定，也可通过良好的设计改善。</li></ol></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>select</strong></p><blockquote><ul><li>单进程可以打开fd有限制，1024；</li><li>对socket进行扫描时是线性扫描，时间复杂度:O(n)，即采用轮询的方法，效率较低；</li><li>用户空间和内核空间的复制非常消耗资源；</li></ul></blockquote><p><strong>poll</strong></p><blockquote><ul><li>调用过程和select类似，时间复杂度:O(n)</li><li>其和select不同的地方：采用<strong>链表</strong>的方式替换原有fd_set数据结构,而使其<strong>没有连接数的限制</strong>。</li></ul></blockquote><p><strong>epoll</strong></p><blockquote><ul><li><strong>LT</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。 </li><li><strong>ET</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。 </li><li>ET模式的效率比LT模式的效率要高很多。只是如果使用ET模式，就要保证每次进行数据处理时，要将其处理完，不能造成数据丢失。</li><li>ET模式只支持非阻塞的读写：为了保证数据的完整性。</li></ul></blockquote><h2 id="epoll实现多路复用"><a href="#epoll实现多路复用" class="headerlink" title="epoll实现多路复用"></a>epoll实现多路复用</h2><p>由于epoll的实现机制与select/poll机制完全不同，上面所说的 select的缺点在epoll上不复存在。</p><p>设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p><p>在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p><p>epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先的select/poll调用分成了3个部分：</p><blockquote><ul><li>调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</li><li>调用epoll_ctl向epoll对象中添加这100万个连接的套接字</li><li>调用epoll_wait收集发生的事件的连接</li></ul></blockquote><p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</p><p><strong>下面来看看Linux内核具体的epoll机制实现思路。</strong><br>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>&#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</p><p>而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p><p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span><span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllink</span>;</span><span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span>  <span class="comment">//事件句柄信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>    <span class="comment">//指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。<br><img src="/2021/03/29/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select%E3%80%81poll%E3%80%81epoll/05.png" alt="01"></p><p>从上面的可知：通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。一句话描述就是：三步曲。</p><blockquote><p>第一步：epoll_create()系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。</p><p>第二步：epoll_ctl()系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。</p><p>第三部：epoll_wait()系统调用。通过此调用收集收集在epoll监控中已经发生的事件。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a simple echo server using epoll in linux  </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 500  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> fd;  </span><br><span class="line">    <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg);  </span><br><span class="line">    <span class="keyword">int</span> events;  </span><br><span class="line">    <span class="keyword">void</span> *arg;  </span><br><span class="line">    <span class="keyword">int</span> status; <span class="comment">// 1: in epoll wait list, 0 not in  </span></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">128</span>]; <span class="comment">// recv data buffer  </span></span><br><span class="line">    <span class="keyword">int</span> len, s_offset;  </span><br><span class="line">    <span class="keyword">long</span> last_active; <span class="comment">// last active time  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// set event  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventSet</span><span class="params">(myevent_s *ev, <span class="keyword">int</span> fd, <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span>*), <span class="keyword">void</span> *arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    ev-&gt;fd = fd;  </span><br><span class="line">    ev-&gt;call_back = call_back;  </span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;  </span><br><span class="line">    ev-&gt;arg = arg;  </span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    bzero(ev-&gt;buff, <span class="keyword">sizeof</span>(ev-&gt;buff));</span><br><span class="line">    ev-&gt;s_offset = <span class="number">0</span>;  </span><br><span class="line">    ev-&gt;len = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;last_active = time(<span class="literal">NULL</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// add/mod an event to epoll  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventAdd</span><span class="params">(<span class="keyword">int</span> epollFd, <span class="keyword">int</span> events, myevent_s *ev)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;  </span><br><span class="line">    <span class="keyword">int</span> op;  </span><br><span class="line">    epv.data.ptr = ev;  </span><br><span class="line">    epv.events = ev-&gt;events = events;  </span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status == <span class="number">1</span>)&#123;  </span><br><span class="line">        op = EPOLL_CTL_MOD;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>&#123;  </span><br><span class="line">        op = EPOLL_CTL_ADD;  </span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(epoll_ctl(epollFd, op, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Event Add failed[fd=%d], evnets[%d]\n&quot;</span>, ev-&gt;fd, events);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Event Add OK[fd=%d], op=%d, evnets[%0X]\n&quot;</span>, ev-&gt;fd, op, events);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// delete an event from epoll  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventDel</span><span class="params">(<span class="keyword">int</span> epollFd, myevent_s *ev)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epv</span> =</span> &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;  </span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;status != <span class="number">1</span>) <span class="keyword">return</span>;  </span><br><span class="line">    epv.data.ptr = ev;  </span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    epoll_ctl(epollFd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">int</span> g_epollFd;  </span><br><span class="line">myevent_s g_Events[MAX_EVENTS+<span class="number">1</span>]; <span class="comment">// g_Events[MAX_EVENTS] is used by listen fd  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecvData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;  </span><br><span class="line"><span class="comment">// accept new connections from clients  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AcceptConn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>  </span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct sockaddr_in);  </span><br><span class="line">    <span class="keyword">int</span> nfd, i;  </span><br><span class="line">    <span class="comment">// accept  </span></span><br><span class="line">    <span class="keyword">if</span>((nfd = accept(fd, (struct sockaddr*)&amp;<span class="built_in">sin</span>, &amp;len)) == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EINTR)  </span><br><span class="line">        &#123;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: accept, %d&quot;</span>, __func__, errno);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_EVENTS; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(g_Events[i].status == <span class="number">0</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(i == MAX_EVENTS)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s:max connection limit[%d].&quot;</span>, __func__, MAX_EVENTS);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// set nonblocking</span></span><br><span class="line">        <span class="keyword">int</span> iret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((iret = fcntl(nfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: fcntl nonblocking failed:%d&quot;</span>, __func__, iret);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add a read event for receive data  </span></span><br><span class="line">        EventSet(&amp;g_Events[i], nfd, RecvData, &amp;g_Events[i]);  </span><br><span class="line">        EventAdd(g_epollFd, EPOLLIN, &amp;g_Events[i]);  </span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new conn[%s:%d][time:%d], pos[%d]\n&quot;</span>, inet_ntoa(<span class="built_in">sin</span>.sin_addr),</span><br><span class="line">            ntohs(<span class="built_in">sin</span>.sin_port), g_Events[i].last_active, i);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// receive data  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecvData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (struct myevent_s*)arg;  </span><br><span class="line">    <span class="keyword">int</span> len;  </span><br><span class="line">    <span class="comment">// receive data</span></span><br><span class="line">    len = recv(fd, ev-&gt;buff+ev-&gt;len, <span class="keyword">sizeof</span>(ev-&gt;buff)<span class="number">-1</span>-ev-&gt;len, <span class="number">0</span>);    </span><br><span class="line">    EventDel(g_epollFd, ev);</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev-&gt;len += len;</span><br><span class="line">        ev-&gt;buff[len] = <span class="string">&#x27;\0&#x27;</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C[%d]:%s\n&quot;</span>, fd, ev-&gt;buff);  </span><br><span class="line">        <span class="comment">// change to send event  </span></span><br><span class="line">        EventSet(ev, fd, SendData, ev);  </span><br><span class="line">        EventAdd(g_epollFd, EPOLLOUT, ev);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        close(ev-&gt;fd);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d] pos[%d], closed gracefully.\n&quot;</span>, fd, ev-g_Events);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        close(ev-&gt;fd);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv[fd=%d] error[%d]:%s\n&quot;</span>, fd, errno, strerror(errno));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// send data  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> =</span> (struct myevent_s*)arg;  </span><br><span class="line">    <span class="keyword">int</span> len;  </span><br><span class="line">    <span class="comment">// send data  </span></span><br><span class="line">    len = send(fd, ev-&gt;buff + ev-&gt;s_offset, ev-&gt;len - ev-&gt;s_offset, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d], [%d&lt;-&gt;%d]%s\n&quot;</span>, fd, len, ev-&gt;len, ev-&gt;buff);</span><br><span class="line">        ev-&gt;s_offset += len;</span><br><span class="line">        <span class="keyword">if</span>(ev-&gt;s_offset == ev-&gt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// change to receive event</span></span><br><span class="line">            EventDel(g_epollFd, ev);  </span><br><span class="line">            EventSet(ev, fd, RecvData, ev);  </span><br><span class="line">            EventAdd(g_epollFd, EPOLLIN, ev);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        close(ev-&gt;fd);  </span><br><span class="line">        EventDel(g_epollFd, ev);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d] error[%d]\n&quot;</span>, fd, errno);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitListenSocket</span><span class="params">(<span class="keyword">int</span> epollFd, <span class="keyword">short</span> port)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> listenFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    fcntl(listenFd, F_SETFL, O_NONBLOCK); <span class="comment">// set non-blocking  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server listen fd=%d\n&quot;</span>, listenFd);  </span><br><span class="line">    EventSet(&amp;g_Events[MAX_EVENTS], listenFd, AcceptConn, &amp;g_Events[MAX_EVENTS]);  </span><br><span class="line">    <span class="comment">// add listen socket  </span></span><br><span class="line">    EventAdd(epollFd, EPOLLIN, &amp;g_Events[MAX_EVENTS]);  </span><br><span class="line">    <span class="comment">// bind &amp; listen  </span></span><br><span class="line">    sockaddr_in <span class="built_in">sin</span>;  </span><br><span class="line">    bzero(&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));  </span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;  </span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;  </span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons(port);  </span><br><span class="line">    bind(listenFd, (<span class="keyword">const</span> sockaddr*)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));  </span><br><span class="line">    listen(listenFd, <span class="number">5</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> port = <span class="number">12345</span>; <span class="comment">// default port  </span></span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">2</span>)&#123;  </span><br><span class="line">        port = atoi(argv[<span class="number">1</span>]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// create epoll  </span></span><br><span class="line">    g_epollFd = epoll_create(MAX_EVENTS);  </span><br><span class="line">    <span class="keyword">if</span>(g_epollFd &lt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;create epoll failed.%d\n&quot;</span>, g_epollFd);  </span><br><span class="line">    <span class="comment">// create &amp; bind listen socket, and add to epoll, set non-blocking  </span></span><br><span class="line">    InitListenSocket(g_epollFd, port);  </span><br><span class="line">    <span class="comment">// event loop  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span>  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server running:port[%d]\n&quot;</span>, port);  </span><br><span class="line">    <span class="keyword">int</span> checkPos = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="comment">// a simple timeout check here, every time 100, better to use a mini-heap, and add timer event  </span></span><br><span class="line">        <span class="keyword">long</span> now = time(<span class="literal">NULL</span>);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++, checkPos++) <span class="comment">// doesn&#x27;t check listen fd  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(checkPos == MAX_EVENTS) checkPos = <span class="number">0</span>; <span class="comment">// recycle  </span></span><br><span class="line">            <span class="keyword">if</span>(g_Events[checkPos].status != <span class="number">1</span>) <span class="keyword">continue</span>;  </span><br><span class="line">            <span class="keyword">long</span> duration = now - g_Events[checkPos].last_active;  </span><br><span class="line">            <span class="keyword">if</span>(duration &gt;= <span class="number">60</span>) <span class="comment">// 60s timeout  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                close(g_Events[checkPos].fd);  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d] timeout[%d--%d].\n&quot;</span>, g_Events[checkPos].fd, g_Events[checkPos].last_active, now);  </span><br><span class="line">                EventDel(g_epollFd, &amp;g_Events[checkPos]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// wait for events to happen  </span></span><br><span class="line">        <span class="keyword">int</span> fds = epoll_wait(g_epollFd, events, MAX_EVENTS, <span class="number">1000</span>);  </span><br><span class="line">        <span class="keyword">if</span>(fds &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait error, exit\n&quot;</span>);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fds; i++)&#123;  </span><br><span class="line">            myevent_s *ev = (struct myevent_s*)events[i].data.ptr;  </span><br><span class="line">            <span class="keyword">if</span>((events[i].events&amp;EPOLLIN)&amp;&amp;(ev-&gt;events&amp;EPOLLIN)) <span class="comment">// read event  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>((events[i].events&amp;EPOLLOUT)&amp;&amp;(ev-&gt;events&amp;EPOLLOUT)) <span class="comment">// write event  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// free resource  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多路复用之select、poll、epoll详解</summary>
    
    
    
    <category term="多路复用" scheme="http://example.com/categories/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
    
    <category term="I/O" scheme="http://example.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>网络IO演变发展过程和模型介绍</title>
    <link href="http://example.com/2021/03/24/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E7%BD%91%E7%BB%9CIO/"/>
    <id>http://example.com/2021/03/24/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E7%BD%91%E7%BB%9CIO/</id>
    <published>2021-03-24T06:04:11.000Z</published>
    <updated>2021-08-14T06:12:41.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络-IO-演变发展过程和模型介绍"><a href="#网络-IO-演变发展过程和模型介绍" class="headerlink" title="网络 IO 演变发展过程和模型介绍"></a>网络 IO 演变发展过程和模型介绍</h1><blockquote><p>转腾讯技术工程——<a href="https://mp.weixin.qq.com/s/EDzFOo3gcivOe_RgipkTkQ">网络 IO 演变发展过程和模型介绍</a></p></blockquote><p>在互联网中提起网络，我们都会避免不了讨论高并发、百万连接。而此处的百万连接的实现，脱离不了网络 IO 的选择，因此本文作为一篇个人学习的笔记，特此进行记录一下整个网络 IO 的发展演变过程。以及目前广泛使用的网络模型。</p><h2 id="1-网络-IO-的发展"><a href="#1-网络-IO-的发展" class="headerlink" title="1.网络 IO 的发展"></a>1.网络 IO 的发展</h2><p>在本节内容中，我们将一步一步介绍网络 IO 的演变发展过程。介绍完发展过程后，再对网络 IO 中几组容易混淆的概念进行对比、分析。</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415112127.webp"></p><h3 id="1-1-网络-IO-的各个发展阶段"><a href="#1-1-网络-IO-的各个发展阶段" class="headerlink" title="1.1 网络 IO 的各个发展阶段"></a>1.1 网络 IO 的各个发展阶段</h3><p>通常，我们在此讨论的网络 IO 一般都是针对 linux 操作系统而言。网络 IO 的发展过程是随着 linux 的内核演变而变化，因此网络 IO 大致可以分为如下几个阶段：</p><p><strong>1. 阻塞 IO(BIO)</strong><br><strong>2. 非阻塞 IO(NIO)</strong><br><strong>3. IO 多路复用第一版(select/poll)</strong><br><strong>4. IO 多路复用第二版(epoll)</strong><br><strong>5. 异步 IO(AIO)</strong></p><p>而每一个阶段，都是因为当前的网络有一些缺陷，因此又在不断改进该缺陷。这是<strong>网络 IO 一直演变过程中的本质</strong>。下面将对上述几个阶段进行介绍，并对每个阶段的网络 IO 解决了哪些问题、优点、缺点进行剖析。</p><h3 id="1-2-网络的两个阶段"><a href="#1-2-网络的两个阶段" class="headerlink" title="1.2 网络的两个阶段"></a>1.2 网络的两个阶段</h3><p>在网络中，我们通常可以将其广义上划分为以下两个阶段：</p><p><strong>第一阶段：硬件接口到内核态</strong><br><strong>第二阶段：内核态到用户态</strong></p><p>本人理解：我们通常上网，大部分数据都是通过网线传递的。因此对于两台计算机而言，要进行网络通信，其数据都是先从应用程序传递到传输层(TCP/UDP)到达内核态，然后再到网络层、数据链路层、物理层，接着数据传递到硬件网卡，最后通过网络传输介质传递到对端机器的网卡，然后再一步一步数据从网卡传递到内核态，最后再拷贝到用户态。</p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415112223.webp" style="zoom:50%;"><h3 id="1-3-阻塞-IO-和非阻塞-IO-的区别"><a href="#1-3-阻塞-IO-和非阻塞-IO-的区别" class="headerlink" title="1.3 阻塞 IO 和非阻塞 IO 的区别"></a>1.3 阻塞 IO 和非阻塞 IO 的区别</h3><p>根据 1.2 节的内容，我们可以知道，网络中的数据传输从网络传输介质到达目的机器，需要如上两个阶段。此处我们把从<strong>硬件到内核态</strong>这一阶段，是否发生阻塞等待，可以将网络分为<strong>阻塞 IO</strong>和<strong>非阻塞 IO</strong>。如果用户发起了读写请求，但内核态数据还未准备就绪，该阶段不会阻塞用户操作，内核立马返回，则称为非阻塞 IO。如果该阶段一直阻塞用户操作。直到内核态数据准备就绪，才返回。这种方式称为阻塞 IO。</p><p>因此，区分阻塞 IO 和非阻塞 IO 主要看第一阶段是否阻塞用户操作。</p><h3 id="1-4-同步-IO-和异步-IO-的区别"><a href="#1-4-同步-IO-和异步-IO-的区别" class="headerlink" title="1.4 同步 IO 和异步 IO 的区别"></a>1.4 同步 IO 和异步 IO 的区别</h3><p>从前面我们知道了，数据的传递需要两个阶段，在此处只要任何一个阶段会阻塞用户请求，都将其称为同步 IO，两个阶段都不阻塞，则称为异步 IO。</p><p>在目前所有的操作系统中，linux 中的 epoll、mac 的 kqueue 都属于同步 IO，因为其在第二阶段(数据从内核态到用户态)都会发生拷贝阻塞。而只有 windows 中的 IOCP 才真正属于异步 IO，即 AIO。</p><h2 id="2-阻塞-IO"><a href="#2-阻塞-IO" class="headerlink" title="2.阻塞 IO"></a>2.阻塞 IO</h2><p>在本节，我们将介绍最初的阻塞 IO，阻塞 IO 英文为 blocking IO，又称为 BIO。根据前面的介绍，阻塞 IO 主要指的是第一阶段(硬件网卡到内核态)。</p><h3 id="2-1-阻塞-IO-的概念"><a href="#2-1-阻塞-IO-的概念" class="headerlink" title="2.1 阻塞 IO 的概念"></a>2.1 阻塞 IO 的概念</h3><p>阻塞 IO，顾名思义当用户发生了系统调用后，如果数据未从网卡到达内核态，内核态数据未准备好，此时会一直阻塞。直到数据就绪，然后从内核态拷贝到用户态再返回。具体过程可以参考 2.2 的图示。</p><h3 id="2-2-阻塞-IO-的过程"><a href="#2-2-阻塞-IO-的过程" class="headerlink" title="2.2 阻塞 IO 的过程"></a>2.2 阻塞 IO 的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415112344.webp"></p><h3 id="2-3-阻塞-IO-的缺点"><a href="#2-3-阻塞-IO-的缺点" class="headerlink" title="2.3 阻塞 IO 的缺点"></a>2.3 阻塞 IO 的缺点</h3><p>在一般使用阻塞 IO 时，都需要配置多线程来使用，最常见的模型是<strong>阻塞 IO+多线程</strong>，每个连接一个单独的线程进行处理。</p><p><strong>我们知道，一般一个程序可以开辟的线程是有限的，而且开辟线程的开销也是比较大的。也正是这种方式，会导致一个应用程序可以处理的客户端请求受限。面对百万连接的情况，是无法处理。</strong></p><p>既然发现了问题，分析了问题，那就得解决问题。既然阻塞 IO 有问题，本质是由于其阻塞导致的，因此自然而然引出了下面即将介绍的主角：<strong>非阻塞 IO</strong></p><h2 id="3-非阻塞-IO"><a href="#3-非阻塞-IO" class="headerlink" title="3.非阻塞 IO"></a>3.非阻塞 IO</h2><p>非阻塞 IO 是为了解决前面提到的阻塞 IO 的缺陷而引出的，下面我们将介绍非阻塞 IO 的过程。</p><h3 id="3-1-非阻塞-IO-的概念"><a href="#3-1-非阻塞-IO-的概念" class="headerlink" title="3.1 非阻塞 IO 的概念"></a>3.1 非阻塞 IO 的概念</h3><p>非阻塞 IO：见名知意，就是在第一阶段(网卡-内核态)数据未到达时不等待，然后直接返回。因此非阻塞 IO 需要不断的用户发起请求，询问内核数据好了没，好了没。</p><h3 id="3-2-非阻塞-IO-的过程"><a href="#3-2-非阻塞-IO-的过程" class="headerlink" title="3.2 非阻塞 IO 的过程"></a>3.2 非阻塞 IO 的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415112435.webp"></p><p>非阻塞 IO 是需要系统内核支持的，在创建了连接后，可以调用 setsockop 设置 noblocking。</p><h3 id="3-3-非阻塞-IO-的优点"><a href="#3-3-非阻塞-IO-的优点" class="headerlink" title="3.3 非阻塞 IO 的优点"></a>3.3 非阻塞 IO 的优点</h3><p>正如前面提到的，非阻塞 IO 解决了阻塞 IO<strong>每个连接一个线程处理的问题</strong>，所以其最大的优点就是 <strong>一个线程可以处理多个连接</strong>，这也是其非阻塞决定的。</p><h3 id="3-4-非阻塞-IO-的缺点"><a href="#3-4-非阻塞-IO-的缺点" class="headerlink" title="3.4 非阻塞 IO 的缺点"></a>3.4 非阻塞 IO 的缺点</h3><p>但这种模式，也有一个问题，就是需要用户多次发起系统调用。<strong>频繁的系统调用</strong>是比较消耗系统资源的。</p><p>因此，既然存在这样的问题，那么自然而然我们就需要解决该问题：<strong>保留非阻塞 IO 的优点的前提下，减少系统调用</strong>。</p><h2 id="4-IO-多路复用第一版"><a href="#4-IO-多路复用第一版" class="headerlink" title="4.IO 多路复用第一版"></a>4.IO 多路复用第一版</h2><p>为了解决非阻塞 IO 存在的频繁的系统调用这个问题，随着内核的发展，出现了 IO 多路复用模型。那么我们就需要搞懂几个问题：</p><ol><li>IO 多路复用到底复用什么？</li><li>IO 多路复用如何复用？</li></ol><p><strong>IO 多路复用：</strong> 很多人都说，IO 多路复用是用一个线程来管理多个网络连接，但本人不太认可，因为在非阻塞 IO 时，就已经可以实现一个线程处理多个网络连接了，这个是由于其非阻塞而决定的。</p><p><strong>在此处，个人观点，多路复用主要复用的是通过有限次的系统调用来实现管理多个网络连接。最简单来说，我目前有 10 个连接，我可以通过一次系统调用将这 10 个连接都丢给内核，让内核告诉我，哪些连接上面数据准备好了，然后我再去读取每个就绪的连接上的数据。因此，IO 多路复用，复用的是系统调用。通过有限次系统调用判断海量连接是否数据准备好了</strong>。</p><p><strong>无论下面的 select、poll、epoll，其都是这种思想实现的，不过在实现上，select/poll 可以看做是第一版，而 epoll 是第二版</strong>。</p><h3 id="4-1-IO-多路复用第一版的概念"><a href="#4-1-IO-多路复用第一版的概念" class="headerlink" title="4.1 IO 多路复用第一版的概念"></a>4.1 IO 多路复用第一版的概念</h3><p><strong>IO 多路复用第一版，这个概念是本人想出来的，主要是方便将 select/poll 和 epoll 进行区分</strong>。</p><p>所以此处 IO 多路复用第一版，主要特指 select 和 poll 这两个。</p><h4 id="select-的-api"><a href="#select-的-api" class="headerlink" title="select 的 api"></a>select 的 api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readfds:关心读的fd集合；writefds：关心写的fd集合；excepttfds：异常的fd集合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>select 函数监视的文件描述符分 3 类，分别是 writefds、readfds、和 exceptfds。调用后 select 函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 select 函数返回后，可以 通过遍历 fdset，来找到就绪的描述符。</p><p>select 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select 的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p><h4 id="poll-的-api"><a href="#poll-的-api" class="headerlink" title="poll 的 api"></a>poll 的 api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pollfd 结构包含了要监视的 event 和发生的 event，不再使用 select“参数-值”传递的方式。同时，pollfd 并没有最大数量限制（但是数量过大后性能也是会下降）。和 select 函数一样，poll 返回后，需要轮询 pollfd 来获取就绪的描述符。</p><p>从上面看，select 和 poll 都需要在返回后，通过遍历文件描述符来获取已经就绪的 socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p><p><strong>从本质来说：IO 多路复用中，select()/poll()/epoll_wait()这几个函数对应第一阶段；read()/recvfrom()对应第二阶段</strong>。</p><h3 id="4-2-IO-多路复用第一版的过程"><a href="#4-2-IO-多路复用第一版的过程" class="headerlink" title="4.2 IO 多路复用第一版的过程"></a>4.2 IO 多路复用第一版的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415112735.webp"></p><h3 id="4-3-IO-多路复用第一版的优点"><a href="#4-3-IO-多路复用第一版的优点" class="headerlink" title="4.3 IO 多路复用第一版的优点"></a>4.3 IO 多路复用第一版的优点</h3><p><strong>IO 多路复用，主要在于复用，通过 select()或者 poll()将多个 socket fds 批量通过系统调用传递给内核，由内核进行循环遍历判断哪些 fd 上数据就绪了，然后将就绪的 readyfds 返回给用户。再由用户进行挨个遍历就绪好的 fd，读取或者写入数据。</strong></p><p><strong>所以通过 IO 多路复用+非阻塞 IO，一方面降低了系统调用次数，另一方面可以用极少的线程来处理多个网络连接。</strong></p><h3 id="4-4-IO-多路复用第一版的缺点"><a href="#4-4-IO-多路复用第一版的缺点" class="headerlink" title="4.4 IO 多路复用第一版的缺点"></a>4.4 IO 多路复用第一版的缺点</h3><p>虽然第一版 IO 多路复用解决了之前提到的频繁的系统调用次数，但同时引入了新的问题：<strong>用户需要每次将海量的 socket fds 集合从用户态传递到内核态，让内核态去检测哪些网络连接数据就绪了</strong></p><p><strong>但这个地方会出现频繁的将海量 fd 集合从用户态传递到内核态，再从内核态拷贝到用户态。所以，这个地方开销也挺大。</strong></p><p>既然还有这个问题，那我们继续开始解决这个问题，因此就引出了第二版的 IO 多路复用。</p><p><strong>其实思路也挺简单，既然需要拷贝，那就想办法，不拷贝。既然不拷贝，那就在内核开辟一段区域咯</strong></p><h3 id="4-5-IO-多路复用第一版的区别"><a href="#4-5-IO-多路复用第一版的区别" class="headerlink" title="4.5 IO 多路复用第一版的区别"></a>4.5 IO 多路复用第一版的区别</h3><p><strong>select 和 poll 的区别</strong></p><ol><li>select 能处理的最大连接，默认是 1024 个，可以通过修改配置来改变，但终究是有限个；而 poll 理论上可以支持无限个</li><li>select 和 poll 在管理海量的连接时，会频繁的从用户态拷贝到内核态，比较消耗资源。</li></ol><h2 id="5-IO-多路复用第二版"><a href="#5-IO-多路复用第二版" class="headerlink" title="5. IO 多路复用第二版"></a>5. IO 多路复用第二版</h2><p>IO 多路复用第二版主要指 epoll，epoll 的出现也是随着内核版本迭代才诞生的，在网上到处看到，epoll 是内核 2.6 以后开始支持的</p><p><strong>epoll 的出现是为了解决前面提到的 IO 多路复用第一版的问题</strong>。</p><h3 id="5-1-IO-多路复用第二版的概念"><a href="#5-1-IO-多路复用第二版的概念" class="headerlink" title="5.1 IO 多路复用第二版的概念"></a>5.1 IO 多路复用第二版的概念</h3><h4 id="epoll-提供的-api"><a href="#epoll-提供的-api" class="headerlink" title="epoll 提供的 api"></a>epoll 提供的 api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建epollFd，底层是在内核态分配一段区域，底层数据结构红黑树+双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span>；<span class="comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//往红黑树中增加、删除、更新管理的socket fd</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//这个api是用来在第一阶段阻塞，等待就绪的fd。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+<span class="number">1</span>的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</span><br><span class="line">当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span>；</span></span><br><span class="line"><span class="function">函数是对指定描述符fd执行op操作。</span></span><br><span class="line"><span class="function">- epfd：是<span class="title">epoll_create</span><span class="params">()</span>的返回值。</span></span><br><span class="line"><span class="function">- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</span></span><br><span class="line"><span class="function">- fd：是需要监听的fd（文件描述符）</span></span><br><span class="line"><span class="function">- epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct epoll_event </span>&#123;</span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">等待epfd上的io事件，最多返回maxevents个事件。</span><br><span class="line">参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，<span class="number">0</span>会立即返回，<span class="number">-1</span>将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回<span class="number">0</span>表示已超时。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p>epoll 对文件描述符的操作有两种模式：LT（level trigger）和 ET（edge trigger）。LT 模式是默认模式，LT 模式与 ET 模式的区别如下：</p><ul><li>LT 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。</li><li>ET 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。</li></ul><ol><li><p>LT 模式</p><p>LT(level triggered)是缺省的工作方式，并且同时支持 block 和 no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。</p></li><li><p>ET 模式</p><p>ET(edge-triggered)是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个 EWOULDBLOCK 错误）。但是请注意，如果一直不对这个 fd 作 IO 操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p><p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p></li></ol><h3 id="5-2-IO-多路复用第二版的过程"><a href="#5-2-IO-多路复用第二版的过程" class="headerlink" title="5.2 IO 多路复用第二版的过程"></a>5.2 IO 多路复用第二版的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415113121.webp"></p><p>当 epoll_wait()调用后会阻塞，然后完了当返回时，会返回了哪些 fd 的数据就绪了，用户只需要遍历就绪的 fd 进行读写即可。</p><h3 id="5-3-IO-多路复用第二版的优点"><a href="#5-3-IO-多路复用第二版的优点" class="headerlink" title="5.3 IO 多路复用第二版的优点"></a>5.3 IO 多路复用第二版的优点</h3><p><strong>IO 多路复用第二版 epoll 的优点在于：</strong></p><p>一开始就在内核态分配了一段空间，来存放管理的 fd,所以在每次连接建立后，交给 epoll 管理时，需要将其添加到原先分配的空间中，后面再管理时就不需要频繁的从用户态拷贝管理的 fd 集合。通通过这种方式大大的提升了性能。</p><p>所以现在的 IO 多路复用主要指 epoll。</p><h3 id="5-4-IO-多路复用第二版的缺点"><a href="#5-4-IO-多路复用第二版的缺点" class="headerlink" title="5.4 IO 多路复用第二版的缺点"></a>5.4 IO 多路复用第二版的缺点</h3><p><strong>个人猜想：</strong> 如何降低占用的空间。</p><h2 id="6-异步-IO"><a href="#6-异步-IO" class="headerlink" title="6.异步 IO"></a>6.异步 IO</h2><h3 id="6-1-异步-IO-的过程"><a href="#6-1-异步-IO-的过程" class="headerlink" title="6.1 异步 IO 的过程"></a>6.1 异步 IO 的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415113223.webp"></p><p>前面介绍的所有网络 IO 都是同步 IO，因为当数据在内核态<strong>就绪</strong>时，在内核态拷贝用用户态的过程中，仍然会有短暂时间的阻塞等待。而异步 IO 指：<strong>内核态拷贝数据到用户态这种方式也是交给系统线程来实现，不由用户线程完成</strong>，目前只有 windows 系统的 IOCP 是属于异步 IO。</p><p><strong>区分同步异步IO的准则就是判断是就绪还是完成，就绪就是同步，完成就是异步</strong></p><h2 id="7-网络-IO-各种模型"><a href="#7-网络-IO-各种模型" class="headerlink" title="7.网络 IO 各种模型"></a>7.网络 IO 各种模型</h2><h3 id="7-1-reactor-模型"><a href="#7-1-reactor-模型" class="headerlink" title="7.1 reactor 模型"></a>7.1 reactor 模型</h3><p>目前 reactor 模型有以下几种实现方案：</p><p><strong>1. 单 reactor 单线程模型</strong><br><strong>2. 单 reactor 多线程模型</strong><br><strong>3. multi-reactor 多线程模型</strong><br><strong>4. multi-reactor 多进程模型</strong></p><h4 id="单-reactor-单线程模型"><a href="#单-reactor-单线程模型" class="headerlink" title="单 reactor 单线程模型"></a>单 reactor 单线程模型</h4><p>此种模型，通常是只有一个 epoll 对象，所有的<strong>接收客户端连接</strong>、<strong>客户端读取</strong>、<strong>客户端写入</strong>操作都包含在一个线程内。该种模型也有一些中间件在用，比如 redis。</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415113326.webp"></p><p>但在目前的单线程 Reactor 模式中，不仅 I/O 操作在该 Reactor 线程上，连非 I/O 的业务操作也在该线程上进行处理了，这可能会大大延迟 I/O 请求的响应。所以我们应该将非 I/O 的业务逻辑操作从 Reactor 线程上卸载，以此来加速 Reactor 线程对 I/O 请求的响应。</p><h4 id="单-reactor-多线程模型"><a href="#单-reactor-多线程模型" class="headerlink" title="单 reactor 多线程模型"></a>单 reactor 多线程模型</h4><p>该模型主要是通过将，前面的模型进行改造，将读写的业务逻辑交给具体的线程池来实现，这样可以显示 reactor 线程对 IO 的响应，以此提升系统性能。</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415113406.webp"></p><p>在工作者线程池模式中，虽然非 I/O 操作交给了线程池来处理，但是所有的 I/O 操作依然由 Reactor 单线程执行，在高负载、高并发或大数据量的应用场景，依然较容易成为瓶颈。所以，对于 Reactor 的优化，又产生出下面的多线程模式。</p><h4 id="multi-reactor-多线程模型"><a href="#multi-reactor-多线程模型" class="headerlink" title="multi-reactor 多线程模型"></a>multi-reactor 多线程模型</h4><p>在这种模型中，主要分为两个部分：mainReactor、subReactors。mainReactor 主要负责接收客户端的连接，然后将建立的客户端连接通过负载均衡的方式分发给 subReactors，subReactors 来负责具体的每个连接的读写。对于非 IO 的操作，依然交给工作线程池去做，对逻辑进行解耦。</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415113459.webp"></p><p>mainReactor 对应 Netty 中配置的 BossGroup 线程组，主要负责接受客户端连接的建立。一般只暴露一个服务端口，BossGroup 线程组一般一个线程工作即可 subReactor 对应 Netty 中配置的 WorkerGroup 线程组，BossGroup 线程组接受并建立完客户端的连接后，将网络 socket 转交给 WorkerGroup 线程组，然后在 WorkerGroup 线程组内选择一个线程，进行 I/O 的处理。WorkerGroup 线程组主要处理 I/O，一般设置 2*CPU 核数个线程。</p><h3 id="7-2-proactor-模型"><a href="#7-2-proactor-模型" class="headerlink" title="7.2 proactor 模型"></a>7.2 proactor 模型</h3><p>proactor 主要是通过对异步 IO 的封装的一种模型，它需要底层操作系统的支持，目前只有 windows 的 IOCP 支持的比较好。详细的介绍可以参考<a href="https://zhuanlan.zhihu.com/p/95662364">高性能IO模型分析-Reactor模式和Proactor模式（二）</a>。</p><h3 id="7-3-主流的中间件所采用的网络模型"><a href="#7-3-主流的中间件所采用的网络模型" class="headerlink" title="7.3 主流的中间件所采用的网络模型"></a>7.3 主流的中间件所采用的网络模型</h3><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415113546.webp"></p><h3 id="7-4-主流网络框架"><a href="#7-4-主流网络框架" class="headerlink" title="7.4 主流网络框架"></a>7.4 主流网络框架</h3><ul><li>netty</li><li>gnet</li><li>libevent</li><li>evio(golang)</li><li>ACE(c++)</li><li>boost::asio(c++)</li><li>muduo （linux only)</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://juejin.im/post/5bf7b89e518825369c564059">IO 模式和 IO 多路复用</a></li><li><a href="https://segmentfault.com/a/1190000003063859">Linux IO 模式及 select、poll、epoll 详解</a></li><li><a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06.html">Chapter 6. I/O Multiplexing: The select and poll Functions</a></li><li><a href="https://zhuanlan.zhihu.com/p/95662364">高性能 IO 模型分析-Reactor 模式和 Proactor 模式（二）</a></li></ol>]]></content>
    
    
    <summary type="html">多路复用——网络 IO 演变发展过程和模型介绍</summary>
    
    
    
    <category term="多路复用" scheme="http://example.com/categories/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
    
    <category term="I/O" scheme="http://example.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>shell</title>
    <link href="http://example.com/2021/03/15/shell/"/>
    <id>http://example.com/2021/03/15/shell/</id>
    <published>2021-03-15T07:45:40.000Z</published>
    <updated>2021-09-15T08:17:53.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nc-01统计文件的行数"><a href="#nc-01统计文件的行数" class="headerlink" title="nc_01统计文件的行数"></a>nc_01统计文件的行数</h2><p>写一个 bash脚本以输出一个文本文件 nowcoder.txt中的行数<br>示例:<br>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 100;</span><br><span class="line">    cout &lt;&lt; &quot;a + b:&quot; &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你的脚本应当输出：<br>9</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat nowcoder.txt | wc -l</span><br><span class="line"></span><br><span class="line">wc -l nowcoder.txt | awk &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line"></span><br><span class="line">awk &#x27;&#123;print NR&#125;&#x27; nowcoder.txt | tail -n1</span><br><span class="line"></span><br><span class="line">awk &#x27;END&#123;print NR&#125;&#x27; nowcoder.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">sed 统计行</span></span><br><span class="line">sed -n &#x27;$=&#x27; nowcoder.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">使用 grep 搜索 <span class="string">&quot;&quot;</span>，然后利用 grep 自带的功能统计行</span></span><br><span class="line">grep -c &quot;&quot; nowcoder.txt</span><br><span class="line"></span><br><span class="line">grep -n &quot;&quot; nowcoder.txt  | awk -F &quot;:&quot; &#x27;&#123;print $1 &#125;&#x27; | tail -n 1</span><br></pre></td></tr></table></figure><h2 id="nc-02打印文件的最后5行"><a href="#nc-02打印文件的最后5行" class="headerlink" title="nc_02打印文件的最后5行"></a>nc_02打印文件的最后5行</h2><p>经常查看日志的时候，会从文件的末尾往前查看，于是请你写一个 bash脚本以输出一个文本文件 nowcoder.txt中的最后5行<br>示例:<br>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 100;</span><br><span class="line">cout &lt;&lt; &quot;a + b:&quot; &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你的脚本应当输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 100;</span><br><span class="line">cout &lt;&lt; &quot;a + b:&quot; &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -n5 nowcoder.txt</span><br><span class="line"></span><br><span class="line">awk &#x27;NR&gt;=4&#123;print $0&#125;&#x27; nowcoder.txt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NR ||　NF</span><br><span class="line">NR代表的是这个文本文件的行数（记录数）</span><br><span class="line">NF代表的是一个文本文件中一行（一条记录）中的字段个数/列数</span><br><span class="line">September 2003               # NR=1;NF=2</span><br><span class="line">Su Mo Tu We Th Fr Sa         # NR=2;NF=7</span><br><span class="line">    1  2  3  4  5  6         # NR=3;NF=6</span><br><span class="line">07 08 09 10 11 12 13         # NR=4;NF=7</span><br><span class="line">14 15 16 17 18 19 20         # NR=5;NF=7</span><br><span class="line">21 22 23 24 25 26 27         # NR=6;NF=7</span><br><span class="line">28 29 30                     # NR=7;NF=3</span><br></pre></td></tr></table></figure><h2 id="nc-03输出7的倍数"><a href="#nc-03输出7的倍数" class="headerlink" title="nc_03输出7的倍数"></a>nc_03输出7的倍数</h2><p>写一个 bash脚本以输出数字 0 到 500 中 7 的倍数(0 7 14 21…)的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for num in &#123;0..500..7&#125;; do</span><br><span class="line">  echo &quot;$&#123;num&#125;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># seq 用于生成从一个数到另一个数之间的所有整数。</span><br><span class="line"># 用法：seq [选项]... 尾数</span><br><span class="line"># 或：seq [选项]... 首数 尾数</span><br><span class="line"># 或：seq [选项]... 首数 增量 尾数</span><br><span class="line">seq 0 7 500</span><br></pre></td></tr></table></figure><h2 id="nc-04输出第五行内容"><a href="#nc-04输出第五行内容" class="headerlink" title="nc_04输出第五行内容"></a>nc_04输出第五行内容</h2><p>写一个 bash脚本以输出一个文本文件 nowcoder.txt 中第5行的内容</p><p>示例:<br>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">welcome</span><br><span class="line">to</span><br><span class="line">nowcoder</span><br><span class="line">this</span><br><span class="line">is</span><br><span class="line">shell</span><br><span class="line">code</span><br></pre></td></tr></table></figure><p>你的脚本应当输出：<br>is</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> p 打印 通常 p 会与参数 sed -n 一起运行～</span></span><br><span class="line">sed -n &#x27;5p&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">head n 5 nowcoder.txt | tail -n 1</span><br><span class="line"></span><br><span class="line">awk &#x27;NR==5&#123;print $0&#125;&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">awk &#x27;&#123;if(NR==5)&#123;print $0&#125;&#125;&#x27; nowcoder.txt</span><br></pre></td></tr></table></figure><h2 id="nc-05打印空行的行号"><a href="#nc-05打印空行的行号" class="headerlink" title="nc_05打印空行的行号"></a>nc_05打印空行的行号</h2><p>写一个 bash脚本以输出一个文本文件 nowcoder.txt中空行的行号,可能连续,从1开始</p><p>示例:<br>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">d</span><br><span class="line"></span><br><span class="line">e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f</span><br></pre></td></tr></table></figure><p>你的脚本应当输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">^：开始</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">：结尾</span></span><br><span class="line"></span><br><span class="line">^$：表示空行</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">awk &#x27;/^$/ &#123;print NR&#125;&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">awk &#x27;&#123;if($0 == &quot;&quot;) &#123;print NR&#125;&#125;&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">awk &#x27;&#123;if (NF==0) print NR&#125;&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">sed -n &#x27;/^$/=&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">grep -n &#x27;^$&#x27; nowcoder.txt | awk -F: &#x27;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="nc-06去掉空行"><a href="#nc-06去掉空行" class="headerlink" title="nc_06去掉空行"></a>nc_06去掉空行</h2><p>写一个 bash脚本以去掉一个文本文件 nowcoder.txt中的空行<br>示例:<br>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line"></span><br><span class="line">567</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ccc</span><br></pre></td></tr></table></figure><p>你的脚本应当输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">567</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -v 显示不包含匹配文本的所有行</span></span><br><span class="line">grep -v &#x27;^$&#x27; nowcoder.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> -e 指定字符串做为查找文件内容的样式</span></span><br><span class="line">grep -e &#x27;\S&#x27;</span><br><span class="line"></span><br><span class="line">awk &#x27;&#123;if($0!=&quot;&quot;) &#123;print $0 &#125;&#125;&#x27; nowcoder.txt</span><br><span class="line">awk &#x27;!/^$/ &#123;print $NF&#125;&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat 输出文本内容，然后通过管道符交由 awk 做非空校验然后输出</span></span><br><span class="line">cat nowcoder.txt | awk NF</span><br><span class="line"></span><br><span class="line">sed &#x27;/^$/d&#x27; nowcoder.txt</span><br></pre></td></tr></table></figure><h2 id="nc-07打印字母数小于8的单词"><a href="#nc-07打印字母数小于8的单词" class="headerlink" title="nc_07打印字母数小于8的单词"></a>nc_07打印字母数小于8的单词</h2><p>写一个 bash脚本以统计一个文本文件 nowcoder.txt中字母数小于8的单词。</p><p>示例:假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">how they are implemented and applied in computer </span><br></pre></td></tr></table></figure><p>你的脚本应当输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">how</span><br><span class="line">they</span><br><span class="line">are</span><br><span class="line">and</span><br><span class="line">applied</span><br><span class="line">in</span><br></pre></td></tr></table></figure><p>说明:不要担心你输出的空格以及换行的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat nowcoder.txt | awk &#x27;&#123;</span><br><span class="line">for (i=1;i&lt;=NF;i++)&#123;</span><br><span class="line">        if (length($i) &lt; 8)</span><br><span class="line">                print $i</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="nc-08统计所有进程占用内存大小的和"><a href="#nc-08统计所有进程占用内存大小的和" class="headerlink" title="nc_08统计所有进程占用内存大小的和"></a>nc_08统计所有进程占用内存大小的和</h2><p>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root         2  0.0  0.0      0     0 ?        S    9月25   0:00 [kthreadd]</span><br><span class="line">root         4  0.0  0.0      0     0 ?        I&lt;   9月25   0:00 [kworker/0:0H]</span><br><span class="line">web       1638  1.8  1.8 6311352 612400 ?      Sl   10月16  21:52 test</span><br><span class="line">web       1639  2.0  1.8 6311352 612401 ?      Sl   10月16  21:52 test</span><br><span class="line">tangmiao-pc       5336   0.0  1.4  9100240 238544   ??  S     3:09下午   0:31.70 /Applications</span><br></pre></td></tr></table></figure><p>上内容是通过<code>ps aux | grep -v &#39;RSS TTY&#39; </code>命令输出到<code>nowcoder.txt</code>文件下面的<br>请你写一个脚本计算一下所有进程占用内存大小的和:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;a+=$6&#125;END&#123;print a&#125;&#x27;</span><br><span class="line">对第一列数字求和： awk &#x27;&#123;a+=$1&#125;END&#123;print a&#125;&#x27;</span><br><span class="line">对第二列数字求和： awk &#x27;&#123;a+=$2&#125;END&#123;print a&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="nc-09统计每个单词出现的次数"><a href="#nc-09统计每个单词出现的次数" class="headerlink" title="nc_09统计每个单词出现的次数"></a>nc_09统计每个单词出现的次数</h2><p>写一个 bash脚本以统计一个文本文件 nowcoder.txt 中每个单词出现的个数。</p><p>为了简单起见，你可以假设：<br>nowcoder.txt只包括小写字母和空格。<br>每个单词只由小写字母组成。<br>单词间由一个或多个空格字符分隔。</p><p>示例:<br>假设 nowcoder.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">welcome nowcoder</span><br><span class="line">welcome to nowcoder</span><br><span class="line">nowcoder</span><br></pre></td></tr></table></figure><p>你的脚本应当输出（以词频升序排列）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">to 1 </span><br><span class="line">welcome 2 </span><br><span class="line">nowcoder 3 </span><br></pre></td></tr></table></figure><p>说明:<br>不要担心个数相同的单词的排序问题，每个单词出现的个数都是唯一的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat nowcoder.txt | xargs -n1 | sort | uniq -c | sort -n | awk &#x27;&#123;print $2,$1&#125;&#x27;</span><br></pre></td></tr></table></figure><p>对于nowcoder.txt文件进行词频统计，首先要做的事情就是把nowcoder.txt文件当中的每一个单词分割出来，分割出每一个单词可以使用以下两种方式：</p><p><strong>使用awk命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;for(i=1;i&lt;=NF;i++)&#123;print $i&#125;&#125;&#x27; nowcoder.txt </span><br><span class="line">其中NF表示当前记录的字段数（即列数）</span><br><span class="line"><span class="meta">$</span><span class="bash">i 文件中每行以间隔符号分割的不同字段</span></span><br><span class="line">如果对awk命令不熟悉，可以参考之前分享的一篇文章学习：</span><br><span class="line">号称三剑客之首的awk，开始秀！</span><br></pre></td></tr></table></figure><p><strong>使用xargs命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat nowcoder.txt | xargs -n1</span><br><span class="line">xargs命令是用于给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。</span><br><span class="line">-n1，指定 输出时每行输出的 1列</span><br><span class="line">welcome</span><br><span class="line">nowcoder</span><br><span class="line">welcome</span><br><span class="line">to</span><br><span class="line">nowcoder</span><br><span class="line">nowcoder</span><br><span class="line"></span><br><span class="line">-n2，指定 输出时每行输出的 2列</span><br><span class="line">welcome nowcoder</span><br><span class="line">welcome to</span><br><span class="line">nowcoder nowcoder</span><br></pre></td></tr></table></figure><p>可以在xargs的基础之上使用一些shell小工具来得到每个单词出现的次数。sort 工具及 uniq 工具，这里仅介绍解决问题使用的参数，关于小工具（grep、cut、sort、uniq、tee、diff、past、tr）可以参考文章：<a href="https://mp.weixin.qq.com/s/7pfE3S-uDSLOG1AZSj3D1A">Shell编程之文本处理工具与bash的特性</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sort工具用于排序，它将文件的每一行作为一个单位，从首字母向后按照ASCII码值进行比较，默认将他们升序输出。</span><br><span class="line">nowcoder</span><br><span class="line">nowcoder</span><br><span class="line">nowcoder</span><br><span class="line">to</span><br><span class="line">welcome</span><br><span class="line">welcome</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uniq用去取出连续的重复行</span><br><span class="line"></span><br><span class="line">-c ：统计重复行的次数</span><br><span class="line">     3 nowcoder</span><br><span class="line">     1 to</span><br><span class="line">     2 welcome</span><br><span class="line"></span><br><span class="line">-r : 降序排列</span><br><span class="line"></span><br><span class="line">-n : 以数字排序，默认是按照字符排序的。</span><br><span class="line">      1 to</span><br><span class="line">      2 welcome</span><br><span class="line">      3 nowcoder</span><br><span class="line"></span><br><span class="line">最后我们仅需要对上面的结果进行排序啦，很简单的使用sort就可以啦！</span><br></pre></td></tr></table></figure><h2 id="nc-10第二列是否有重复"><a href="#nc-10第二列是否有重复" class="headerlink" title="nc_10第二列是否有重复"></a>nc_10第二列是否有重复</h2><p>给定一个 <code>nowcoder.txt</code>文件，其中有3列信息，如下实例，编写一个<code>shell</code>脚本来检查文件第二列是否有重复，且有几个重复，并提取出重复的行的第二列信息：<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">20201001 python 99</span><br><span class="line">20201002 go 80</span><br><span class="line">20201002 c++ 88</span><br><span class="line">20201003 php 77</span><br><span class="line">20201001 go 88</span><br><span class="line">20201005 shell 89</span><br><span class="line">20201006 java 70</span><br><span class="line">20201008 c 100</span><br><span class="line">20201007 java 88</span><br><span class="line">20201006 go 97</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 java</span><br><span class="line">3 go</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $2&#125;&#x27; nowcoder.txt | sort | uniq -cd | sort -n</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $2&#125;&#x27; nowcoder.txt</span><br><span class="line"></span><br><span class="line">python</span><br><span class="line">go</span><br><span class="line">c++</span><br><span class="line">php</span><br><span class="line">go</span><br><span class="line">shell</span><br><span class="line">java</span><br><span class="line">c</span><br><span class="line">java</span><br><span class="line">go</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $2&#125;&#x27; nowcoder.txt | sort</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line">c++</span><br><span class="line">go</span><br><span class="line">go</span><br><span class="line">go</span><br><span class="line">java</span><br><span class="line">java</span><br><span class="line">php</span><br><span class="line">python</span><br><span class="line">shell</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $2&#125;&#x27; nowcoder.txt | sort | uniq -cd</span><br><span class="line"></span><br><span class="line">3 go</span><br><span class="line">2 java</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq [-c/d/D/u/i] [-f Fields] [-s N] [-w N] [InFile] [OutFile]</span><br></pre></td></tr></table></figure><blockquote><ul><li>-c: 在每列旁边显示该行重复出现的次数。</li><li>-d: 仅显示重复出现的行列，显示一行。</li><li>-D: 显示所有重复出现的行列，有几行显示几行。</li><li>-u: 仅显示出一次的行列。</li><li>-i: 忽略大小写字符的不同。</li><li>-f Fields: 忽略比较指定的列数。</li><li>-s N: 忽略比较前面的N个字符。</li><li>-w N: 对每行第N个字符以后的内容不作比较。</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [-b/d/f/g/i/M/n/r] [InFile]</span><br></pre></td></tr></table></figure><blockquote><ul><li>-b: ignore-leading-blanks，忽略前面空格符部分</li><li>-d: data-order，仅考虑空格和字母数字字符</li><li>-f: ignore-case，忽略大小写</li><li>-g: general-numeric-sort，根据一般数值进行排序</li><li>-i: ignore-nonprinting，忽略不可打印的字符，比如换行符、回车符</li><li>-M: month-sort，以月份进行排序</li><li>-n: numeric-sort，根据字符串数值进行排序-r: reverse，反向输出排序结果</li></ul></blockquote><h2 id="nc-11转置文件中的内容"><a href="#nc-11转置文件中的内容" class="headerlink" title="nc_11转置文件中的内容"></a>nc_11转置文件中的内容</h2><p>写一个 bash脚本来转置文本文件<code>nowcoder.txt</code>中的文件内容。</p><p>为了简单起见，你可以假设：<br>你可以假设每行列数相同，并且每个字段由空格分隔</p><p>示例:<br>假设 <code>nowcoder.txt </code>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">job salary</span><br><span class="line">c++ 13</span><br><span class="line">java 14</span><br><span class="line">php 12</span><br></pre></td></tr></table></figure><p>你的脚本应当输出（以词频升序排列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job c++ java php</span><br><span class="line">salary 13 14 12</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123; </span><br><span class="line">    # NF表示列数,NR表示当前行数</span><br><span class="line">    for (i=1; i&lt;=NF; i++)&#123;</span><br><span class="line">        if(NR==1)&#123; </span><br><span class="line">            # 处理第一行时,将第i列的值($i)存入arr[i],i为数组的下标,数组不用定义可以直接使用</span><br><span class="line">            arr[i]=$i;   </span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            # 不是第一行时，将该行对应i列的值拼接到arr[i]</span><br><span class="line">            arr[i]=arr[i] &quot; &quot; $i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">END&#123;</span><br><span class="line">    # 每行处理完以后,输出数组</span><br><span class="line">    for (i=1; i&lt;=NF; i++)&#123;</span><br><span class="line">        print arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27; nowcoder.txt</span><br></pre></td></tr></table></figure><h2 id="shell基本语法"><a href="#shell基本语法" class="headerlink" title="shell基本语法"></a>shell基本语法</h2><p><strong>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具</strong></p><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] <span class="string">&#x27;script&#x27;</span> var=value file(s)</span><br><span class="line">或</span><br><span class="line">awk [选项参数] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure><p><strong>选项参数</strong></p><ul><li>-F fs or –field-separator fs<br>指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:</li><li>-v var=value or –asign var=value<br>赋值一个用户定义变量。</li><li>-f scripfile or –file scriptfile<br>从脚本文件中读取awk命令。</li><li>-mf nnn and -mr nnn<br>对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li><li>-W compact or –compat, -W traditional or –traditional<br>在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</li><li>-W copyleft or –copyleft, -W copyright or –copyright<br>打印简短的版权信息。</li><li>-W help or –help, -W usage or –usage<br>打印全部awk选项和每个选项的简短说明。</li><li>-W lint or –lint<br>打印不能向传统unix平台移植的结构的警告。</li><li>-W lint-old or –lint-old<br>打印关于不能向传统unix平台移植的结构的警告。</li><li>-W posix<br>打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符<strong>和</strong>=不能代替^和^=；fflush无效。</li><li>-W re-interval or –re-inerval<br>允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。</li><li>-W source program-text or –source program-text<br>使用program-text作为源代码，可与-f命令混用。</li><li>-W version or –version<br>打印bug报告信息的版本。</li></ul><p><strong>sed</strong></p><p><strong>sed 命令是利用脚本来处理文本文件。</strong></p><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li>-e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。</li><li>-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</li><li>-h或–help 显示帮助。</li><li>-n或–quiet或–silent 仅显示script处理后的结果。</li><li>-V或–version 显示版本信息。</li></ul><p><strong>动作说明</strong>：</p><ul><li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)</li><li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li><li>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li></ul><p>** wc**</p><p><strong>wc命令的功能为统计指定文件中的字节数、字数、行数, 并将统计结果显示输出。</strong></p><p><strong>参数说明</strong></p><ul><li>-c 统计字节数 chars byres</li><li>-l 统计行数      lines</li><li>-w 统计词数    words</li></ul></script></li></ul>]]></content>
    
    
    <summary type="html">整理牛客和力扣上的shell编程题</summary>
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="Shell" scheme="http://example.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>程序、进程和线程</title>
    <link href="http://example.com/2021/03/03/%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2021/03/03/%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-03-03T14:12:17.000Z</published>
    <updated>2021-08-11T13:40:57.590Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="sleep-和usleep"><a href="#sleep-和usleep" class="headerlink" title="sleep()和usleep()"></a>sleep()和usleep()</h2><p>函数名:<strong>sleep()</strong></p><p>头文件:<code>#include &lt;unistd.h&gt; </code>  // 在<code>gcc</code>编译器中，使用的头文件因<code>gcc</code>版本的不同而不同</p><p>功 能: 执行挂起指定的秒数<br>语 法: <code>unsigned sleep(unsigned seconds);</code></p><p>函数名:<strong>usleep()</strong><br>头文件:<code> #include &lt;unistd.h&gt;</code><br>功  能:<code> usleep</code>功能把进程挂起一段时间， 单位是微秒（百万分之一秒）<br>语  法:<code> void usleep(int micro_seconds);</code><br>内容说明：本函数可暂时使程序停止执行。参数 <code>micro_seconds </code>为要暂停的微秒数(us)。</p><h2 id="线程间的互斥"><a href="#线程间的互斥" class="headerlink" title="线程间的互斥"></a>线程间的互斥</h2><p>下面是一个线程互斥的例子。代码用线程互斥的方法构建了以哦个生产者和消费者的例子。代码中建立了两个线程，函数<code>producter_f()</code>用于生成，函数<code>consumer_f()</code>用于消费。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* mutex.c</span></span><br><span class="line"><span class="comment">* 线程实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producter_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span>;<span class="comment">/*生产者*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span>;<span class="comment">/*消费者*/</span></span><br><span class="line"><span class="keyword">int</span> buffer_has_item=<span class="number">0</span>;<span class="comment">/*缓冲区计数值*/</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;<span class="comment">/*互斥区*/</span></span><br><span class="line"><span class="keyword">int</span> running =<span class="number">1</span> ;<span class="comment">/*线程运行控制*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">consumer_t</span>;<span class="comment">/*消费者线程参数*/</span></span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">producter_t</span>;<span class="comment">/*生产者线程参数*/</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_init (&amp;mutex,<span class="literal">NULL</span>);<span class="comment">/*初始化互斥*/</span></span><br><span class="line"></span><br><span class="line">pthread_create(&amp;<span class="keyword">producter_t</span>, <span class="literal">NULL</span>,(<span class="keyword">void</span>*)producter_f, <span class="literal">NULL</span> );            <span class="comment">/*建立生产者线程*/</span></span><br><span class="line">pthread_create(&amp;<span class="keyword">consumer_t</span>, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)consumer_f, <span class="literal">NULL</span>);            <span class="comment">/*建立消费者线程*/</span></span><br><span class="line">usleep(<span class="number">1</span>);<span class="comment">/*等待，线程创建完毕*/</span></span><br><span class="line">running =<span class="number">0</span>;<span class="comment">/*设置线程退出值*/</span></span><br><span class="line">pthread_join(<span class="keyword">consumer_t</span>,<span class="literal">NULL</span>);<span class="comment">/*等待消费者线程退出*/</span></span><br><span class="line">pthread_join(<span class="keyword">producter_t</span>,<span class="literal">NULL</span>);    <span class="comment">/*等待生产者线程退出*/</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);<span class="comment">/*销毁互斥*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producter_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">/*生产者线程程序*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(running)<span class="comment">/*没有设置退出值*/</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock (&amp;mutex);<span class="comment">/*进入互斥区*/</span></span><br><span class="line">buffer_has_item++;<span class="comment">/*增加计数值*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产，总数量:%d\n&quot;</span>,buffer_has_item); <span class="comment">/*打印信息*/</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);<span class="comment">/*离开互斥区*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer_f</span><span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">/*消费者线程程序*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(running)<span class="comment">/*没有设置退出值*/</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);<span class="comment">/*进入互斥区*/</span></span><br><span class="line">buffer_has_item--;<span class="comment">/*减小计数值*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;消费，总数量:%d\n&quot;</span>,buffer_has_item);<span class="comment">/*打印信息*/</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);<span class="comment">/*离开互斥区*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生产，总数量:1</span><br><span class="line">消费，总数量:0</span><br></pre></td></tr></table></figure><p>上例中声明了一个线程互斥变量<code>mutex</code>,在线程函数<code>consumer_f()</code>和<code>producter_f()</code>中，用线程互斥锁函数<code>pthread_mutex_lock()</code>和<code>pthread_mutex_ublock()</code>来保护对公共变量<code>buffer_has_item</code>的访问。</p><h2 id="线程中使用信号量"><a href="#线程中使用信号量" class="headerlink" title="线程中使用信号量"></a>线程中使用信号量</h2><p>下面是一个使用信号量的例子。在<code>mutex</code>的例子中，使用了一个全局变量来计数，在这个例子中，使用信号量来做同样的工作，其中一个线程增加信号量来模仿生产者，另一个线程获得信号量来模仿消费者。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* sem.c</span></span><br><span class="line"><span class="comment">* 线程实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producter_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span>;<span class="comment">/*生产者线程函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span>;<span class="comment">/*消费者线程函数*/</span></span><br><span class="line"><span class="keyword">sem_t</span> sem;</span><br><span class="line"><span class="keyword">int</span> running =<span class="number">1</span> ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">consumer_t</span>;<span class="comment">/*消费者线程参数*/</span></span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">producter_t</span>;<span class="comment">/*生产者线程参数*/</span></span><br><span class="line"></span><br><span class="line">sem_init (&amp;sem, <span class="number">0</span>, <span class="number">16</span>);<span class="comment">/*信号量初始化*/</span></span><br><span class="line"></span><br><span class="line">pthread_create(&amp;<span class="keyword">producter_t</span>, <span class="literal">NULL</span>,(<span class="keyword">void</span>*)producter_f, <span class="literal">NULL</span> );             <span class="comment">/*建立生产者线程*/</span></span><br><span class="line">pthread_create(&amp;<span class="keyword">consumer_t</span>, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)consumer_f, <span class="literal">NULL</span>);             <span class="comment">/*建立消费者线程*/</span></span><br><span class="line">sleep(<span class="number">1</span>);<span class="comment">/*等待*/</span></span><br><span class="line">running =<span class="number">0</span>;<span class="comment">/*设置线程退出*/</span></span><br><span class="line">pthread_join(<span class="keyword">consumer_t</span>,<span class="literal">NULL</span>);<span class="comment">/*等待消费者线程退出*/</span></span><br><span class="line">pthread_join(<span class="keyword">producter_t</span>,<span class="literal">NULL</span>);    <span class="comment">/*等待生产者线程退出*/</span></span><br><span class="line">sem_destroy(&amp;sem);<span class="comment">/*销毁信号量*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producter_f</span> <span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">/*生产者处理程序代码*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> semval=<span class="number">0</span>;<span class="comment">/*信号量的初始值为0*/</span></span><br><span class="line"><span class="keyword">while</span>(running)<span class="comment">/*运行状态为可运行*/</span></span><br><span class="line">&#123;</span><br><span class="line">usleep(<span class="number">1</span>);<span class="comment">/*等待*/</span></span><br><span class="line">sem_post (&amp;sem);<span class="comment">/*信号量增加*/</span></span><br><span class="line">sem_getvalue(&amp;sem,&amp;semval);<span class="comment">/*获得信号量的值*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;生产，总数量:%d\n&quot;</span>,semval);<span class="comment">/*打印信息*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer_f</span><span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">/*消费者处理程序代码*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> semval=<span class="number">0</span>;<span class="comment">/*信号量的初始值为0*/</span></span><br><span class="line"><span class="keyword">while</span>(running)<span class="comment">/*运行状态为可运行*/</span></span><br><span class="line">&#123;</span><br><span class="line">usleep(<span class="number">1</span>);<span class="comment">/*等待*/</span></span><br><span class="line">sem_wait(&amp;sem);<span class="comment">/*等待信号量*/</span></span><br><span class="line">sem_getvalue(&amp;sem,&amp;semval);<span class="comment">/*获得信号量的值*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;消费，总数量:%d\n&quot;</span>,semval);<span class="comment">/*打印信息*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">生产，总数量:56</span><br><span class="line">生产，总数量:57</span><br><span class="line">消费，总数量:56</span><br><span class="line">消费，总数量:55</span><br><span class="line">生产，总数量:56</span><br><span class="line">消费，总数量:55</span><br><span class="line">生产，总数量:56</span><br><span class="line">生产，总数量:57</span><br><span class="line">消费，总数量:56</span><br><span class="line">消费，总数量:55</span><br><span class="line">生产，总数量:56</span><br><span class="line">生产，总数量:57</span><br><span class="line">消费，总数量:56</span><br><span class="line">消费，总数量:55</span><br><span class="line">生产，总数量:56</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从执行结果可以看出，以上程序建立的各个线程间存在竞争关系。而数值并未按产生一个消耗一个的顺序显示出来，而是以交叉的方式进行，有的时候产生多个再消耗多个。造成这种现象的原因是信号量的产生和消耗是对<code>CPU</code>竞争的结果。</p>]]></content>
    
    
    <summary type="html">学习操作系统的核心概念——进程和线程</summary>
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="pthread" scheme="http://example.com/tags/pthread/"/>
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="http://example.com/2021/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2021-02-24T12:16:44.000Z</published>
    <updated>2021-08-11T13:41:09.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Socket-网络通信"><a href="#Socket-网络通信" class="headerlink" title="Socket 网络通信"></a>Socket 网络通信</h1><h2 id="实现点对点通信"><a href="#实现点对点通信" class="headerlink" title="实现点对点通信"></a>实现点对点通信</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tcp_server.c</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888    <span class="comment">/*侦听端口地址*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKLOG 2    <span class="comment">/*侦听队列长度*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR_EXIT(m) do&#123;perror(m);exit(EXIT_FAILURE);&#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sign)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recv a sign: %d&quot;</span>, sign);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ss,sc;    <span class="comment">/*ss为服务器的socket描述符，sc为客户端的socket描述符*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span>    <span class="comment">/*服务器地址结构*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span>    <span class="comment">/*客户端地址结构*/</span></span><br><span class="line"><span class="keyword">int</span> err;      <span class="comment">/*返回值*/</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;    <span class="comment">/*分叉的进行ID*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*建立一个流式套接字*/</span></span><br><span class="line">ss = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ss &lt; <span class="number">0</span>)&#123;    <span class="comment">/*出错*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置服务器地址*/</span></span><br><span class="line"><span class="built_in">bzero</span>(&amp;server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr));        <span class="comment">/*清零*/</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;server_addr,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;                <span class="comment">/*协议族*/</span></span><br><span class="line">server_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">/*本地地址*/</span></span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(PORT);              <span class="comment">/*服务器端口*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*绑定地址结构到套接字描述符*/</span></span><br><span class="line">err = <span class="built_in">bind</span>(ss, (struct sockaddr*)&amp;server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr));</span><br><span class="line"><span class="keyword">if</span>(err &lt; <span class="number">0</span>)&#123;    <span class="comment">/*出错*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置侦听*/</span></span><br><span class="line">err = <span class="built_in">listen</span>(ss, BACKLOG);</span><br><span class="line"><span class="keyword">if</span>(err &lt; <span class="number">0</span>)&#123;    <span class="comment">/*出错*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主循环过程*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">socklen_t</span> addrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr);</span><br><span class="line"></span><br><span class="line">sc = <span class="built_in">accept</span>(ss, (struct sockaddr*)&amp;client_addr, &amp;addrlen); </span><br><span class="line"><span class="comment">/*接收客户端连接*/</span></span><br><span class="line"><span class="keyword">if</span>(sc &lt; <span class="number">0</span>)&#123;    <span class="comment">/*出错*/</span></span><br><span class="line"><span class="built_in">ERR_EXIT</span>(<span class="string">&quot;accept error&quot;</span>);    <span class="comment">/*结束本次循环*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*建立一个新的进程处理到来的连接*/</span></span><br><span class="line">pid = fork();    <span class="comment">/*分叉进程*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子进程只管发数据</span></span><br><span class="line"><span class="keyword">if</span>( pid == <span class="number">0</span> )&#123;    <span class="comment">/*子进程中*/</span></span><br><span class="line"><span class="built_in">signal</span>(SIGUSR1, handler);    <span class="comment">/*通知子进程关闭*/</span></span><br><span class="line"><span class="keyword">char</span> sendbuffer[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">fgets</span>(sendbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(sendbuffer),stdin)!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">write</span>(sc,sendbuffer,<span class="built_in">strlen</span>(sendbuffer));</span><br><span class="line"><span class="built_in">bzero</span>(sendbuffer,<span class="built_in"><span class="keyword">sizeof</span></span>(sendbuffer));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);    <span class="comment">/*在子进程中关闭服务器的侦听*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//父进程只管读数据</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">char</span> recvbuffer[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">bzero</span>(recvbuffer,<span class="built_in"><span class="keyword">sizeof</span></span>(recvbuffer));</span><br><span class="line"><span class="keyword">int</span> size = <span class="built_in">read</span>(sc, recvbuffer, <span class="built_in"><span class="keyword">sizeof</span></span>(recvbuffer));</span><br><span class="line"><span class="keyword">if</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">fputs</span>(recvbuffer, stdout);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(sc);</span><br><span class="line"><span class="built_in">close</span>(ss);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tcp_client.c</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888    <span class="comment">/*侦听端口地址*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR_EXIT(m) do&#123;perror(m);exit(EXIT_FAILURE);&#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sign)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recv a sign: %d&quot;</span>, sign);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s;       <span class="comment">/*s为socket描述符*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span>    <span class="comment">/*服务器地址结构*/</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);    <span class="comment">/*建立一个流式套接字 */</span></span><br><span class="line"><span class="keyword">if</span>(s &lt; <span class="number">0</span>)&#123;   <span class="comment">/*出错*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置服务器地址*/</span></span><br><span class="line"><span class="built_in">bzero</span>(&amp;server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr));        <span class="comment">/*清零*/</span></span><br><span class="line">server_addr.sin_family = AF_INET;                <span class="comment">/*协议族*/</span></span><br><span class="line">server_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">/*本地地址*/</span></span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(PORT);              <span class="comment">/*服务器端口*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将用户输入的字符串类型的IP地址转为整型*/</span></span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, argv[<span class="number">1</span>], &amp;server_addr.sin_addr);</span><br><span class="line"><span class="comment">/*连接服务器*/</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">connect</span>(s, (struct sockaddr*)&amp;server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr))&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">ERR_EXIT</span>(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == pid)&#123;</span><br><span class="line"><span class="built_in">ERR_EXIT</span>(<span class="string">&quot;fork errorr&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == pid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(recvBuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(recvBuf));</span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">read</span>(s, recvBuf, <span class="built_in"><span class="keyword">sizeof</span></span>(recvBuf));</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line"><span class="built_in">ERR_EXIT</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == ret)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;peer close\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fputs</span>(recvBuf, stdout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(s);</span><br><span class="line"><span class="built_in">kill</span>(<span class="built_in">getppid</span>(), SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">signal</span>(SIGUSR1, handler);</span><br><span class="line"><span class="keyword">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">fgets</span>(sendBuf, <span class="built_in"><span class="keyword">sizeof</span></span>(sendBuf), stdin) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">write</span>(s, sendBuf, <span class="built_in">strlen</span>(sendBuf));</span><br><span class="line"><span class="built_in">memset</span>(sendBuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sendBuf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2021/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/01.png" alt="01"></p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>问题：不能处理多个客户端连接服务器</p><p>改进：select多路复用</p><h1 id="bind-函数重难点解析"><a href="#bind-函数重难点解析" class="headerlink" title="bind 函数重难点解析"></a>bind 函数重难点解析</h1><h2 id="bind-函数如何选择绑定地址"><a href="#bind-函数如何选择绑定地址" class="headerlink" title="bind 函数如何选择绑定地址"></a>bind 函数如何选择绑定地址</h2><p>bind 函数的基本用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bindaddr</span>;</span></span><br><span class="line">bindaddr.sin_family = AF_INET;</span><br><span class="line">bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">bindaddr.sin_port = htons(<span class="number">3000</span>);</span><br><span class="line"><span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;bindaddr, <span class="keyword">sizeof</span>(bindaddr)) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind listen socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 bind 的地址我们使用了一个宏叫 <strong>INADDR_ANY</strong> ，关于这个宏的解释如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">If an application does <span class="keyword">not</span> care what local address is assigned, </span><br><span class="line">specify the constant value INADDR_ANY <span class="keyword">for</span> an IPv4 local address</span><br><span class="line"><span class="keyword">or</span> the constant value in6addr_any <span class="keyword">for</span> an IPv6 local address </span><br><span class="line">in the sa_data member of the name parameter. This allows the </span><br><span class="line">underlying service provider to use any appropriate network address,</span><br><span class="line"><span class="function">potentially simplifying application programming in the presence of </span></span><br><span class="line"><span class="function">multihomed <span class="title">hosts</span> <span class="params">(that is, hosts that have more than one network </span></span></span><br><span class="line"><span class="params"><span class="function">interface <span class="keyword">and</span> address)</span>.</span></span><br></pre></td></tr></table></figure><p>意译一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果应用程序不关心bind绑定的ip地址，可以使用INADDR_ANY(如果是IPv6，</span><br><span class="line">则对应in6addr_any)，这样底层的（协议栈）服务会自动选择一个合适的ip地址，</span><br><span class="line">这样使在一个有多个网卡机器上选择ip地址问题变得简单。</span><br></pre></td></tr></table></figure><p>也就是说 <strong>INADDR_ANY</strong> 相当于地址 <strong>0.0.0.0</strong>。可能读者还是不太明白我想表达什么。这里我举个例子，假设我们在一台机器上开发一个服务器程序，使用 bind 函数时，我们有多个ip 地址可以选择。首先，这台机器对外访问的ip地址是<strong>120.55.94.78</strong>，这台机器在当前局域网的地址是<strong>192.168.1.104</strong>；同时这台机器有本地回环地址<strong>127.0.0.1</strong>。</p><p>如果你指向本机上可以访问，那么你 bind 函数中的地址就可以使用<strong>127.0.0.1</strong>; 如果你的服务只想被局域网内部机器访问，bind 函数的地址可以使用<strong>192.168.1.104</strong>；如果 希望这个服务可以被公网访问，你就可以使用地址<strong>0.0.0.0</strong>或 <strong>INADDR_ANY</strong>。</p><h2 id="bind-函数端口号问题"><a href="#bind-函数端口号问题" class="headerlink" title="bind 函数端口号问题"></a>bind 函数端口号问题</h2><p>网络通信程序的基本逻辑是客户端连接服务器，即从客户端的<strong>地址:端口</strong>连接到服务器<strong>地址:端口</strong>上，以 4.2 小节中的示例程序为例，服务器端的端口号使用 3000，那客户端连接时的端口号是多少呢？TCP 通信双方中一般服务器端端口号是固定的，而客户端端口号是连接发起时由操作系统随机分配的（不会分配已经被占用的端口）。端口号是一个 C short 类型的值，其范围是0～65535，知道这点很重要，所以我们在编写压力测试程序时，由于端口数量的限制，在某台机器上网卡地址不变的情况下压力测试程序理论上最多只能发起六万五千多个连接。注意我说的是理论上，在实际情况下，由于当时的操作系统很多端口可能已经被占用，实际可以使用的端口比这个更少，例如，一般规定端口号在1024以下的端口是保留端口，不建议用户程序使用。而对于 Windows 系统，MSDN 甚至明确地说：</p><blockquote><p>On Windows Vista and later, the dynamic client port range is a value between 49152 and 65535. This is a change from Windows Server 2003 and earlier where the dynamic client port range was a value between 1025 and 5000. Vista 及以后的Windows，可用的动态端口范围是49152～65535，而 Windows Server及更早的系统，可以的动态端口范围是1025~5000。（你可以通过修改注册表来改变这一设置，参考网址：<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-bind%EF%BC%89">https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-bind）</a></p></blockquote><p>如果将 bind 函数中的端口号设置成0，那么操作系统会随机给程序分配一个可用的侦听端口，当然服务器程序一般不会这么做，因为服务器程序是要对外服务的，必须让客户端知道确切的ip地址和端口号。</p><p>很多人觉得只有服务器程序可以调用 bind 函数绑定一个端口号，其实不然，在一些特殊的应用中，我们需要客户端程序以指定的端口号去连接服务器，此时我们就可以在客户端程序中调用 bind 函数绑定一个具体的端口。</p><p>我们用代码来实际验证一下上路所说的，为了能看到连接状态，我们将客户端和服务器关闭socket的代码注释掉，这样连接会保持一段时间。</p><ul><li><strong>情形一：客户端代码不绑定端口</strong></li></ul><p>修改后的服务器代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP服务器通信基本流程</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个侦听socket</span></span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create listen socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化服务器地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bindaddr</span>;</span></span><br><span class="line">    bindaddr.sin_family = AF_INET;</span><br><span class="line">    bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    bindaddr.sin_port = htons(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;bindaddr, <span class="keyword">sizeof</span>(bindaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind listen socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.启动侦听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, SOMAXCONN) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;listen error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录所有客户端连接的容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; clientfds;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clientaddrlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        <span class="comment">//4. 接受客户端连接</span></span><br><span class="line">        <span class="keyword">int</span> clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clientaddrlen);</span><br><span class="line">        <span class="keyword">if</span> (clientfd != <span class="number">-1</span>)</span><br><span class="line">        &#123;             </span><br><span class="line">            <span class="keyword">char</span> recvBuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="comment">//5. 从客户端接受数据</span></span><br><span class="line">            <span class="keyword">int</span> ret = recv(clientfd, recvBuf, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data from client, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">//6. 将收到的数据原封不动地发给客户端</span></span><br><span class="line">                ret = send(clientfd, recvBuf, <span class="built_in">strlen</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret != <span class="built_in">strlen</span>(recvBuf))</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data to client successfully, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//close(clientfd);</span></span><br><span class="line">            clientfds.push_back(clientfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.关闭侦听socket</span></span><br><span class="line">    close(listenfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的客户端代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP客户端通信基本流程</span></span><br><span class="line"><span class="comment"> * zhangyl 2018.12.13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_ADDRESS <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT     3000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEND_DATA       <span class="meta-string">&quot;helloworld&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个socket</span></span><br><span class="line">    <span class="keyword">int</span> clientfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (clientfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create client socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class="line">    serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    <span class="keyword">if</span> (connect(clientfd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;connect socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 向服务器发送数据</span></span><br><span class="line">    <span class="keyword">int</span> ret = send(clientfd, SEND_DATA, <span class="built_in">strlen</span>(SEND_DATA), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="built_in">strlen</span>(SEND_DATA))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data successfully, data: &quot;</span> &lt;&lt; SEND_DATA &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 从客户端收取数据</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ret = recv(clientfd, recvBuf, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data successfully, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data error, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 关闭socket</span></span><br><span class="line">    <span class="comment">//close(clientfd);</span></span><br><span class="line">    <span class="comment">//这里仅仅是为了让客户端程序不退出</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将程序编译好后（编译方法和上文一样），我们先启动server，再启动三个客户端。然后通过 <strong>lsof</strong> 命令查看当前机器上的 TCP 连接信息，为了更清楚地显示结果，已经将不相关的连接信息去掉了，结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsof -i -Pn</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">server   1445 root    3u  IPv4  21568      0t0  TCP *:3000 (LISTEN)</span><br><span class="line">server   1445 root    4u  IPv4  21569      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40818 (ESTABLISHED)</span><br><span class="line">server   1445 root    5u  IPv4  21570      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40820 (ESTABLISHED)</span><br><span class="line">server   1445 root    6u  IPv4  21038      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:40822 (ESTABLISHED)</span><br><span class="line">client   1447 root    3u  IPv4  21037      0t0  TCP 127.0.0.1:40818-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class="line">client   1448 root    3u  IPv4  21571      0t0  TCP 127.0.0.1:40820-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class="line">client   1449 root    3u  IPv4  21572      0t0  TCP 127.0.0.1:40822-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>上面的结果显示，<strong>server</strong> 进程（进程 ID 是 <strong>1445</strong>）在 <strong>3000</strong> 端口开启侦听，有三个 <strong>client</strong> 进程（进程 ID 分别是<strong>1447</strong>、<strong>1448</strong>、<strong>1449</strong>）分别通过端口号 <strong>40818</strong>、<strong>40820</strong>、<strong>40822</strong> 连到 <strong>server</strong> 进程上的，作为客户端的一方，端口号是系统随机分配的。</p><ul><li><p><strong>情形二：客户端绑定端口号 0</strong></p><p>服务器端代码保持不变，我们修改下客户端代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP服务器通信基本流程</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_ADDRESS <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT     3000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEND_DATA       <span class="meta-string">&quot;helloworld&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//1.创建一个socket</span></span><br><span class="line">  <span class="keyword">int</span> clientfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (clientfd == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;create client socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bindaddr</span>;</span></span><br><span class="line">  bindaddr.sin_family = AF_INET;</span><br><span class="line">  bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  <span class="comment">//将socket绑定到0号端口上去</span></span><br><span class="line">  bindaddr.sin_port = htons(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bind(clientfd, (struct sockaddr *)&amp;bindaddr, <span class="keyword">sizeof</span>(bindaddr)) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.连接服务器</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">  serveraddr.sin_family = AF_INET;</span><br><span class="line">  serveraddr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);</span><br><span class="line">  serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">  <span class="keyword">if</span> (connect(clientfd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr)) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;connect socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3. 向服务器发送数据</span></span><br><span class="line">  <span class="keyword">int</span> ret = send(clientfd, SEND_DATA, <span class="built_in">strlen</span>(SEND_DATA), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret != <span class="built_in">strlen</span>(SEND_DATA))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;send data successfully, data: &quot;</span> &lt;&lt; SEND_DATA &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4. 从客户端收取数据</span></span><br><span class="line">  <span class="keyword">char</span> recvBuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  ret = recv(clientfd, recvBuf, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data successfully, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;recv data error, data: &quot;</span> &lt;&lt; recvBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5. 关闭socket</span></span><br><span class="line">  <span class="comment">//close(clientfd);</span></span><br><span class="line">  <span class="comment">//这里仅仅是为了让客户端程序不退出</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">  &#123;</span><br><span class="line">      sleep(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们再次编译客户端程序，并启动三个 <strong>client</strong> 进程，然后用 <strong>lsof</strong> 命令查看机器上的 TCP 连接情况，结果如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># lsof -i -Pn</span></span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">server   1593 root    3u  IPv4  21807      0t0  TCP *:3000 (LISTEN)</span><br><span class="line">server   1593 root    4u  IPv4  21808      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:44220 (ESTABLISHED)</span><br><span class="line">server   1593 root    5u  IPv4  19311      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:38990 (ESTABLISHED)</span><br><span class="line">server   1593 root    6u  IPv4  21234      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:42365 (ESTABLISHED)</span><br><span class="line">client   1595 root    3u  IPv4  22626      0t0  TCP 127.0.0.1:44220-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class="line">client   1611 root    3u  IPv4  21835      0t0  TCP 127.0.0.1:38990-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br><span class="line">client   1627 root    3u  IPv4  21239      0t0  TCP 127.0.0.1:42365-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>通过上面的结果，我们发现三个 <strong>client</strong> 进程使用的端口号仍然是系统随机分配的，也就是说绑定 <strong>0</strong> 号端口和没有绑定效果是一样的。</p><ul><li><p><strong>情形三：客户端绑定一个固定端口</strong></p><p>我们这里使用 <strong>20000</strong> 端口，当然读者可以根据自己的喜好选择，只要保证所选择的端口号当前没有被其他程序占用即可，服务器代码保持不变，客户端绑定代码中的端口号从 <strong>0</strong> 改成 <strong>20000</strong>。这里为了节省篇幅，只贴出修改处的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">bindaddr</span>;</span></span><br><span class="line">bindaddr.sin_family = AF_INET;</span><br><span class="line">bindaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"><span class="comment">//将socket绑定到20000号端口上去</span></span><br><span class="line">bindaddr.sin_port = htons(<span class="number">20000</span>);</span><br><span class="line"><span class="keyword">if</span> (bind(clientfd, (struct sockaddr *)&amp;bindaddr, <span class="keyword">sizeof</span>(bindaddr)) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bind socket error.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次重新编译程序，先启动一个客户端后，我们看到此时的 TCP 连接状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# lsof -i -Pn</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">server   1676 root    3u  IPv4  21933      0t0  TCP *:3000 (LISTEN)</span><br><span class="line">server   1676 root    4u  IPv4  21934      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:20000 (ESTABLISHED)</span><br><span class="line">client   1678 root    3u  IPv4  21336      0t0  TCP 127.0.0.1:20000-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>通过上面的结果，我们发现 <strong>client</strong> 进程确实使用 <strong>20000</strong> 号端口连接到 <strong>server</strong> 进程上去了。这个时候如果我们再开启一个 <strong>client</strong> 进程，我们猜想由于端口号 <strong>20000</strong> 已经被占用，新启动的 <strong>client</strong> 会由于调用 <strong>bind</strong> 函数出错而退出，我们实际验证一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# ./client </span><br><span class="line">bind socket error.</span><br><span class="line">[root@localhost testsocket]#</span><br></pre></td></tr></table></figure><p>结果确实和我们预想的一样。</p></li></ul><p>在技术面试的时候，有时候面试官会问 TCP 网络通信的客户端程序中的 socket 是否可以调用 bind 函数，相信读到这里，聪明的读者已经有答案了。</p><p>另外，Linux 的 <strong>nc</strong> 命令有个 <strong>-p</strong> 选项（字母 <strong>p</strong> 是小写），这个选项的作用就是 <strong>nc</strong> 在模拟客户端程序时，可以使用指定端口号连接到服务器程序上去，实现原理相信读者也明白了。我们还是以上面的服务器程序为例，这个我们不用我们的 <strong>client</strong> 程序，改用 <strong>nc</strong> 命令来模拟客户端。在 <strong>shell</strong> 终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# nc -v -p 9999 127.0.0.1 3000</span><br><span class="line">Ncat: Version 6.40 ( http://nmap.org/ncat )</span><br><span class="line">Ncat: Connected to 127.0.0.1:3000.</span><br><span class="line">My name is zhangxf</span><br><span class="line">My name is zhangxf</span><br></pre></td></tr></table></figure><p><strong>-v</strong> 选项表示输出 <strong>nc</strong> 命令连接的详细信息，这里连接成功以后，会输出“**Ncat: Connected to 127.0.0.1:3000.**” 提示已经连接到服务器的 <strong>3000</strong> 端口上去了。</p><p><strong>-p</strong> 选项的参数值是 <strong>9999</strong> 表示，我们要求 <strong>nc</strong> 命令本地以端口号 <strong>9999</strong> 连接服务器，注意不要与端口号 <strong>3000</strong> 混淆，<strong>3000</strong> 是服务器的侦听端口号，也就是我们的连接的目标端口号，<strong>9999</strong> 是我们客户端使用的端口号。我们用 <strong>lsof</strong> 命令来验证一下我们的 <strong>nc</strong> 命令是否确实以 <strong>9999</strong> 端口号连接到 <strong>server</strong> 进程上去了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# lsof -i -Pn</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">server   1676 root    3u  IPv4  21933      0t0  TCP *:3000 (LISTEN)</span><br><span class="line">server   1676 root    7u  IPv4  22405      0t0  TCP 127.0.0.1:3000-&gt;127.0.0.1:9999 (ESTABLISHED)</span><br><span class="line">nc       2005 root    3u  IPv4  22408      0t0  TCP 127.0.0.1:9999-&gt;127.0.0.1:3000 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>结果确实如我们期望的一致。</p><p>当然，我们用 <strong>nc</strong> 命令连接上 <strong>server</strong> 进程以后，我们还给服务器发了一条消息”<strong>My name is zhangxf</strong>“，<strong>server</strong> 程序收到消息后把这条消息原封不动地返还给我们，以下是 <strong>server</strong> 端运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsocket]# ./server   </span><br><span class="line">recv data from client, data: My name is zhangxf</span><br><span class="line"></span><br><span class="line">send data to client successfully, data: My name is zhangxf</span><br></pre></td></tr></table></figure><p>关于 <strong>lsof</strong> 和 <strong>nc</strong> 命令我们会在后面的系列文章中详细讲解。</p><p>参考：<a href="https://balloonwj.github.io/cpp-guide-web/articles/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/bind%E5%87%BD%E6%95%B0%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90.html">https://balloonwj.github.io/cpp-guide-web/articles/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/bind%E5%87%BD%E6%95%B0%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90.html</a></p>]]></content>
    
    
    <summary type="html">学习Socket网络编程</summary>
    
    
    
    <category term="网络编程" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Socket" scheme="http://example.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm</title>
    <link href="http://example.com/2021/02/21/Algorithm/"/>
    <id>http://example.com/2021/02/21/Algorithm/</id>
    <published>2021-02-21T13:32:33.000Z</published>
    <updated>2021-09-17T06:47:14.319Z</updated>
    
    <content type="html"><![CDATA[<p>整理分类做过的 <code>leetcode</code>，好记性不如烂笔头啊~</p><p>[TOC]</p><h1 id="滑动窗口-双指针"><a href="#滑动窗口-双指针" class="headerlink" title="滑动窗口/双指针"></a>滑动窗口/双指针</h1><p><strong>最短或最长的子串  最多可变k次</strong></p><h2 id="LC-3-无重复字符的最长子串"><a href="#LC-3-无重复字符的最长子串" class="headerlink" title="LC-3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LC-3. 无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （一）</span></span><br><span class="line"><span class="comment"> * 这里可以建立一个 HashMap，建立每个字符和其最后出现位置之间的映射</span></span><br><span class="line"><span class="comment"> * 然后定义两个变量 res 和 left，其中 res 用来记录最长无重复子串的长度</span></span><br><span class="line"><span class="comment"> * left 指向该无重复子串左边的起始位置的前一个，所以初始化就是 -1</span></span><br><span class="line"><span class="comment"> * 然后遍历整个字符串，对于每一个遍历到的字符，如果该字符已经在 HashMap 中存在了，</span></span><br><span class="line"><span class="comment"> * 并且如果其映射值大于 left 的话，那么更新 left 为当前映射值。然后映射值更新为当前坐标i，</span></span><br><span class="line"><span class="comment"> * 这样保证了 left 始终为当前边界的前一个位置，然后计算窗口长度的时候，直接用 i-left 即可，</span></span><br><span class="line"><span class="comment"> * 用来更新结果 res。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">-1</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(s[i]) &amp;&amp; m[s[i]] &gt; left) &#123;</span><br><span class="line">                left = m[s[i]];  </span><br><span class="line">            &#125;</span><br><span class="line">            m[s[i]] = i;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - left);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面这种解法使用了 <code>HashSet</code>，核心算法和上面的很类似，把出现过的字符都放入<code>HashSet</code>中，遇到 <code>HashSet </code>中没有的字符就加入<code> HashSet</code> 中并更新结果 <code>res</code>，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （二）</span></span><br><span class="line"><span class="comment"> * 下面这种解法使用了 HashSet，核心算法和上面的很类似，</span></span><br><span class="line"><span class="comment"> * 把出现过的字符都放入 HashSet 中，遇到 HashSet 中没有的字符就加入 HashSet</span></span><br><span class="line"><span class="comment"> * 并更新结果 res，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, res=<span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">find</span>(s[i])!=st.<span class="built_in">end</span>())&#123;</span><br><span class="line">                st.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">            res=<span class="built_in">max</span>(res,i-left+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-76-最小覆盖子串"><a href="#LC-76-最小覆盖子串" class="headerlink" title="LC-76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">LC-76. 最小覆盖子串</a></h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p> <strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p>这道题给了我们一个原字符串<code>s</code>，还有一个目标字符串<code>t</code>，让在<code>s</code>中找到一个最短的子串，使得其包含了<code>t</code>中的所有的字母，并且限制了时间复杂度为<code> O(n)</code>。这道题的要求是要在<code>O(n) </code>的时间度里实现找到这个最小窗口字串，暴力搜索 <code>Brute Force </code>肯定是不能用的，因为遍历所有的子串的时间复杂度是平方级的。那么来想一下，时间复杂度卡的这么严，说明必须在一次遍历中完成任务，当然遍历若干次也是<code> O(n)</code>，但不一定有这个必要，尝试就一次遍历拿下！那么再来想，既然要包含T中所有的字母，那么对于T中的每个字母，肯定要快速查找是否在子串中，既然总时间都卡在了<code> O(n)</code>，肯定不想在这里还浪费时间，就用空间换时间（也就算法题中可以这么干了，七老八十的富翁就算用大别野也换不来时间啊。依依东望，望的就是时间呐），使用<code> HashMap</code>，建立T中每个字母与其出现次数之间的映射。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * step1: 确定右边界</span></span><br><span class="line"><span class="comment"> * 先用 HashMap 统计好 t 串中字母的，再遍历 s 串，对于 s 中的每个字母</span></span><br><span class="line"><span class="comment"> * 都将 HashMap 中的映射值减1，如果减1后的映射值仍大于等于0，说明当前遍历到的字母是 t 串中的字母</span></span><br><span class="line"><span class="comment"> * 使用 cnt++ 记录。当cnt 和 t 串字母个数相等时，说明此时的窗口已经包含了 t 串中的所有字母</span></span><br><span class="line"><span class="comment"> * step2: 收缩左边界</span></span><br><span class="line"><span class="comment"> * 由于遍历的时候，映射值减了1，所以此时去除字母的时候，就要把减去的1加回来，</span></span><br><span class="line"><span class="comment"> * 此时如果加1后的值大于0了，说明当前遍历到的字母是 t 串中的字母，</span></span><br><span class="line"><span class="comment"> * 那么 cnt 值就要减1了，然后移动左边界left</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; letterCnt;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++letterCnt[c];         <span class="comment">//遍历t</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--letterCnt[s[i]] &gt;= <span class="number">0</span>) ++cnt;   <span class="comment">//--letterCnt[s[i]] &gt;= 0，s[i]在t中</span></span><br><span class="line">            <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                    res = s.<span class="built_in">substr</span>(left, minLen); <span class="comment">//从left开始，长度为minLen的字符串</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收缩左边界 ++letterCnt[s[left]] &gt; 0， 0-&gt;1 该元素在t中，</span></span><br><span class="line">                <span class="keyword">if</span> (++letterCnt[s[left]] &gt; <span class="number">0</span>) --cnt;   </span><br><span class="line">                <span class="comment">//因为不在t中的本来为0，先减去，现在再增加，最终还是0.</span></span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="pa-3-寻找最靠左的匹配子串"><a href="#pa-3-寻找最靠左的匹配子串" class="headerlink" title="pa-3.寻找最靠左的匹配子串"></a><a href="https://www.papamelon.com/problem/3">pa-3.寻找最靠左的匹配子串</a></h2><p>给定一个字符串 A 长度为 N，1 &lt;= N &lt;= 2*10^5，下标从 0 开始标号，仅包含 0 到 9 这十种字符。</p><p>再给定另一个字符串 B，长度为 M，1 &lt;= M &lt;= 2*10^5，下标从 0 开始标号，也是仅包含 0 到 9 这十种字符。</p><p>例如以下字符串就是一个合法的 A或 B</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">066465353473034515</span><br></pre></td></tr></table></figure><p>现在我们要在 A寻找一个连续的子串 s，使得 s包含 B中出现的所有字符，且要保证 s的<strong>长度尽可能短</strong>。如果存在多个符合上述条件的 s，<strong>返回最靠左</strong>的那个。</p><p>例如:</p><ul><li>B串：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3314</span><br></pre></td></tr></table></figure><ul><li>A串：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">563145633</span><br></pre></td></tr></table></figure><p>子串 A[2:7]为 <code>314563</code>，包含了 B串中出现的 <code>3</code>, <code>3</code>, <code>1</code>, <code>4</code>。</p><p>子串 A[3:8]为 <code>145633</code>，也包含了 B串中出现的 <code>3</code>, <code>3</code>, <code>1</code>, <code>4</code>。</p><p>两个子串长度一样，而前者更靠左，因此前者就是我们要找的答案。</p><p><strong>输入</strong></p><ul><li>每组测试数据的第一行是整数 T，$1 \leq T \leq 1000$，表示接下来有 T对 A, B串</li><li>接下来有 $2*T$行，每两行分别表示一对 A串和 B串</li><li>A<em>A</em> 串长度为 N，1 &lt;= N &lt;= 2*10^5</li><li>B<em>B</em> 串长度为 M，1 &lt;= M &lt;= 2*10^5</li><li>一组测试数据中字符总数为 C，  2 * T  &lt;= C &lt;= 2*10^6</li></ul><p><strong>输出</strong></p><ul><li>输出 T行，每行两个整数，用空格分割，表示 A的子串下标</li><li>如果不存在这样的合法子串，输出 <code>-1 -1</code></li></ul><p>样例 1</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">563145633</span><br><span class="line">3314</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 7</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>样例 2</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">678</span><br><span class="line">123</span><br><span class="line">12345</span><br><span class="line">1233</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 -1</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （一）</span></span><br><span class="line"><span class="comment"> * 核心算法继承LC-76，先确定右边界再收缩左边界</span></span><br><span class="line"><span class="comment"> * 需要注意输入输出的练习</span></span><br><span class="line"><span class="comment"> * if else规范书写，一个小bug调式了好久</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s, t;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++mp[c];        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--mp[s[i]] &gt;= <span class="number">0</span>) ++cnt;   </span><br><span class="line">            <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                    res.<span class="built_in">clear</span>();</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;left,left+minLen<span class="number">-1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++mp[s[left]] &gt; <span class="number">0</span>) --cnt;   </span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-1</span> &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; res[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>  &lt;&lt; res[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">Solution</span>().<span class="built_in">minWindow</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （二）</span></span><br><span class="line"><span class="comment"> * 核心算法继承LC-76，</span></span><br><span class="line"><span class="comment"> * 代码稍微简洁，逻辑不变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s, t;</span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++mp[c];         </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--mp[s[i]] &gt;= <span class="number">0</span>) ++cnt;   </span><br><span class="line">        <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                res.<span class="built_in">clear</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;left,left+minLen<span class="number">-1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++mp[s[left]] &gt; <span class="number">0</span>) --cnt;   </span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return res;</span></span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-1</span> &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; res[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>  &lt;&lt; res[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LC-1-两数之和"><a href="#LC-1-两数之和" class="headerlink" title="LC-1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">LC-1. 两数之和</a></h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em>target</em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （一）</span></span><br><span class="line"><span class="comment"> * 笨方法</span></span><br><span class="line"><span class="comment"> * 最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</span></span><br><span class="line"><span class="comment"> * 当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，</span></span><br><span class="line"><span class="comment"> * 因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(target== nums[i]+nums[j])&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （二）</span></span><br><span class="line"><span class="comment"> * 注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，</span></span><br><span class="line"><span class="comment"> * 能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</span></span><br><span class="line"><span class="comment"> * 使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)。</span></span><br><span class="line"><span class="comment"> * 这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，</span></span><br><span class="line"><span class="comment"> * 即可保证不会让 x 和自己匹配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(target-nums[i])!=mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(mp.<span class="built_in">find</span>(target-nums[i])-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mp.insert(pair&lt;int, int&gt;(nums[i], i));</span></span><br><span class="line">            mp[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （三）再精简一下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, m[target - nums[i]]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-15-三数之和"><a href="#LC-15-三数之和" class="headerlink" title="LC-15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">LC-15. 三数之和</a></h2><p>难度中等3545收藏分享切换为英文接收动态反馈</p><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序+双指针</span></span><br><span class="line"><span class="comment"> * 固定第一个数，转化为求两数之和</span></span><br><span class="line"><span class="comment"> * 特别注意相邻元素去重</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">3</span>)   <span class="keyword">return</span> &#123;&#125;;          <span class="comment">// 特判</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;res;            <span class="comment">// 保存结果（所有不重复的三元组）</span></span><br><span class="line">        std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// 排序（默认递增）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)      <span class="comment">// 固定第一个数，转化为求两数之和</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)  <span class="keyword">return</span> res; <span class="comment">// 第一个数大于 0，后面都是递增正数，不可能相加为零</span></span><br><span class="line">            <span class="comment">// 去重：如果此数已经选取过，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 双指针在nums[i]后面的区间中寻找和为0-nums[i]的另外两个数</span></span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] &gt; -nums[i])</span><br><span class="line">                    right--;    <span class="comment">// 两数之和太大，右指针左移</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; -nums[i])</span><br><span class="line">                    left++;     <span class="comment">// 两数之和太小，左指针右移</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 找到一个和为零的三元组，添加到结果中，左右指针内缩，继续寻找</span></span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="comment">// 去重：第二个数和第三个数也不重复选取</span></span><br><span class="line">                    <span class="comment">// 例如：[-4,1,1,1,2,3,3,3], i=0, left=1, right=5</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">-1</span>])  left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>])    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-40-组合总和-II"><a href="#LC-40-组合总和-II" class="headerlink" title="LC-40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">LC-40. 组合总和 II</a></h2><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,2,2],</span><br><span class="line">[5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回溯+剪枝</span></span><br><span class="line"><span class="comment"> * 特别注意相邻元素去重</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; target-candidates[i] &gt;= <span class="number">0</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; index &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//处理节点</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            <span class="built_in">backtrack</span>(candidates, target-candidates[i], i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯，撤销处理结果</span></span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//对candidates先排序</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-451-根据字符出现频率排序"><a href="#LC-451-根据字符出现频率排序" class="headerlink" title="LC-451.根据字符出现频率排序"></a><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">LC-451.根据字符出现频率排序</a></h2><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><p>示例 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line">输出:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line">解释:</span><br><span class="line">&#x27;e&#x27;出现两次，&#x27;r&#x27;和&#x27;t&#x27;都只出现一次。</span><br><span class="line">因此&#x27;e&#x27;必须出现在&#x27;r&#x27;和&#x27;t&#x27;之前。此外，&quot;eetr&quot;也是一个有效的答案。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line">输出:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line">解释:</span><br><span class="line">&#x27;c&#x27;和&#x27;a&#x27;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。</span><br><span class="line">注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line">输出:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line">解释:</span><br><span class="line">此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。</span><br><span class="line">注意&#x27;A&#x27;和&#x27;a&#x27;被认为是两种不同的字符。。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表记录每个字符出现的频率，将字符去重后存入列表</span></span><br><span class="line"><span class="comment"> * 再将列表中的字符按照频率降序排序</span></span><br><span class="line"><span class="comment"> * 生成排序后的字符串时，遍历列表中的每个字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:s) mp[it]++;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; vec; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) vec.<span class="built_in">push_back</span>(it);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;b)&#123;<span class="keyword">return</span> a.second &gt; b.second;&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [ch, num] : vec) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vector&lt;pair&lt;int,int&gt; &gt;vec</span></span><br><span class="line"><span class="comment"> * vec.push_back(make_pair&lt;int,int&gt;(10,50));</span></span><br><span class="line"><span class="comment"> * vec.push_back(make_pair(20,30));</span></span><br><span class="line"><span class="comment"> * vector&lt;pair&lt;int,int&gt;&gt; ::iterator iter;</span></span><br><span class="line"><span class="comment"> * for(iter=vec.begin();iter!=vec.end();iter++);</span></span><br><span class="line"><span class="comment"> * 第一个数据:(*iter).first</span></span><br><span class="line"><span class="comment"> * 第二个数据:(*iter).second</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="LC-136-只出现一次的数字"><a href="#LC-136-只出现一次的数字" class="headerlink" title="LC-136.只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/">LC-136.只出现一次的数字</a></h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>给定一个数组，从数组中查找左右对称相加的和等于k的最长子数组</p><p>示例</p><p>arr = [2,4,4,5,10,5,6,9,8]   k=10</p><p>res = [4,5,10,5,6]</p><p>arr = [2,6,7,10,2,5,6,9]   k=12</p><p>res = [6,7,10,2,5,6]</p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="LC-122-买卖股票的最佳时机-II"><a href="#LC-122-买卖股票的最佳时机-II" class="headerlink" title="LC-122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LC-122. 买卖股票的最佳时机 II</a></h2><p>难度简单1290收藏分享切换为英文接收动态反馈</p><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= prices[i] &lt;= 10^4</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pa-9-套娃"><a href="#pa-9-套娃" class="headerlink" title="pa-9.套娃"></a><a href="https://www.papamelon.com/problem/9">pa-9.套娃</a></h2><p>小棒瓜瓜有 n个套娃，设第 i个套娃的体积为v_i，大套娃可以套住小套娃，同时要满足以下条件：</p><ul><li>一个大套娃想要套住另一个小套娃，体积至少是其 3 倍；例如大套娃体积为 10，小套娃体积为 3，前者是后者的 3.333… 倍，可以套住</li><li>一个大套娃只能套住一个小套娃，一旦套住后，小套娃不能再套其他更小的套娃，也就是说不能继续嵌套下去</li><li>当大套娃套住小套娃后，小套娃不再可见</li></ul><p>现在我们要帮小棒瓜瓜选择一种最优的套娃方案，使得最终可见的套娃数量最少。</p><p>输入</p><ul><li>第一行输入整数 T,  1 &lt;= T &lt;=1000，表示接下来有 T组数据</li><li>接下来有 T行，每行表示一组套娃的信息</li><li>对于每组套娃，第一个整数是 n，表示套娃数量，1 &lt;= n &lt;= 600；后面跟着 n个正整数，用空格分隔，表示每个套娃的体积，第 i个整数为 v_i, 1 &lt;= v_i &lt;= 10000​</li></ul><p>输出</p><ul><li>输出 T行，每行一个整数，表示 T组套娃经过操作，可见套娃的最小数量</li></ul><p>样例 1</p><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 1 3 7</span><br><span class="line">3 1 2 3</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  |-----------------|------------------|</span></span><br><span class="line"><span class="comment"> * a[0]              a[n/2]             a[n-1]</span></span><br><span class="line"><span class="comment"> * 根据条件2，一个大娃只能套一个小娃，所以最终可见套娃数量最少为 n/2</span></span><br><span class="line"><span class="comment"> * 所以小娃在前半部分，大娃在后半部分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n ;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        a.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> res = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n/<span class="number">2</span> &amp;&amp; j&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]/a[i] &gt;=<span class="number">3</span>)&#123;</span><br><span class="line">            res--;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> j++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-18-套娃II"><a href="#pa-18-套娃II" class="headerlink" title="pa-18.套娃II"></a><a href="https://www.papamelon.com/problem/18">pa-18.套娃II</a></h2><p>小棒瓜瓜在第一次得到 <a href="https://www.papamelon.com/problem/9">套娃</a> 玩具后，喜欢上了这种玩具，这次他准备用行李箱上带着套娃去旅游。</p><p>现在有 n个套娃，设第 i 个套娃的体积为 v_i，大套娃可以套住小套娃，同时要满足以下条件：</p><ul><li>一个大套娃想要套住另一个小套娃，体积至少是其 33 倍；例如大套娃体积为 10，小套娃体积为 3，前者是后者的 3.333… 倍，可以套住</li><li>一个大套娃只能套住一个小套娃，一旦套住后，小套娃不能再套其他更小的套娃，也就是说不能继续嵌套下去</li><li>当大套娃套住小套娃后，两者的体积就是大套娃的体积</li></ul><p>小棒瓜瓜有一个行李箱，它的容积是 C，希望能用行李箱装下 <strong>最多数量</strong> 的套娃，在能装下最多套娃的情况下，选择 <strong>占用空间最小</strong> 的方案。</p><p>来看一下实际的例子：</p><p>有 66 个套娃，它们的体积分别为[1,3,4,3,12,10]，行李箱的容积为 16</p><p> <strong>第一种方案</strong></p><ul><li>第三个套娃能套住第一个套娃，套住后两者体积为 4</li><li>第五个套娃能套住第二个套娃，套住后两者体积为 12</li><li>最终选择 4 个套娃，总体积为 16</li></ul><p> <strong>第二种方案</strong></p><ul><li>第二个套娃能套住第一个套娃，套住后两者体积为 3</li><li>第六个套娃能套住第四个套娃，套住后两者体积为 10</li><li>最终选择 4 个套娃，总体积为 13</li></ul><p><strong>第三种方案</strong></p><ul><li>第二个套娃能套住第一个套娃，套住后两者体积为 3</li><li>再选择第三，四个套娃，它们两个不套住其他的任何套娃，也不被别人套住，共占用体积 7</li><li>最终选择 4 个套娃，总体积为 10</li></ul><p>上述方案能带走的套娃数量是最多的，而第三种方案占用空间更小，选择第三种方案。</p><p> <strong>输入</strong></p><ul><li><p>第一行输入整数 T, ,1≤ T ≤100，表示接下来有 T 组数据</p></li><li><p>接下来有 T 行，每行表示套娃和行李箱的信息</p><ul><li>第一个整数是 n, 1≤ n ≤12，表示套娃数量</li><li>第二个整数为 C, 1≤ C ≤105，表示行李箱容积</li><li>后面跟着 n个正整数，用空格分隔，表示每个套娃的体积，第 i 个整数为 v_i, 1≤ vi ≤10000</li></ul></li></ul><p> <strong>输出</strong></p><ul><li>输出 T 行，每行两个整数，表示最多能带走多少个套娃，以及保证套娃数量最多的情况下，占用的最小空间</li></ul><p>样例 1</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">6 16 1 3 4 3 12 10</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 10</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 二进制枚举外部套娃</span></span><br><span class="line"><span class="comment"> * 2. 枚举未选中的套娃</span></span><br><span class="line"><span class="comment"> * 3. 双指针得出最小体积</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> T, n, C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; C;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)  cin &gt;&gt; a[i] ;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxcount=<span class="number">0</span>, mincap=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxstate = <span class="number">1</span>&lt;&lt;n;  <span class="comment">// 2^n方种状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始状态压缩枚举, 枚举 2^n方种状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;maxstate; ++s)&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visted</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>, cap=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (s&gt;&gt;i) &amp; <span class="number">1</span> )&#123; <span class="comment">//第 i 个外围套娃被选中</span></span><br><span class="line">                b.<span class="built_in">push_back</span>(i);</span><br><span class="line">                count++;</span><br><span class="line">                cap += a[i];</span><br><span class="line">                visted[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cap &gt; C) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; i&lt;n &amp;&amp; j&lt;b.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visted[i])&#123;</span><br><span class="line">                <span class="comment">//从未被选中的套娃里面依次判断是否可以放入外围套娃中</span></span><br><span class="line">                <span class="keyword">while</span>( j&lt;b.<span class="built_in">size</span>() &amp;&amp; a[i]*<span class="number">3</span> &gt; a[b[j]]) j++;</span><br><span class="line">                <span class="keyword">if</span>( j&lt;b.<span class="built_in">size</span>())  count++, j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新结果</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; maxcount || (count==maxcount &amp;&amp; cap &lt; mincap))&#123;</span><br><span class="line">                maxcount = count;</span><br><span class="line">                mincap = cap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxcout==<span class="number">0</span>)  mincap=<span class="number">0</span>; <span class="comment">//特例输出</span></span><br><span class="line">    cout &lt;&lt; maxcount &lt;&lt; <span class="string">&quot;　&quot;</span> &lt;&lt; mincap &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS/BFS"></a>DFS/BFS</h1><h2 id="LC-200-岛屿数量"><a href="#LC-200-岛屿数量" class="headerlink" title="LC-200.岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">LC-200.岛屿数量</a></h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><blockquote><p>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 300<br>grid(i)(j)的值为 ‘0’ 或 ‘1’</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. dfs+备忘录</span></span><br><span class="line"><span class="comment"> * 2. 枚举未选中的套娃</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; vis;  <span class="comment">//标记数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> dc[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; g, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; ++k)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = i + dr[k];</span><br><span class="line">            <span class="keyword">int</span> c = j + dc[k];</span><br><span class="line">            <span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;=n || c&lt;<span class="number">0</span> || c&gt;=m || g[r][c]==<span class="string">&#x27;0&#x27;</span> || vis[r][c])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(g, r, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        n = g.<span class="built_in">size</span>();</span><br><span class="line">        m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vis.<span class="built_in">assign</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[i][j]==<span class="literal">false</span> &amp;&amp; g[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    <span class="built_in">dfs</span>(g, i ,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. dfs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; g, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= g.<span class="built_in">size</span>() || j &gt;= g[<span class="number">0</span>].<span class="built_in">size</span>() || g[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        g[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//上下左右</span></span><br><span class="line">        <span class="built_in">dfs</span>(g, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(g, i, j + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(g, i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(g, i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = g.<span class="built_in">size</span>(),n = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(g, i, j);</span><br><span class="line">                    res ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h1><h2 id="LC-5-最长回文子串"><a href="#LC-5-最长回文子串" class="headerlink" title="LC-5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">LC-5. 最长回文子串</a></h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= s.length &lt;= 1000</code></p></li><li><p><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （一）中心扩展法</span></span><br><span class="line"><span class="comment"> * 由于回文串的长度可奇可偶，比如 “bob” 是奇数形式的回文，”noon” 就是偶数形式的回文，</span></span><br><span class="line"><span class="comment"> * 两种形式的回文都要搜索，对于奇数形式的，我们就从遍历到的位置为中心，向两边进行扩散，</span></span><br><span class="line"><span class="comment"> * 对于偶数情况，我们就把当前位置和下一个位置当作偶数行回文的最中间两个字符，然后向两边进行搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;    <span class="comment">//记录回文子串起始位置</span></span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>;      <span class="comment">//记录回文子串终止位置</span></span><br><span class="line">        <span class="keyword">int</span> mlen=<span class="number">0</span>;     <span class="comment">//记录最大回文子串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len1=<span class="built_in">expendaroundcenter</span>(s,i,i);     <span class="comment">//一个元素为中心</span></span><br><span class="line">            <span class="keyword">int</span> len2=<span class="built_in">expendaroundcenter</span>(s,i,i+<span class="number">1</span>);   <span class="comment">//两个元素为中心</span></span><br><span class="line">            mlen=<span class="built_in">max</span>(<span class="built_in">max</span>(len1,len2),mlen);</span><br><span class="line">            <span class="keyword">if</span>(mlen&gt;end-start+<span class="number">1</span>)&#123;</span><br><span class="line">                start=i-(mlen<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                end=i+mlen/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,mlen);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expendaroundcenter</span><span class="params">(string s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//计算以left和right为中心的回文串长度</span></span><br><span class="line">        <span class="keyword">int</span> L=left;</span><br><span class="line">        <span class="keyword">int</span> R=right;</span><br><span class="line">        <span class="keyword">while</span>(L&gt;=<span class="number">0</span> &amp;&amp; R&lt;s.<span class="built_in">length</span>() &amp;&amp; s[R]==s[L])&#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R-L<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （一）中心扩展法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//以 s[left] s[right] 为中心向两端扩散的回文串</span></span><br><span class="line">    <span class="function">string <span class="title">expendaroundcenter</span><span class="params">(string &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//防止索引越界</span></span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.<span class="built_in">size</span>()&amp;&amp;s[left]==s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left+<span class="number">1</span>,right-left<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string s1=<span class="built_in">expendaroundcenter</span>(s,i,i);</span><br><span class="line">            string s2=<span class="built_in">expendaroundcenter</span>(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//res=longest(res,s1,s1)</span></span><br><span class="line">            res=res.<span class="built_in">size</span>()&gt;s1.<span class="built_in">size</span>()?res:s1;</span><br><span class="line">            res=res.<span class="built_in">size</span>()&gt;s2.<span class="built_in">size</span>()?res:s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （二）动态规划</span></span><br><span class="line"><span class="comment"> * 1.确定dp数组（dp table）以及下标的含义</span></span><br><span class="line"><span class="comment"> * 2.确定递推公式</span></span><br><span class="line"><span class="comment"> * 3.dp数组如何初始化</span></span><br><span class="line"><span class="comment"> * 4.确定遍历顺序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在确定递推公式时，就要分析如下几种情况。</span></span><br><span class="line"><span class="comment"> * 整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</span></span><br><span class="line"><span class="comment"> * 当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</span></span><br><span class="line"><span class="comment"> * 当s[i]与s[j]相等时，这就复杂一些了，又有如下三种情况</span></span><br><span class="line"><span class="comment"> *  情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</span></span><br><span class="line"><span class="comment"> *  情况二：下标i 与 j相差为1，例如aa，也是回文子串</span></span><br><span class="line"><span class="comment"> *  情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，</span></span><br><span class="line"><span class="comment"> *  我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，</span></span><br><span class="line"><span class="comment"> *  这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *     —— —— —— —— —  —— —— —— ——</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *    |             |  dp[i][j]  |</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *     —— —— —— —— —  —— —— —— ——</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *    |dp[i+1][j-1] |            |</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *     —— —— —— —— —  —— —— —— ——</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本题目是少有的动态规划非最优解的问题 （时间 O(n^2) ！空间O(n^2)）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，</span></span><br><span class="line">        <span class="comment">// 如果是dp[i][j]为true，否则为false。</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxlenth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j]由dp[i+1][j-1]确定，因此从左下向右上遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;    <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlenth) &#123;</span><br><span class="line">                    maxlenth = j - i + <span class="number">1</span>;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以上代码是为了凸显情况一二三，当然是可以简洁一下的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxlenth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlenth) &#123;</span><br><span class="line">                    maxlenth = j - i + <span class="number">1</span>;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left, maxlenth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JZ-47-礼物的最大价值"><a href="#JZ-47-礼物的最大价值" class="headerlink" title="JZ-47.礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">JZ-47.礼物的最大价值</a></h2><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。</p><p>你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。</p><p>给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><blockquote><p> 提示：<br>0 &lt; grid.length &lt;= 200<br>0 &lt; grid[0].length &lt;= 200</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * dp状态定义：dp[i][j]表示从“start”位置走到(i,j)位置的最大权重 </span></span><br><span class="line"><span class="comment"> * dp转移方程：dp[i][j] = max(dp[i-1][j], dp[i][j-1])+grid[i][j] 只能从上面dp[i-1][j] 或 左边dp[i][j-1] 走过来</span></span><br><span class="line"><span class="comment"> * dp初始化：</span></span><br><span class="line"><span class="comment"> *  - dp[0][0] = grid[0][0]</span></span><br><span class="line"><span class="comment"> *  - dp[0][j] = dp[0][j-1] + grid[0][j]</span></span><br><span class="line"><span class="comment"> *  - dp[i][0] = dp[i-1][0] + grid[i][0]</span></span><br><span class="line"><span class="comment"> * 最终结果：res = dp[m-1][n-1] </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=grid.<span class="built_in">size</span>(), n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector &lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt; (n,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)  dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; ++i)  dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; ++j)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res=dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="pa-185-种植棒瓜"><a href="#pa-185-种植棒瓜" class="headerlink" title="pa-185.种植棒瓜"></a><a href="https://www.papamelon.com/problem/185">pa-185.种植棒瓜</a></h2><p>小棒瓜瓜在自己的果园中种植棒瓜。</p><p>每一天他都能掌握一定的种植经验，经验越丰富，种植出来的棒瓜越甜美。</p><p>但是小棒瓜瓜的记性不太好，时间一长，曾经积累下来的经验就会忘掉。</p><p>假设他的记忆力为 K，表示能记住 K 天内的事情。也就是说，在第 i 天，他能记住第 i-K, i-K+1, i-K+2 … i-1 天内的所有事情。</p><p>完成第 i 天的种植工作后，小棒瓜瓜能获得经验值 A_i</p><p>在进行第 i 天工作时，他拥有的全部经验为 A_{i-K} + A_{i-K+1} + A_{i-K+2} … + A_{i-1} 。</p><p>请问哪一天，小棒瓜瓜的种植经验是最丰富的？如果有多天的种植经验都是最丰富的，选最靠后的那天。</p><p><strong>输入</strong></p><p>多组测试数据，以 EOF 结束</p><p>每组测试数据占一行：</p><p>第一个整数是 n(1≤n≤10^5)，表示有 n 天</p><p>第二个整数是 K(1≤K≤n)，表示记忆力</p><p>后面跟着 n 个整数，第 i 个整数为 A_i(1≤A_i≤100)</p><p>数据保证：多组数据的 n 之和不超过 10^5</p><p><strong>输出</strong></p><p>输出若干行，每行一个整数，表示哪一天小棒瓜瓜的种植经验最丰富</p><p><strong>提示</strong></p><p>天数从 1 到 n 进行编号</p><blockquote><p>样例 1<br>输入<br>4 2<br>1 2 2 3</p><p>输出<br>4</p><p>提示<br>一组测试数据。<br>一共 4 天，记忆力为 2。<br>第一天种植时，掌握的经验为 0。<br>第二天种植时，掌握的经验为 1。<br>第三天种植时，掌握的经验为 1 + 2 = 3。<br>第四天种植时，掌握的经验为 2 + 2 = 4。<br>第四天的种植经验最丰富。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 状态定义: f[i] 表示执行第 i 天种植任务时掌握的经验总和</span></span><br><span class="line"><span class="comment"> * 由题意可知:</span></span><br><span class="line"><span class="comment"> * - f[i] = A[i-K] + A[i-K+1] ... + A[i-1]</span></span><br><span class="line"><span class="comment"> * - f[i+1] = A[i-K+1] + A[i-K+2] ... + A[i]</span></span><br><span class="line"><span class="comment"> * 上面两个式子相减，去掉同类项目可得：f[i+1] - f[i] = A[i] - A[i-K] </span></span><br><span class="line"><span class="comment"> * 上面式子左右移项可得：f[i+1] = f[i] + A[i] - A[i-K]</span></span><br><span class="line"><span class="comment"> * 到这里，我们得到了递推公式</span></span><br><span class="line"><span class="comment"> * 注意边界情况：前 K+1 天，f[i] = A[1] + A[2] ... + A[i-1]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; k)&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>, maxsum=<span class="number">0</span>, sum=<span class="number">0</span>, a[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre = i-k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre&gt;<span class="number">0</span>) sum-=a[pre];  <span class="comment">//sum至多为k个元素的累加和</span></span><br><span class="line">            <span class="keyword">if</span>(sum&gt;=maxsum)&#123;</span><br><span class="line">                maxsum=sum;</span><br><span class="line">                res=i;</span><br><span class="line">            &#125;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            sum+=a[i];  </span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LC-97-字符串交错"><a href="#LC-97-字符串交错" class="headerlink" title="LC-97.字符串交错"></a><a href="https://leetcode-cn.com/problems/interleaving-string/">LC-97.字符串交错</a></h2><p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</p><p>两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p><p>s = s1 + s2 + … + sn</p><p>t = t1 + t2 + … + tm</p><p>|n - m| &lt;= 1</p><p>交错 是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …</p><p>提示：a + b 意味着字符串 a 和 b 连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">输入：s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;</span><br><span class="line">输出：true</span><br><span class="line">i/j: 0 a a b c c e</span><br><span class="line">  0[T,T,F,F,F,F,F]</span><br><span class="line">  b [F,T,T,F,F,F,F]</span><br><span class="line">  a[F,T,T,F,F,F,F]</span><br><span class="line">  c[F,F,T,T,T,T,T]</span><br><span class="line">  c[F,F,F,F,T,F,T]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 状态定义：f[i][j]表示 s1的前i个元素和s2的前j个元素是否能交错组成 s3的前i+j个元素</span></span><br><span class="line"><span class="comment"> * 转移方程：f[i][j] = (f[i-1][j] &amp;&amp; s1[i-1]==s3[i+j-1]) || (f[i][j-1] &amp;&amp; s2[j-1]==s3[i+j-1]);</span></span><br><span class="line"><span class="comment"> * 初始化：</span></span><br><span class="line"><span class="comment"> *  - f[0][0] = 1</span></span><br><span class="line"><span class="comment"> *  - f[i][0] = f[i-1][0]  &amp;&amp; s1[i-1]==s3[i-1];</span></span><br><span class="line"><span class="comment"> *  - f[0][j] = f[0][j-1]  &amp;&amp; s2[j-1]==s3[j-1];</span></span><br><span class="line"><span class="comment"> * 最终结果：f[n][m] </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s1.<span class="built_in">size</span>(), m=s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>( n+m != s3.<span class="built_in">size</span>() )  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector &lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">f</span>(n+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)  f[i][<span class="number">0</span>]= f[i<span class="number">-1</span>][<span class="number">0</span>] &amp;&amp; s1[i<span class="number">-1</span>]==s3[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; ++j)  f[<span class="number">0</span>][j]= f[<span class="number">0</span>][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>]==s3[j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; ++j)&#123;</span><br><span class="line">                f[i][j] = (f[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]) || (f[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="高频面试系列"><a href="#高频面试系列" class="headerlink" title="高频面试系列"></a>高频面试系列</h1><h2 id="寻找素数"><a href="#寻找素数" class="headerlink" title="寻找素数"></a>寻找素数</h2><p> <a href="https://leetcode-cn.com/problems/count-primes/">LC-204. 计数质数</a></p><p>统计所有小于非负整数 <em>n</em> 的质数的数量。[如果⼀个数如果只能被 1 和它本⾝整除，那么这个数就是素数]</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 5 * 10^6</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Eratosthenes筛选法</span></span><br><span class="line"><span class="comment"> * 从2开始遍历到n</span></span><br><span class="line"><span class="comment"> * i=2,并排除2的倍数</span></span><br><span class="line"><span class="comment"> * i=3,并排除3的倍数</span></span><br><span class="line"><span class="comment"> * i=5,并排除5的倍数</span></span><br><span class="line"><span class="comment"> * 。。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始默认所有数为质数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i) &#123;</span><br><span class="line">                    <span class="comment">//排除i的倍数</span></span><br><span class="line">                    res[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="模幂运算"><a href="#模幂运算" class="headerlink" title="模幂运算"></a>模幂运算</h2><p><a href="https://leetcode-cn.com/problems/super-pow/">LC-372. 超级次方</a></p><p>你的任务是计算 <code>ab</code> 对 <code>1337</code> 取模，<code>a</code> 是一个正整数，<code>b</code> 是一个非常大的正整数且会以数组形式给出。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = [3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = [1,0]</span><br><span class="line">输出：1024</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 1, b = [4,3,3,8,5,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2147483647, b = [2,0,0]</span><br><span class="line">输出：1198</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a &lt;= 231 - 1</code></li><li><code>1 &lt;= b.length &lt;= 2000</code></li><li><code>0 &lt;= b[i] &lt;= 9</code></li><li><code>b</code> 不含前导 0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1337</span>;</span><br><span class="line">    <span class="comment">//求 a 的 k 次方， 对 mod 取余</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">modPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        a %= mod;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            res *= a;</span><br><span class="line">            res %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">size</span>() == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = b.<span class="built_in">back</span>();</span><br><span class="line">        b.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 将原问题化简，缩小规模递归求解</span></span><br><span class="line">        <span class="keyword">int</span> part1 = <span class="built_in">modPow</span>(a, last);</span><br><span class="line">        <span class="keyword">int</span> part2 = <span class="built_in">modPow</span>(<span class="built_in">superPow</span>(a, b), <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 合并出结果</span></span><br><span class="line">        <span class="keyword">return</span> (part1 * part2)%mod;</span><br><span class="line">        <span class="comment">// return (modPow(a, last) * modPow(superPow(a, b), 10)) % mod;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1337</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">modPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        a %= mod;</span><br><span class="line">        <span class="comment">// k 是奇数</span></span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>)  <span class="keyword">return</span> (a * <span class="built_in">modPow</span>(a, k - <span class="number">1</span>)) % mod;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// k 是偶数</span></span><br><span class="line">            <span class="keyword">int</span> sub = <span class="built_in">modPow</span>(a, k / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> (sub * sub) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="pa-3-寻找最靠左的匹配子串-1"><a href="#pa-3-寻找最靠左的匹配子串-1" class="headerlink" title="pa-3.寻找最靠左的匹配子串"></a>pa-3.寻找最靠左的匹配子串</h2><p><a href="#%5Bpa-3.%E5%AF%BB%E6%89%BE%E6%9C%80%E9%9D%A0%E5%B7%A6%E7%9A%84%E5%8C%B9%E9%85%8D%E5%AD%90%E4%B8%B2%5D(https://www.papamelon.com/problem/3)">跳转</a></p><h2 id="pa-4-长度为-K-的回文子串"><a href="#pa-4-长度为-K-的回文子串" class="headerlink" title="pa-4.长度为 K 的回文子串"></a><a href="https://www.papamelon.com/problem/4">pa-4.长度为 K 的回文子串</a></h2><p><img src="/2021/02/21/Algorithm/pa-4.png" alt="pa-4"></p><p>样例 1</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6 3</span><br><span class="line">acdcxb</span><br><span class="line">6 5</span><br><span class="line">acdcxb</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试用例 20/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left]!=s[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> left++,right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+k<span class="number">-1</span>&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i,i+k<span class="number">-1</span>))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 字符串哈希 O(1)</span></span><br><span class="line"><span class="comment">* https://www.bilibili.com/video/BV1Tv41157YX?p=5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line">ull p[N];           <span class="comment">//k的幂次</span></span><br><span class="line">ull h0[N], h1[N];   <span class="comment">// 从左到右扫描，维护所有前缀的映射值（哈希值）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  h0[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">    h0[i] = h0[i - <span class="number">1</span>] * P + s[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">//idx 对应的是 s 的 n - i + 1 下标</span></span><br><span class="line">    <span class="keyword">int</span> idx = n - i + <span class="number">1</span>;</span><br><span class="line">    h1[i] = h1[i - <span class="number">1</span>] * P + s[idx];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">query0</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> h0[r] - h0[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function">ull <span class="title">query1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> h1[r] - h1[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  cin&gt;&gt;s;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">init</span>();   <span class="comment">//预处理哈希值，幂次</span></span><br><span class="line">  <span class="comment">//枚举回文串的左端点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + m - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> half = m &gt;&gt; <span class="number">1</span>;   <span class="comment">//int half = m/2;</span></span><br><span class="line">    ull ret1 = <span class="built_in">query0</span>(i, i + half - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = n - (i + m - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = n - (i + m - half) + <span class="number">1</span>;</span><br><span class="line">    ull ret2 = <span class="built_in">query1</span>(l, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret1 == ret2) &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  cin&gt;&gt;T;</span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-29-回文平方数"><a href="#pa-29-回文平方数" class="headerlink" title="pa-29.回文平方数"></a><a href="https://www.papamelon.com/problem/29">pa-29.回文平方数</a></h2><p>Palindromic Squares</p><p>回文数是指从左向右念和从右向左念都一样的数。如 1232112321 就是一个典型的回文数。</p><p>给定一个用十进制正整数 B<em>B</em>，在 [1, 300]中寻找所有特殊的整数 <em>X</em>，满足 X^2用 B进制表示时是回文数。</p><p>其中，2≤B≤20。大于 9 的数，用字母表示。例如用 A表示 10，B表示 11，用第 n个大写字母表示 n+9。</p><p> 输入</p><ul><li>输入一个正整数 B, 2≤B≤20</li></ul><p> 输出</p><ul><li>输出多行，每行分左右两部分，用空格隔开<ul><li>左边的部分是 [1,300] 内的一个正整数 X的 B进制表示</li><li>右边的部分是 X^2 的 B进制表示</li></ul></li><li>输出的数据按左部分的十进制值从小到大排序</li></ul><p>样例 1</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">2 4</span><br><span class="line">3 9</span><br><span class="line">11 121</span><br><span class="line">22 484</span><br><span class="line">26 676</span><br><span class="line">101 10201</span><br><span class="line">111 12321</span><br><span class="line">121 14641</span><br><span class="line">202 40804</span><br><span class="line">212 44944</span><br><span class="line">264 69696</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 十进制转 K 进制：短除法</span></span><br><span class="line"><span class="comment"> * 实际上就是一个不断模 K 除 K 的过程。我们可以举一个实际的例子，将 345 转成 6 进制数</span></span><br><span class="line"><span class="comment"> * 346÷6=57...4</span></span><br><span class="line"><span class="comment"> * 57÷6=9...3</span></span><br><span class="line"><span class="comment"> * 9÷6=1...3</span></span><br><span class="line"><span class="comment"> * 1÷6=0...1</span></span><br><span class="line"><span class="comment"> * 当商等于 0 时算法停止，然后我们将余数逆序保存，得到 1334，这就是对应的 6 进制表达</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="comment">//回文串判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left]!=s[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> left++,right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进制转换</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">char</span>&gt; <span class="title">tobint</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">char</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=a%b;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;<span class="number">9</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&#x27;A&#x27;</span>+tmp<span class="number">-10</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//int强转char--&gt; char(intval+48)</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in"><span class="keyword">char</span></span>(tmp+<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        a=a/b; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">300</span>;++i)&#123;</span><br><span class="line">        vector&lt;<span class="keyword">char</span>&gt; vec1=<span class="built_in">tobint</span>(i*i,b);</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="built_in">check</span>(vec1,<span class="number">0</span>,vec1.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">char</span>&gt; vec0=<span class="built_in">tobint</span>(i,b);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it0=vec0.<span class="built_in">begin</span>();it0!=vec0.<span class="built_in">end</span>();++it0)&#123;</span><br><span class="line">                cout&lt;&lt;*it0;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it1=vec1.<span class="built_in">begin</span>();it1!=vec1.<span class="built_in">end</span>();++it1)&#123;</span><br><span class="line">                cout&lt;&lt;*it1;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-30-双重回文数"><a href="#pa-30-双重回文数" class="headerlink" title="pa-30.双重回文数"></a><a href="https://www.papamelon.com/problem/30/submissions">pa-30.双重回文数</a></h2><p>Dual Palindromes</p><p>从左往右读和从右往左读都一样的数字叫做 <strong>回文数</strong>。例如，12321就是一个回文数，而 77778 就不是。</p><p>当然，回文数的首和尾都应是非零的，因此 0220不是回文数。</p><p>有一些数，例如 21，在十进制时不是回文数，但在其它进制，如二进制时为 10101时是回文数。</p><p>给定两个十进制数 n,s，然后找出前 n个满足大于 s且在不少于两种进制（二进制至十进制）上是回文数的十进制数。</p><p>本问题的解决方案不需要使用大于 32 位的整型数</p><p> 输入</p><ul><li>只有一行，用空格隔开的两个正整数 n,s, 1≤<em>n</em>≤15,1≤<em>s</em>≤9999。</li></ul><p> 输出</p><ul><li>n行, 每行一个满足上述要求的数，并按从小到大的顺序输出。</li></ul><p>样例 1</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 25</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 s+1 开始枚举</span></span><br><span class="line"><span class="comment"> * 对于每个数字，从二进制到十进制枚举，将该数转换为对应进制下的值，再看看这个值是否为回文数</span></span><br><span class="line"><span class="comment"> * 如果有至少两个进制下的值是回文数，该数就是双重回文数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="comment">//回文串判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left]!=s[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> left++,right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进制转换</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tobint</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(a%b);</span><br><span class="line">        a=a/b; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力枚举</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>,k=<span class="number">0</span>;k&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;=<span class="number">10</span>&amp;&amp;count&lt;<span class="number">2</span>; ++j)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec = <span class="built_in">tobint</span>(i,j);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(vec, <span class="number">0</span>, vec.<span class="built_in">size</span>()<span class="number">-1</span>))  count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">2</span>)&#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-27-挤牛奶"><a href="#pa-27-挤牛奶" class="headerlink" title="pa-27.挤牛奶"></a><a href="https://www.papamelon.com/problem/27/submissions">pa-27.挤牛奶</a></h2><p>这是一个关于农夫和奶牛的问题，直接来看一个实际的例子：</p><ul><li>第一个农民在 [300, 1000) 秒给奶牛挤奶</li><li>第二个农民在 [700, 1200) 秒给奶牛挤奶</li><li>第三个农民在 [1500, 2100) 秒给奶牛挤奶</li></ul><p>期间最长的至少有一个农民在挤奶的连续时间为 900 秒 (也就是 [300, 1200) 秒)。</p><p>而最长的无人挤奶的连续时间为 300 秒 (也就是 [1200, 1500) 秒)。</p><p>你的任务是编一个程序，读入 n个农民的工作时间列表，计算以下两点(均以秒为单位):</p><ul><li>最长至少有一人在挤奶的时间段。</li><li>最长的无人挤奶的时间段。（从有人挤奶开始算起）</li></ul><p> 输入</p><ul><li>第一行一个正整数 n, 1 ≤<em>n</em>≤5000</li><li>接下来 n行，每行两个非负整数 l,r，表示一个农民的工作时间。</li></ul><p> 输出</p><ul><li>一行，两个整数，即题目所要求的两个答案。</li></ul><p>样例 1</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">300 1000</span><br><span class="line">700 1200</span><br><span class="line">1500 2100</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">900 300</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  【经典的区间合并问题】</span></span><br><span class="line"><span class="comment"> * 我们把农民工作的时候看作区间，每个区间用 [start_i, end_i) 表示</span></span><br><span class="line"><span class="comment"> * 对所有区间按左端点从小到大排序</span></span><br><span class="line"><span class="comment"> * 挨个遍历这些区间，并且维护一个 “当前合并区间” S，用 [resa, reab) 表示 S 的左右端点</span></span><br><span class="line"><span class="comment"> * 当遍历到第一个区间的时候，它就是 S，即 resa=start_0, resb=end_0</span></span><br><span class="line"><span class="comment"> * 当遍历到一个新区间，可能出现两种情况：</span></span><br><span class="line"><span class="comment"> *    start_i &lt;= resb, 合并区间 S，并更新右端点，resb=max(end_i, resb)</span></span><br><span class="line"><span class="comment"> *    start_i &gt; resb,  将 S 保存下来,重置区间S的左右端点，resa=start_i, resb=end_i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector &lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; ma, mi;</span><br><span class="line"><span class="keyword">int</span> resa, resb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    resa=vec[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    resb=vec[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    ma.<span class="built_in">push_back</span>(resb-resa);</span><br><span class="line">    mi.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i][<span class="number">0</span>] &lt;= resb)&#123;</span><br><span class="line">            resb=<span class="built_in">max</span>(vec[i][<span class="number">1</span>],resb);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ma.<span class="built_in">push_back</span>(resb-resa);</span><br><span class="line">            mi.<span class="built_in">push_back</span>(vec[i][<span class="number">0</span>]-resb);</span><br><span class="line">            resa=vec[i][<span class="number">0</span>];</span><br><span class="line">            resb=vec[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ma.<span class="built_in">push_back</span>(vec[n<span class="number">-1</span>][<span class="number">1</span>]-vec[n<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">    cout&lt;&lt;*<span class="built_in">max_element</span>(ma.<span class="built_in">begin</span>(),ma.<span class="built_in">end</span>()) &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; *<span class="built_in">max_element</span>(mi.<span class="built_in">begin</span>(),mi.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line">        cin &gt;&gt; start &gt;&gt; end;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(&#123;start, end&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-19-后缀0"><a href="#pa-19-后缀0" class="headerlink" title="pa-19.后缀0"></a><a href="https://www.papamelon.com/problem/19">pa-19.后缀0</a></h2><p>小棒瓜瓜得到了一个正整数 n，他需要计算 n，即要计算 1 * 2 * 3 * 4 … * n。最后让我们统计一下，这个结果有多少个后缀 0，也就是从结果的末尾往前数有多少个连续的 0。</p><p><strong>输入</strong></p><p>第一行是整数 T, 1≤T≤1000，表示接下来有 T 组数据</p><p>接下来有 TT 行，每行一个整数 n, 1≤n≤1000，表示要我们统计 n! 的后缀 0 数量</p><p><strong>输出</strong></p><p>输出 T 行，每行一个整数，表示 n! 的后缀 0 的数量</p><p>样例 1<br>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><blockquote><p> 提示<br>4 的阶乘是 24，后缀 0 数量为 0<br>8 的阶乘为 40320，后缀 0 的数量为 1</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 容斥原理</span></span><br><span class="line"><span class="comment"> * 有一对【2，5】才能产生一个 0</span></span><br><span class="line"><span class="comment"> * 在每 5 个数为一组的区间， 2^x  5^y  ====&gt; x &gt; y</span></span><br><span class="line"><span class="comment"> * 最后求[0,n]中 5 的幂次方的个数 5^a, 25^b, 125^c 625^d</span></span><br><span class="line"><span class="comment"> * 后缀0的个数即为 a+b+c+d</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>, base=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span>(base &lt;= n)&#123;</span><br><span class="line">        res += n/base;</span><br><span class="line">        base = base*<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-20-合适篮筐的数量"><a href="#pa-20-合适篮筐的数量" class="headerlink" title="pa-20.合适篮筐的数量"></a><a href="https://www.papamelon.com/problem/20">pa-20.合适篮筐的数量</a></h2><p>小棒瓜瓜现在有 m 个甜美的棒瓜，每个棒瓜都有相应的体积，设第 i 个棒瓜的体积为 v_i</p><p>现在他要寻找一个 合适的篮筐，要求这个 篮筐的容量至少是其中一个棒瓜的体积的整数倍。</p><p>小棒瓜瓜来到集市，发现有 n 个篮筐，这些篮筐的容量恰好是连续的正整数，最小的篮筐容量为 C，最大的篮筐容量为 C + n - 1，也就是说，这些篮筐的容量分别为 [C, C+1, C+2, C+3, … , C+n-1]</p><p>现在他要在这些篮筐中，找出所有合适的篮筐，请你帮忙统计合适的篮筐个数。</p><p>下面来看一个例子</p><p>一共有 3 个棒瓜，它们的体积分别为 [2,3,4]</p><p>集市里有 6 个篮筐，最小篮筐容量为 11，所有的篮筐容量为 [1,2,3,4,5,6]</p><p>合适的篮筐一共有 4 个，包括 [2,3,4,6]，它们的容量至少是一个棒瓜体积的整数倍</p><p><strong>输入</strong></p><ul><li><p>第一行是整数 T, 1≤T≤1000，表示接下来有 T 组数据</p></li><li><p>每组数据位于一行:</p><ul><li><p>前 3 个是正整数 m, n, C，分别表示棒瓜的数量和集市中篮筐的数量，以及最小的篮筐容量，其中 1≤m≤10, 1≤n≤10^6, 1≤C≤10^8</p></li><li><p>接下来是 m 个正整数，表示 m 个棒瓜的体积，设第 i 个棒瓜的体积为 1&lt;=vi&lt;=500,<strong>同时保证所有棒瓜的体积相乘不会超过</strong>10^18</p></li></ul></li></ul><blockquote><p>样例 1<br>输入<br>1<br>3 6 1 2 3 4<br>输出<br>4</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.枚举所有集合重叠的情况 </span></span><br><span class="line"><span class="comment"> *  -所谓的集合，指的是 vi 的倍数</span></span><br><span class="line"><span class="comment"> *  -&#123;v0&#125;, &#123;v1&#125;, &#123;v2&#125; ... &#123;vm-1&#125;</span></span><br><span class="line"><span class="comment"> *  -&#123;v0,v1&#125;, &#123;v0,v2&#125;... &#123;vm-2,vm-1&#125;</span></span><br><span class="line"><span class="comment"> *  -&#123;v0,v1,v2&#125; ... &#123;vm-3,vm-2,vm-1&#125;</span></span><br><span class="line"><span class="comment"> *  - ...</span></span><br><span class="line"><span class="comment"> * 2.计算重叠集合的最小公倍数， LCM = &#123;vi, vj ... vk&#125;,  n/LCM = 重叠集合的大小</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.根据容斥原理， 奇加 偶减</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n ,c;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)  cin &gt;&gt; v[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxs = <span class="number">1</span> &lt;&lt; m; <span class="comment">//总共状态数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s&lt;maxs; ++s)&#123; <span class="comment">//一共maxs-1重状态，s从1开始</span></span><br><span class="line">        ll lcm=<span class="number">1LL</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i) <span class="keyword">if</span> ((s &gt;&gt; i) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// a*b=p*q 最小公倍数于最大公约数的关系</span></span><br><span class="line">            lcm = lcm * v[i] / __gcd(lcm, <span class="number">1LL</span> * v[i]) ; <span class="comment">// &#123;vi, vj ... vk&#125;的最小公倍数</span></span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> count = (c+n<span class="number">-1</span>)/lcm - (c<span class="number">-1</span>)/lcm;</span><br><span class="line">        <span class="keyword">if</span>(cnt &amp;<span class="number">1</span> )  res += count;</span><br><span class="line">        <span class="keyword">else</span> res -= count;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="pa-9-套娃-1"><a href="#pa-9-套娃-1" class="headerlink" title="pa-9.套娃"></a>pa-9.套娃</h2><p><a href="#%5Bpa-9.%E5%A5%97%E5%A8%83%5D(https://www.papamelon.com/problem/9)">跳转</a></p><h2 id="pa-18-套娃II-1"><a href="#pa-18-套娃II-1" class="headerlink" title="pa-18.套娃II"></a>pa-18.套娃II</h2><p><a href="#%5Bpa-18.%E5%A5%97%E5%A8%83II%5D(https://www.papamelon.com/problem/18)">跳转</a></p><h2 id="pa-10-计算第k个排列"><a href="#pa-10-计算第k个排列" class="headerlink" title="pa-10.计算第k个排列"></a><a href="https://www.papamelon.com/problem/10">pa-10.计算第k个排列</a></h2><p>给定我们整数 n，表示我们有 [1,2,3,4 … n-1, n] 这 n 个数字，我们可以构造出 n! 个的升序排序的排列。</p><p>例如，n = 3，所有的排列为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><p>现在再给定我们一个整数 K, 1≤K≤n!，让我们找到第 K 个排列。</p><p>例如，n = 3, K = 1，目标排列是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p> n= 3, K = 3，目标排列是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1 3</span><br></pre></td></tr></table></figure><p><strong>输入</strong></p><p>第一行是整数 T 表示接下来有 T 组 n, K，其中 1≤T≤1000</p><p>接下来有 T 行，每行两个数字用空格分隔，分别为 n, K，1≤n≤20,1≤K≤n!</p><p><strong>输出</strong></p><p>输出 T 行，每行是相应的目标排列，每个数字间用空格相隔，注意每行最后不要输出多余空格</p><p>样例 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">2</span><br><span class="line">3 1</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出:</span><br><span class="line">1 2 3</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-08-11 21:53:14</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-08-12 10:49:45</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">ll f[N+<span class="number">5</span>];         <span class="comment">//计算阶乘 f[i]=!i</span></span><br><span class="line"><span class="keyword">bool</span> visit[N+<span class="number">5</span>];   <span class="comment">//visit[i]=true 表示 i 已经被选到排列中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ll K;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="comment">// 从左到右，按位确认被选中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pos = n; pos&gt;<span class="number">0</span>; pos--) &#123;</span><br><span class="line">        ll sum=<span class="number">0</span>;     <span class="comment">//跳过多少个排列</span></span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">1</span>;    <span class="comment">//选中的元素，pos=n时，每个分组有 f(n-1)个排列</span></span><br><span class="line">        <span class="comment">//确认分组</span></span><br><span class="line">        <span class="keyword">for</span> (; cur &lt;= n; cur++) <span class="keyword">if</span> (!visit[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + f[pos - <span class="number">1</span>] &gt;= K) <span class="keyword">break</span>;</span><br><span class="line">            sum += f[pos - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        visit[cur] = <span class="literal">true</span>;</span><br><span class="line">        cout &lt;&lt; cur &lt;&lt; (pos==<span class="number">1</span> ? <span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        K -= sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) f[i] = f[i - <span class="number">1</span>] * i;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pa-10-计算排列的编号"><a href="#pa-10-计算排列的编号" class="headerlink" title="pa-10.计算排列的编号"></a><a href="https://www.papamelon.com/problem/11">pa-10.计算排列的编号</a></h2><p>给定正整数 n，表示我们有 [1,2,3,4 … n-1, n] 这 n 个数字，我们可以构造出 n! 个升序排序的排列。</p><p>例如，n = 3，所有的排列为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><p>现在，从中选择其中一个排列，计算它的编号，例如：</p><ul><li>以下排列属于第 1 个：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure></li><li>以下排列属于第 3 个:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1 3</span><br></pre></td></tr></table></figure></li><li>以下排列属于第 5 个：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 1 2</span><br></pre></td></tr></table></figure></li><li><em>输入</em>*</li></ul><p>第一行是整数 T，表示接下来有 T 组 排列，其中 1≤T≤10000</p><p>接下来有 T 行，每行的第一个数字为 n, 1≤n≤20，后面跟着 n 个整数，是一个关于 n 的排列，所有数字用空格分 隔</p><p><strong>输出</strong></p><p>输出 T 行，每行表示排列的编号</p><blockquote><p>样例 1</p><p>输入</p><p>2</p><p>3 2 1 3</p><p>3 3 1 2</p><p>输出</p><p>3</p><p>5</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于给定的序列，按位确定</span></span><br><span class="line"><span class="comment"> * 对于当前 a[i]，先计算 a[i] 在可用的元素里面排第几位(count)</span></span><br><span class="line"><span class="comment"> * 对于当前第 i 轮，确认了 a[i] 后，其余元素可以任意排，产生的排列数量是 (n-1-i)!</span></span><br><span class="line"><span class="comment"> * 实际跳过的排列的数量 = (n-1-i)! * count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>; <span class="comment">//标记数组</span></span><br><span class="line">    </span><br><span class="line">    ll skip = <span class="number">0</span>; <span class="comment">//跳过多少个排列</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;  <span class="comment">// a[i] 在可用的数字里面，是第几个</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>; x&lt;=n &amp;&amp; x!=a[i]; x++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[x]) count++;</span><br><span class="line">        skip += f[n<span class="number">-1</span>-i]*count;</span><br><span class="line">        vis[a[i]]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; skip+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; ++i)&#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]*i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-140-公司团建"><a href="#pa-140-公司团建" class="headerlink" title="pa-140.公司团建"></a><a href="https://www.papamelon.com/problem/140">pa-140.公司团建</a></h2><p>公司终于去团建啦！这次参加团建的一共有 n 个小伙伴，为了使得团建可以愉快进行，我们保证 n 一共是 偶数，同时我们希望小伙伴们能两两组队，这样旅途中不会太无聊。</p><p>请你帮忙计算一下，一共有多少种组队方案？</p><p>请注意以下细节</p><p>(A, B) 和 (B,A) 被认为是一个队伍。也就是说，如果 n=2，只有一种组队方案</p><p>匹配后的队伍，并无前后顺序之分，例如 n=4:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以下两种组队方案被认为是同一种</span><br><span class="line">1 2  // 1 2 组队</span><br><span class="line">3 4  // 3 4 组队</span><br><span class="line"></span><br><span class="line">3 4  // 3 4 组队</span><br><span class="line">1 2  // 1 2 组队</span><br></pre></td></tr></table></figure><p><strong>输入</strong></p><p>只有一行，整数 n (2≤n≤16), 保证 n 一定是 <strong>偶数</strong></p><p><strong>输出</strong></p><p>只有一行，表示有多少种组队方案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 所有的组合都可以归结为 a_0(1) &lt; b_i(n-1) a_1(1) &lt; b_i(n-3)...</span></span><br><span class="line"><span class="comment"> * 最后的结果为(n-1)*(n-3)*(n-5)* ... * 1</span></span><br><span class="line"><span class="comment"> * 递推公式 f[i]=f[i-2]*(i-1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> f[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=N; i=i+<span class="number">2</span>)&#123;</span><br><span class="line">        f[i] = f[i<span class="number">-2</span>] * (i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; f[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-141-公司团建II"><a href="#pa-141-公司团建II" class="headerlink" title="pa-141.公司团建II"></a><a href="https://www.papamelon.com/problem/141">pa-141.公司团建II</a></h2><p>题干同140.</p><p><strong>输入</strong></p><ul><li>第一行为整数 T (1≤T≤10000)，表示有 T 组测试数据</li><li>接下来 T行，每行一个整数 n (2≤n≤10^6), 保证 n 一定是 <strong>偶数</strong></li></ul><p><strong>输出</strong></p><ul><li>输出 T行，每行一个整数，表示有多少种组队方案</li><li>结果对 <code>998244353</code> 取模</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多了取模</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">ll f[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=N; i=i+<span class="number">2</span>)&#123;</span><br><span class="line">        f[i] = f[i<span class="number">-2</span>] * (i<span class="number">-1</span>) % <span class="number">998244353</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">   </span><br><span class="line">        cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-15-刷房子"><a href="#pa-15-刷房子" class="headerlink" title="pa-15.刷房子"></a><a href="https://www.papamelon.com/problem/15">pa-15.刷房子</a></h2><p>小棒瓜瓜有 n 个房子排成一排，同时他有红黄蓝三种颜色的油漆。现在他要给每个房子刷上一种颜色的油漆，同时要求任意两个相邻房子的油漆颜色不得相同。</p><p>另外，即便是同一种颜色的油漆，刷不同的房子，所需的花费也是不同的。</p><p>现在我们得到每个房子刷上 33 种油漆的代价，请帮小棒瓜瓜计算一下，为所有房子都刷上油漆且没有任意两个相邻房子的颜色相同的最小总花费。</p><p><strong>输入</strong></p><ul><li><p>第一行是整数 T，表示接下来有 TT 组数据，1≤T≤1000</p></li><li><p>每组数据由 n + 1 行组成，第一行是整数 nn，表示有 n 个房子，1≤n≤10^5</p></li><li><p>接下来是 n 行，每行 3 个正整数。第 i 行的 3 个正整数分别为 cost[i][0], cost[i][1], cost[i][2]，表示给第 i 个房子刷上红黄蓝三种油漆的花费。1≤cost[i][j]≤1000</p></li><li><p>T 组数据中所有 n 的总和为 S, T≤S≤10^6</p></li></ul><p><strong>输出</strong></p><ul><li>输出 T 行，每行一个正整数，表示为所有房子都刷上油漆且没有任意两个相邻房子的颜色相同的最小总花费</li></ul><blockquote><p>样例 1<br>输入<br>3<br>1<br>1 2 3</p><p>2<br>1 2 1<br>2 1 2</p><p>3<br>100 200 300<br>200 300 400<br>1 2 3</p><p>输出<br>1<br>2<br>401</p><p>提示<br>第 3 组测试用例中：<br>第一个房子选用红色油漆，花费为 100<br>第二个房子选用黄色油漆，花费为 300<br>第三个房子选用红色油漆，花费为 1<br>最小总花费为 401</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  DP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; <span class="built_in">x</span>(<span class="number">3</span>,<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 初始状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)  cin &gt;&gt; x[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; ++j)&#123;<span class="comment">// 当前房子颜色状态只与前面房子颜色相关</span></span><br><span class="line">            <span class="keyword">int</span> val;</span><br><span class="line">            cin &gt;&gt; val;</span><br><span class="line">            y[j]=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">3</span>; ++k) <span class="keyword">if</span>(j!=k)&#123; <span class="comment">//当前房子处最小花费</span></span><br><span class="line">                y[j]=<span class="built_in">min</span>(y[j], x[k]+val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);  <span class="comment">// 滚动数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res=INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)&#123;</span><br><span class="line">        res=<span class="built_in">min</span>(res, x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-17-刷房子II"><a href="#pa-17-刷房子II" class="headerlink" title="pa-17.刷房子II"></a><a href="https://www.papamelon.com/problem/17">pa-17.刷房子II</a></h2><p>小棒瓜瓜在完成了第一次 刷房子 任务后，又迎来了第二个任务。</p><p>现在有 n 个房子排成一排，同时有红黄蓝三种颜色的油漆，每种油漆分别有 na, nb, nc 桶。</p><p>刷一个房子要耗费一桶油漆，同时要求任意两个相邻房子的油漆颜色不得相同。</p><p>另外，即便是同一种颜色的油漆，刷不同的房子，所需的花费也是不同的。</p><p>现在我们得到每个房子刷上 3 种油漆的代价，请帮小棒瓜瓜计算一下，为所有房子都刷上油漆且没有任意两个相邻房子的颜色相同的总花费是多少。</p><p>如果无法为每个房子都刷上油漆，花费为 -1</p><p><strong>输入</strong></p><p>第一行是整数 T，表示接下来有 T 组数据，1≤T≤10</p><p>每组数据由 n + 1 行组成</p><p>第一行是整数 n, na, nb, nc，表示有 n 个房子，红黄蓝油漆的桶数分别为 na, nb, nc, 1≤n,na,nb,nc≤25，</p><p>接下来是 n 行，每行 3 个正整数。第 i 行的 3 个正整数分别为 cost[i][0], cost[i][1], cost[i][2]，表示给第 i 个房子刷上红黄蓝三种油漆的花费。1≤cost[i][j]≤1000</p><p><strong>输出</strong></p><p>输出 T 行，每行一个正整数，表示为所有房子都刷上油漆且没有任意两个相邻房子的颜色相同的最小花费</p><p>如果无法为所有房子都刷上油漆，输出 -1</p><blockquote><p>样例 1<br>输入<br>1<br>3 1 1 1<br>1 5 10<br>15 2 20<br>25 30 3</p><p>输出<br>6</p><p>提示<br>第一个房子选择红色油漆，花费为 1<br>第二个房子选择黄色油漆，花费为 2<br>第三个房子选择蓝色油漆，花费为 3<br>总花费为 6</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  DP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">4</span>][N][N][N], vis[N][<span class="number">4</span>][N][N][N];</span><br><span class="line"><span class="keyword">int</span> n, cnt[<span class="number">3</span>], cost[N][<span class="number">3</span>];<span class="comment">//房子数量n 每个颜料数量 cnt[i] 花费数组cost[n][i];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==n) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果计算过 直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vis[cur][col][cnt[<span class="number">0</span>]][cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]])</span><br><span class="line">        <span class="keyword">return</span> f[cur][col][cnt[<span class="number">0</span>]][cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">     vis[cur][col][cnt[<span class="number">0</span>]][cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span>&amp; res = f[cur][col][cnt[<span class="number">0</span>]][cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]];<span class="comment">//引用</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;<span class="number">3</span>; c++) <span class="keyword">if</span>(c !=col &amp;&amp; cnt[c] )&#123; <span class="comment">//颜料使用限制条件</span></span><br><span class="line">         cnt[c]--;</span><br><span class="line">         res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(cur+<span class="number">1</span>, c) + cost[cur][c]);</span><br><span class="line">         cnt[c]++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)   cin &gt;&gt; cnt[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; ++j)</span><br><span class="line">            cin &gt;&gt; cost[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f3f3f3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(res == INF)  res=<span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-153-平面分割"><a href="#pa-153-平面分割" class="headerlink" title="pa-153.平面分割"></a><a href="https://www.papamelon.com/problem/153">pa-153.平面分割</a></h2><p>平面上有 n 条直线，最多把平面切割成多少块?</p><p>输入</p><p>多组测试数据，以 EOF 结束</p><p>每组测试数据一个整数 n (0≤n≤500)</p><p>输出</p><p>每组测试数据输出一个整数，表示最多把平面切割成多少块</p><p>提示</p><p>当 n=0 时，表示平面上没有直线，平面被视为一整块，答案是 1</p><blockquote><p>样例 1<br>输入<br>1<br>2</p><p>输出<br>2<br>4</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 先枚举，找找规律</span></span><br><span class="line"><span class="comment"> * f[0]=1</span></span><br><span class="line"><span class="comment"> * f[i] = f[i-1] + i （i≥1）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> f[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; ++i)&#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ( cin&gt;&gt;n )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pa-151-走楼梯"><a href="#pa-151-走楼梯" class="headerlink" title="pa-151.走楼梯"></a><a href="https://www.papamelon.com/problem/151">pa-151.走楼梯</a></h2><p>我们在地面上，有 n 级楼梯，能让我们上到第 n 层。</p><p>每次我们可以走 1 级或 2 级楼梯。问我们走完 n 级楼梯有多少种方案？</p><p>例：n=3，一共有 3 种可能</p><p>1,1,1，每次走一级，走三步</p><p>1,2，走两步，第一步走一级，第二步走两级</p><p>2,1，走两步，第一步走两级，第二步走一级</p><p><strong>输入</strong><br>一个整数 n(1≤n≤36)，表示有多少级楼梯</p><p><strong>输出</strong><br>一个整数，表示有多少种走法</p><blockquote><p>样例 1<br>输入<br>3</p></blockquote><blockquote><p>输出<br>3</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归，动规</span></span><br><span class="line"><span class="comment"> * f[i]=f[i−1]+f[i−2]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[n];</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>,f[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表-树"><a href="#链表-树" class="headerlink" title="链表/树"></a>链表/树</h1><h2 id="LC-2-两数之和"><a href="#LC-2-两数之和" class="headerlink" title="LC-2.两数之和"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">LC-2.两数之和</a></h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2--&gt;4--&gt;3</span><br><span class="line">5--&gt;6--&gt;4</span><br><span class="line">----------</span><br><span class="line">7--&gt;0--&gt;8</span><br><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]       </span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br><span class="line"></span><br><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br><span class="line"></span><br><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br><span class="line">9--&gt;9--&gt;9--&gt;9--&gt;9--&gt;9--&gt;9</span><br><span class="line">9--&gt;9--&gt;9--&gt;9</span><br><span class="line">-------------------------</span><br><span class="line">8--&gt;9--&gt;9--&gt;9--&gt;0--&gt;0--&gt;0--&gt;1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur = res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( l1 || l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> val1 = l1? l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> val2 = l2? l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = (val1 + val2 +c);</span><br><span class="line">            c = sum/<span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(l1) l1=l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c) cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>); <span class="comment">//最后还有进位的情况，case3</span></span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-141-环形链表"><a href="#LC-141-环形链表" class="headerlink" title="LC-141.环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">LC-141.环形链表</a></h2><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p><strong>进阶：</strong></p><p>你能用 *O(1)*（即，常量）内存解决此问题吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line"> 3--&gt;2--&gt;0--&gt;-4--</span><br><span class="line">  ^           |</span><br><span class="line">  |___________| </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  快慢指针，快指针每次走两步，慢指针每次走一步</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LC-42-环形链表-II"><a href="#LC-42-环形链表-II" class="headerlink" title="LC-42. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">LC-42. 环形链表 II</a></h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O(1) 空间解决此题？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast=head, *slow=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span> || fast-&gt;next==<span class="literal">nullptr</span>)  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快慢指针 fast  slow</span></span><br><span class="line"><span class="comment"> * 链表头到环的长度为 a，环的长度为 b</span></span><br><span class="line"><span class="comment"> * 第一次相遇时：</span></span><br><span class="line"><span class="comment"> *  - fast 走的步数是 slow 步数的 2倍，即 f = 2s</span></span><br><span class="line"><span class="comment"> *  - fast 比 slow 多走了 n 个环的长度，即 f = s + nb</span></span><br><span class="line"><span class="comment"> *  - 可推导得 f = 2s = 2nb</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果让指针从链表头部一直向前走并统计步数 k，那么所有走到链表入口节点时的步数是</span></span><br><span class="line"><span class="comment"> * k = a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）</span></span><br><span class="line"><span class="comment"> * 第一次相遇时 slow 走了 nb 步。因此只要再让 slow 走 a 步停下来，就可以到环的入口</span></span><br><span class="line"><span class="comment"> * 令 fast = head, slow不变，此时： f = 0, s = nb</span></span><br><span class="line"><span class="comment"> * 第二次相遇时：</span></span><br><span class="line"><span class="comment"> *  - f = a, s = a + nb</span></span><br><span class="line"><span class="comment"> * 返回 fast 指针指向的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="JZ-22-链表中倒数第k个节点"><a href="#JZ-22-链表中倒数第k个节点" class="headerlink" title="JZ-22.链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">JZ-22.链表中倒数第k个节点</a></h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *former=head, *latter=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; ++i)&#123;</span><br><span class="line">            former = former-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(former!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            former = former-&gt;next;</span><br><span class="line">            latter = latter-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * head: [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"> * k: 2</span></span><br><span class="line"><span class="comment"> * former: [3,4,5]         [4,5]        [5]          []</span></span><br><span class="line"><span class="comment"> * latter: [1,2,3,4,5]     [2,3,4,5]    [3,4,5]      [4,5]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="LC-146-LRU缓存机制"><a href="#LC-146-LRU缓存机制" class="headerlink" title="LC-146.LRU缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/">LC-146.LRU缓存机制</a></h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><p><strong>进阶</strong>：你是否可以在 O(1) 时间复杂度内完成这两种操作？<strong>双向链表插入、删除时间复杂度 O(1)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure><blockquote><p>提示：</p><ul><li>1 &lt;= capacity &lt;= 3000</li><li>0 &lt;= key &lt;= 10000</li><li>0 &lt;= value &lt;= 10^5</li><li>最多调用 2 * 10^5 次 get 和 put</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">      <span class="keyword">int</span> key, val;</span><br><span class="line">      Node *pre, *next;</span><br><span class="line">      <span class="built_in">Node</span>(<span class="keyword">int</span> k, <span class="keyword">int</span> v)&#123;</span><br><span class="line">          key = k;</span><br><span class="line">          val = v;</span><br><span class="line">          pre = next = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node *head, *tail;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, Node*&gt; pos;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        c = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos.<span class="built_in">count</span>(key)==<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        Node* ptr = pos[key];</span><br><span class="line">        <span class="built_in">remove</span>(ptr);   <span class="comment">//先从双向链表中删除</span></span><br><span class="line">        <span class="built_in">insert</span>(ptr);   <span class="comment">//再插入到head节点后</span></span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos.<span class="built_in">count</span>(key)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//insert (增加节点)</span></span><br><span class="line">            <span class="keyword">if</span>(pos.<span class="built_in">size</span>()==c)&#123;</span><br><span class="line">                Node* ptr = tail-&gt;pre;</span><br><span class="line">                <span class="built_in">remove</span>(ptr);</span><br><span class="line">                pos.<span class="built_in">erase</span>(ptr-&gt;key);</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            Node* ptr = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">            pos[ptr-&gt;key] = ptr;</span><br><span class="line">            <span class="built_in">insert</span>(ptr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update (不会增加节点)</span></span><br><span class="line">        Node* ptr = pos[key];</span><br><span class="line">        ptr-&gt;val = value;</span><br><span class="line">        <span class="built_in">remove</span>(ptr);</span><br><span class="line">        <span class="built_in">insert</span>(ptr); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node* ptr)</span></span>&#123;</span><br><span class="line">        Node* a = ptr-&gt;pre;</span><br><span class="line">        Node* b = ptr-&gt;next;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        b-&gt;pre = a;</span><br><span class="line"></span><br><span class="line">        ptr-&gt;pre = ptr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* ptr)</span></span>&#123;</span><br><span class="line">        Node* a = head-&gt;next;</span><br><span class="line">        a-&gt;pre = ptr;</span><br><span class="line">        ptr-&gt;next = a;</span><br><span class="line">        ptr-&gt;pre = head;</span><br><span class="line">        head-&gt;next= ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span> </span><br></pre></td></tr></table></figure><h2 id="JZ2-53二叉搜索树的中序后继"><a href="#JZ2-53二叉搜索树的中序后继" class="headerlink" title="JZ2-53二叉搜索树的中序后继"></a><a href="https://leetcode-cn.com/problems/P5rCT8/">JZ2-53二叉搜索树的中序后继</a></h2><p>给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null </p><p>节点 p 的后继是值比 p.val 大的节点中键值最小的节点，即按中序遍历的顺序节点 p 的下一个节点</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3], p = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：这里 1 的中序后继是 2</span><br><span class="line"></span><br><span class="line">输入：root = [5,3,6,2,4,null,null,1], p = 6</span><br><span class="line">输出：0</span><br><span class="line">解释：因为给出的节点没有中序后继，所以答案就返回 0</span><br></pre></td></tr></table></figure><p>提示：</p><blockquote><p>树中节点的数目在范围 [1, 104] 内。<br>-105 &lt;= Node.val &lt;= 105<br>树中各节点的值均保证唯一。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 二叉树的中序遍历</span></span><br><span class="line"><span class="comment"> * found 来标记是否已经遍历到节点 p, found 的初始值为 fasle</span></span><br><span class="line"><span class="comment"> * 遍历到节点 p 之后置为 true，在这个变量变为 true 之后第一个遍历到的节点就是结果</span></span><br><span class="line"><span class="comment"> * 二叉搜索树的高度为 h,节点数为 n, 时间复杂度为 O(n)，空间复杂度为 O(h)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">inorderSuccessor</span><span class="params">(TreeNode *root, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; sta;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                sta.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (found)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;val == p)&#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeNode *dummy = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">    TreeNode *tmp = dummy;</span><br><span class="line">    tmp-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    tmp-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">6</span>);</span><br><span class="line">    tmp = tmp-&gt;left;</span><br><span class="line">    tmp-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    tmp-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    tmp = tmp-&gt;left;</span><br><span class="line">    tmp-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    res = <span class="built_in">Solution</span>().<span class="built_in">inorderSuccessor</span>(dummy, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><p>从键盘输入一个string字符串  ‘’m=2,n=3’。现在要把字符串中的数字2和3提取出来分别赋值给两个 int 类型变量 a 和 b</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * c++中引入了流的概念</span></span><br><span class="line"><span class="comment"> * stringstream ss;</span></span><br><span class="line"><span class="comment"> * ss &lt;&lt; t;//向流中传值</span></span><br><span class="line"><span class="comment"> * ss &gt;&gt; res;//向res中写入值，可用作int转string</span></span><br><span class="line"><span class="comment"> * cout &lt;&lt; ss.str(); //cout 输出</span></span><br><span class="line"><span class="comment"> * printf(&quot;%s\n&quot;, ss.str().c_str()); //printf 输出</span></span><br><span class="line"><span class="comment"> * stringstream清空，ss.str(&quot;&quot;);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * getline()函数的定义</span></span><br><span class="line"><span class="comment"> * - istream&amp; getline ( istream &amp;is , string &amp;str , char delim );</span></span><br><span class="line"><span class="comment"> * - is 进行读入操作的输入流 </span></span><br><span class="line"><span class="comment"> * - str 用来存储读入的内容</span></span><br><span class="line"><span class="comment"> * - delim 终结符，遇到该字符停止读取操作，不写的话默认为回车</span></span><br><span class="line"><span class="comment"> * while(getline(cin,str)) 会一直循环，因为回车只会终止getline()函数的读入操作。</span></span><br><span class="line"><span class="comment"> * getline()函数终止后又进行while（）判断（即判断输入流是否有效，你的输入流当然有效，满足条件）</span></span><br><span class="line"><span class="comment"> * 所以又运行getline()函数，导致程序永远跳不出循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">     cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp.<span class="built_in">substr</span>(tmp.<span class="built_in">size</span>()<span class="number">-1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;data.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-01 18:45:34</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-02 10:42:23</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">     cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">int</span> idx = s.<span class="built_in">find</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(<span class="number">2</span>, idx - <span class="number">2</span>));</span><br><span class="line">    n = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(idx + <span class="number">3</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; m &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h2><p>给出一个二维字符数组和一个单词，判断单词是否在数组中出现，</p><p>单词由相邻单元格的字母连接而成，相邻单元指的是上下左右相邻。同一单元格的字母不能多次使用。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给出的字符数组=</span><br><span class="line">[</span><br><span class="line">  [&quot;XYZE&quot;],</span><br><span class="line">  [&quot;SFZS&quot;],</span><br><span class="line">  [&quot;XDEE&quot;]</span><br><span class="line">]</span><br><span class="line">单词 =&quot;XYZZED&quot;, -&gt; 返回 true,</span><br><span class="line">单词 =&quot;SEE&quot;, -&gt;返回 true,</span><br><span class="line">单词 =&quot;XYZY&quot;, -&gt; 返回 fXlse.</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ DFS backtracking 的算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOut</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c&lt;<span class="number">0</span> || c&gt;=cols || r&lt;<span class="number">0</span> || r&gt;=rows;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="keyword">int</span> r, <span class="keyword">int</span> c, string &amp;word, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=word.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isOut</span>(r, c, board.<span class="built_in">size</span>(), board[<span class="number">0</span>].<span class="built_in">size</span>())||word[start]!=board[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dx[]=&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[]=&#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> tmp=board[r][c];</span><br><span class="line">        board[r][c]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">DFS</span>(board, r+dx[i], c+dy[i], word, start+<span class="number">1</span>))</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[r][c]=tmp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt; &gt; &amp;board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows=board.<span class="built_in">size</span>(), cols=board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;rows; ++r)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;cols; ++c)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[r][c]==word[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">DFS</span>(board, r, c, word, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>小汪作为一个有数学天分的程序猿，设计了一套密码生成器来搞定自己的密码问题。<br>密码生成器由N个槽位组成，槽位的下标为0~N-1，每个槽位存储一个数。起初每个槽位都是0。<br>密码生成器会进行M轮计算，每轮计算，小汪会输入两个数L,R(L&lt;=R),密码生成器会将这两个数作为下标，将两个下标之间（包含）的所有槽位赋值为i（i为当前的轮次，i∈[1,M]）。<br>M轮计算完成后，密码生成器会根据槽位的最终值生成一条密码，密码的生成规则为：<br>（0<em>a[0] + 1</em>a[1] + 2*a[2] + … + (N-1)*a[N-1]) mod 100000009<br>其中a[i]表示第i个槽位的最终值。<br>请帮助小汪把他的密码生成器实现为代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lchild(x) ((x) &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rchild(x) (((x) &lt;&lt; 1) + 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">100000009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">9</span>)<span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">op</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="comment">//[l, r]的区间和</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sum</span><span class="params">(ll l, ll r)</span> </span>&#123;<span class="keyword">return</span> (l + r) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> x[maxn &lt;&lt; <span class="number">1</span>], x_size, realx_size, c[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> L, R;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> value, tag_Set;</span><br><span class="line">    &#125;nodes[maxn &lt;&lt; <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">SegmentTree</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(nodes, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(nodes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        nodes[root].value = nodes[<span class="built_in">Lchild</span>(root)].value + nodes[<span class="built_in">Rchild</span>(root)].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        nodes[root].tag_Set = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r)nodes[root].value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">Lchild</span>(root), l, m);</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">Rchild</span>(root), m + <span class="number">1</span>, r);</span><br><span class="line">            <span class="built_in">pushup</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nodes[root].tag_Set) &#123;</span><br><span class="line">            nodes[<span class="built_in">Lchild</span>(root)].tag_Set = nodes[<span class="built_in">Rchild</span>(root)].tag_Set = nodes[root].tag_Set;</span><br><span class="line">            nodes[<span class="built_in">Lchild</span>(root)].value = (m - l + <span class="number">1</span>) * nodes[root].tag_Set;</span><br><span class="line">            nodes[<span class="built_in">Rchild</span>(root)].value = (r - m) * nodes[root].tag_Set;</span><br><span class="line">            nodes[root].tag_Set = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">updateSet</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> curl, <span class="keyword">int</span> curr, <span class="keyword">int</span> tarl, <span class="keyword">int</span> tarr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tarr &lt; curl || curr &lt; tarl)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (tarl &lt;= curl &amp;&amp; curr &lt;= tarr) &#123;</span><br><span class="line">            nodes[root].tag_Set = k;</span><br><span class="line">            nodes[root].value = (curr - curl + <span class="number">1</span>) * k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(root, curl, curr);</span><br><span class="line">        <span class="keyword">int</span> m = (curl + curr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tarl &lt;= m) <span class="built_in">updateSet</span>(<span class="built_in">Lchild</span>(root), curl, m, tarl, tarr, k);</span><br><span class="line">        <span class="keyword">if</span> (tarr &gt; m) <span class="built_in">updateSet</span>(<span class="built_in">Rchild</span>(root), m + <span class="number">1</span>, curr, tarl, tarr, k);</span><br><span class="line">        <span class="built_in">pushup</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> curl, <span class="keyword">int</span> curr, <span class="keyword">int</span> tarl, <span class="keyword">int</span> tarr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tarr &lt; curl || curr &lt; tarl)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tarl &lt;= curl &amp;&amp; curr &lt;= tarr) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodes[root].value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(root, curl, curr);</span><br><span class="line">        <span class="keyword">int</span> m = (curl + curr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tarl &lt;= m) ret += <span class="built_in">query</span>(<span class="built_in">Lchild</span>(root), curl, m, tarl, tarr);</span><br><span class="line">        <span class="keyword">if</span> (tarr &gt; m) ret += <span class="built_in">query</span>(<span class="built_in">Rchild</span>(root), m + <span class="number">1</span>, curr, tarl, tarr);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">SegmentTree tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        x[++x_size] = a[i].l = <span class="built_in">read</span>();</span><br><span class="line">        x[++x_size] = a[i].r = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(x + <span class="number">1</span>, x + x_size + <span class="number">1</span>);</span><br><span class="line">    realx_size = <span class="built_in">unique</span>(x + <span class="number">1</span>, x + x_size + <span class="number">1</span>) - x - <span class="number">1</span>;</span><br><span class="line">    x_size = realx_size;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x_size; ++i)</span><br><span class="line">        <span class="keyword">if</span>(x[i] - x[i - <span class="number">1</span>] &gt; <span class="number">1</span>) x[++realx_size] = x[i] - <span class="number">1</span>, x[++realx_size] = x[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    x_size = realx_size;</span><br><span class="line">    <span class="built_in">sort</span>(x + <span class="number">1</span>, x + x_size + <span class="number">1</span>);</span><br><span class="line">    realx_size = <span class="built_in">unique</span>(x + <span class="number">1</span>, x + x_size + <span class="number">1</span>) - x - <span class="number">1</span>;</span><br><span class="line">    tree.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, realx_size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        L = <span class="built_in">lower_bound</span>(x + <span class="number">1</span>, x + realx_size + <span class="number">1</span>, a[i].l) - x;</span><br><span class="line">        R = <span class="built_in">lower_bound</span>(x + <span class="number">1</span>, x + realx_size + <span class="number">1</span>, a[i].r) - x;</span><br><span class="line">        tree.<span class="built_in">updateSet</span>(<span class="number">1</span>, <span class="number">1</span>, realx_size, L, R, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= realx_size; ++i)</span><br><span class="line">        c[i] = tree.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, realx_size, i, i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; realx_size; ++i)</span><br><span class="line">        ans = (ans + <span class="built_in">sum</span>(x[i], x[i + <span class="number">1</span>] - <span class="number">1</span>) * (<span class="number">1ll</span> * c[i])) % MOD;</span><br><span class="line">    ans = (ans + x[realx_size] * (<span class="number">1ll</span> * c[realx_size])) % MOD;</span><br><span class="line">    <span class="built_in">write</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><strong>寻找连通分量和最大集合数量</strong></p><h1 id="堆-栈"><a href="#堆-栈" class="headerlink" title="堆/栈"></a>堆/栈</h1><h1 id="棋盘-最短路径"><a href="#棋盘-最短路径" class="headerlink" title="棋盘 最短路径"></a>棋盘 最短路径</h1><h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="0831-pdd01"><a href="#0831-pdd01" class="headerlink" title="0831-pdd01"></a>0831-pdd01</h2><p><strong>输入描述：</strong></p><blockquote><p>第一行包含一个整数 T (1&lt;=T&lt;=5)，表示有 T 组数据</p><p>接下俩魅族数据三行输入，第一行包含3个整数 n，m，k(1&lt;=n,m&lt;=10000,0&lt;=k&lt;=100)</p><p>分别表示红色方块数，蓝色方块数和能配对消除的最大数字差异</p><p>第二行包含n个整数，ai（1&lt;=ai&lt;=100）表示第 i 个红色方块上的数字</p><p>第三行包含n个整数，bi（1&lt;=bi&lt;=100）表示第 i 个蓝色方块上的数字</p></blockquote><p><strong>输出描述：</strong></p><blockquote><p>每组数据输出一行ans，表示该剧游戏最多能获得的分数</p></blockquote><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">1</span><br><span class="line">3 4 1</span><br><span class="line">5 2 3</span><br><span class="line">1 2 9 7</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">说明</span><br><span class="line">第1组数据中</span><br><span class="line">第2个红色方块和第1个蓝色方块配对消除</span><br><span class="line">第3个红色方块和第2个蓝色方块配对消除</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-08-31 23:51:48</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-01 15:54:31</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,T;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn],match[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;cin&gt;&gt;a[i];&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;cin&gt;&gt;b[i];&#125;</span><br><span class="line">        <span class="built_in">sort</span>(a,a+n);<span class="built_in">sort</span>(b,b+m);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;m) &#123;</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">abs</span>(a[i]-b[j]) &lt;= k )&#123;</span><br><span class="line">                i++,j++;</span><br><span class="line">                ans ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(b[j]-a[i] &gt; k ) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]-b[j] &gt; k ) j++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0831-pdd02"><a href="#0831-pdd02" class="headerlink" title="0831-pdd02"></a>0831-pdd02</h2><p>一个字符串，长为<code>len</code>，对于<code> 0&lt;= i &lt;= len-1</code>，字符串下标<code>i</code>和<code> len -1 -i</code>可以交换位置</p><p>给定两个字符串 a，b，a的任何状态的字典序小于 b 的任何状态的字典序，则a&lt;b</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">2</span><br><span class="line">dcba</span><br><span class="line">abcd</span><br><span class="line">输出</span><br><span class="line">dcba</span><br><span class="line">abcd</span><br><span class="line">说明：2代表接下来2行输入2个字符串，字典序相等时优先输出先输入的字符串</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">2</span><br><span class="line">abcde</span><br><span class="line">abcdeaf</span><br><span class="line">输出</span><br><span class="line">abcdeaf</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义排序</span></span><br><span class="line"><span class="comment"> * 比较待排序字符串数组的minstring</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minstring</span><span class="params">(string &amp;s)</span></span>&#123; <span class="comment">//传引用，形参修饰实参</span></span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len/<span class="number">2</span>; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[j]&gt;s[len<span class="number">-1</span>-j]) <span class="built_in">swap</span>(s[j],s[len<span class="number">-1</span>-j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(string s1, string s2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">minstring</span>(s1);</span><br><span class="line">    <span class="built_in">minstring</span>(s2);</span><br><span class="line">    <span class="keyword">return</span> s1 &lt; s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)  cin &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        cout &lt;&lt; s[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0831-pdd03"><a href="#0831-pdd03" class="headerlink" title="0831-pdd03"></a>0831-pdd03</h2><p>有n根火柴，最多能拼成多少个1*1的小正方形</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 数学模拟</span></span><br><span class="line"><span class="comment"> * 假设先凑一个边长m的正方形，则一共需要2m(m+1)根火柴</span></span><br><span class="line"><span class="comment"> * 先开根求m，然后一次模拟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll m = <span class="built_in">sqrt</span>(n / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        ll ans = m * m;</span><br><span class="line">        n -= <span class="number">2</span> * (m + <span class="number">1</span>) * m;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//一侧开始外扩</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">3</span>)</span><br><span class="line">                ans++, n -= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">2</span> * m - <span class="number">2</span>)&#123;</span><br><span class="line">                ans += m - <span class="number">1</span>;</span><br><span class="line">                n -= <span class="number">2ll</span> * m - <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans += n / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//另一侧开始外扩</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">3</span>)</span><br><span class="line">                ans++, n -= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">2</span> * m)&#123;</span><br><span class="line">                ans += m;</span><br><span class="line">                n -= <span class="number">2ll</span> * m;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans += n / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0901-小米"><a href="#0901-小米" class="headerlink" title="0901-小米"></a>0901-小米</h2><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">LC-88.合并两个有序数组(小米笔试)</a></p><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br><span class="line"></span><br><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line"></span><br><span class="line">输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><blockquote><ul><li>nums1.length == m + n</li><li>nums2.length == n</li><li>0 &lt;= m, n &lt;= 200</li><li>1 &lt;= m + n &lt;= 200</li><li>-10^9 &lt;= nums1[i], nums2[j] &lt;= 10^9</li></ul></blockquote><p><strong>设计实现一个时间复杂度为 O(m + n) 的算法解决此问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-02 22:12:46</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-02 22:35:20</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt; &amp;nums2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = m + m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span>)</span><br><span class="line">            nums1[len--] = nums2[j--];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">            nums1[len--] = nums1[i--];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j])</span><br><span class="line">            nums1[len--] = nums2[j--];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums1[len--] = nums1[i--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int idx = s.find(&#x27;,&#x27;);</span></span><br><span class="line">    <span class="comment">// m = stoi(s.substr(2, idx - 2));</span></span><br><span class="line">    <span class="comment">// n = stoi(s.substr(idx + 3, s.size() - 1));</span></span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ss,tmp,<span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp.<span class="built_in">substr</span>(<span class="number">2</span>,tmp.<span class="built_in">size</span>()<span class="number">-1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    m = data[<span class="number">0</span>], n=data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(m + n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge</span>(a, m, b, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a[a.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> * m=3,n=3</span></span><br><span class="line"><span class="comment"> * 1 2 3</span></span><br><span class="line"><span class="comment"> * 2 5 6</span></span><br><span class="line"><span class="comment"> * 输出：</span></span><br><span class="line"><span class="comment"> * 1 2 2 3 5 6</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="0906-莉莉丝01"><a href="#0906-莉莉丝01" class="headerlink" title="0906-莉莉丝01"></a>0906-莉莉丝01</h2><p>有一个链表，头节点为head，先要对链表重新排序，排序规则如下，即以链表头元素为初始节点，原链表的节点一次作为新链表的为节点和头节点插入链表，返回新的链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">输入</span><br><span class="line">1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line">输出</span><br><span class="line">5-&gt;3-&gt;1-&gt;2-&gt;4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双向队列 deque</span></span><br><span class="line"><span class="comment"> * 使用dummy节点新建链表 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">formatList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        deque&lt;ListNode *&gt; de;</span><br><span class="line">        de.<span class="built_in">push_back</span>(head);</span><br><span class="line">        ListNode *cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                de.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                de.<span class="built_in">push_front</span>(cur);</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *tmp = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; de.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            tmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(de[i]-&gt;val);</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//新建链表，并输出</span></span><br><span class="line">    <span class="comment">// ListNode *myhead = new ListNode(1);</span></span><br><span class="line">    <span class="comment">// ListNode *a = myhead, *b;</span></span><br><span class="line">    <span class="comment">// for (int i = 2; i &lt; 6; ++i)&#123;</span></span><br><span class="line">    <span class="comment">//     b = new ListNode(i);</span></span><br><span class="line">    <span class="comment">//     a-&gt;next = b;</span></span><br><span class="line">    <span class="comment">//     a = b;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// while (myhead-&gt;next)&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; myhead-&gt;val &lt;&lt; &quot;-&gt;&quot;;</span></span><br><span class="line">    <span class="comment">//     myhead = myhead-&gt;next;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; myhead-&gt;val &lt;&lt; endl;\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode *tmp = dummy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; ++i)&#123;</span><br><span class="line">        tmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i);</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    res = <span class="built_in">Solution</span>().formatList(dummy-&gt;next);</span><br><span class="line">    <span class="keyword">while</span>(res-&gt;next)&#123;</span><br><span class="line">        cout &lt;&lt; res-&gt;val &lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0906-莉莉丝02"><a href="#0906-莉莉丝02" class="headerlink" title="0906-莉莉丝02"></a>0906-莉莉丝02</h2><p>有一个链表，头节点为head，先要对链表重新排序，排序规则如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">输入</span><br><span class="line">2-&gt;1-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出</span><br><span class="line">1-&gt;2-&gt;3-&gt;1-&gt;2</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">3-&gt;2-&gt;3-&gt;1-&gt;1-&gt;3</span><br><span class="line">输出</span><br><span class="line">1-&gt;2-&gt;3-&gt;1-&gt;3-&gt;3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * max_element</span></span><br><span class="line"><span class="comment"> * vector&lt;pair&lt;int, int&gt;&gt; vec</span></span><br><span class="line"><span class="comment"> * 千万别 unordered_map&lt;ListNode*, int&gt; mp</span></span><br><span class="line"><span class="comment"> * 新建链表，输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur)&#123;</span><br><span class="line">            mp[cur-&gt;val]++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : mp)</span><br><span class="line">            vec.<span class="built_in">push_back</span>(it);</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">max_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)&#123; <span class="keyword">return</span> a.second &lt; b.second; &#125;);</span><br><span class="line">        <span class="keyword">int</span> maxnum = it-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)&#123; <span class="keyword">return</span> a.first &lt; b.first; &#125;);</span><br><span class="line"></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *tmp = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxnum; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (vec[j].second &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    tmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(vec[j].first);</span><br><span class="line">                    vec[j].second--;</span><br><span class="line">                    tmp = tmp-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode *tmp = dummy;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">8</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">        tmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(arr[i]);</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    res = <span class="built_in">Solution</span>().<span class="built_in">sortList</span>(dummy-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (res-&gt;next)&#123;</span><br><span class="line">        cout &lt;&lt; res-&gt;val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;2-&gt;4-&gt;2-&gt;4</span></span><br></pre></td></tr></table></figure><h2 id="0907-百度01"><a href="#0907-百度01" class="headerlink" title="0907-百度01"></a>0907-百度01</h2><p>大致题意为：有大小为N的方形矩阵，现将矩阵放大k倍，返回放大后的矩阵</p><p><strong>输入描述</strong></p><p>第一行输入两个整数N，K；接下来N行输入方向矩阵</p><p><strong>输出描述</strong></p><p>输出放大后的矩阵</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">2 2</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br><span class="line">输出</span><br><span class="line">0 0 1 1</span><br><span class="line">0 0 1 1 </span><br><span class="line">1 1 0 0 </span><br><span class="line">1 1 0 0 </span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">3 3</span><br><span class="line">1 0 1</span><br><span class="line">0 0 0</span><br><span class="line">1 0 1</span><br><span class="line">输出</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 模拟 先对列或行进行操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, K;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(N, vector&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            cin &gt;&gt; vec[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(K * N, vector&lt;<span class="keyword">int</span>&gt;(K * N, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; K; ++k)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; K; ++t)&#123;</span><br><span class="line">                    res[i * K + k][j * K + t] = vec[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K * N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K * N; ++j)&#123;</span><br><span class="line">            cout &lt;&lt; res[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0907-百度02"><a href="#0907-百度02" class="headerlink" title="0907-百度02"></a>0907-百度02</h2><p>大致题意为：给定一个整数N，若gcd(x,y)=1，且lcm(x,y)=N，则(x,y)为一对符合要求的答案。如N=30，(1，30)、(2，15)、(3，10)、(5，6)为满足条件的4对数。注：(2，15)和(15，2)为一对符合要求的答案</p><p><strong>输入描述</strong></p><p>第一行给出一个自然数T，表示测试用例的数量</p><p>接下来T行测试用例，每行给出一个自然数N</p><p>1 &lt;= T &lt;= 10^3    1 &lt;= N &lt;= 10^8</p><p><strong>输出描述</strong></p><p>按顺序输出每个测试用例的答案</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">1</span><br><span class="line">30</span><br><span class="line">输出</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">2</span><br><span class="line">16</span><br><span class="line">2021</span><br><span class="line">输出</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gcd(x,y) * lcm(x,y)  = x * y</span></span><br><span class="line"><span class="comment"> * __gcd(x,y)为自带求解最小公约数的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">cin&gt;&gt;N;</span><br><span class="line"><span class="keyword">int</span> count= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="built_in">sqrt</span>(N); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = N/i;</span><br><span class="line">        <span class="keyword">if</span>(__gcd(i,j)==<span class="number">1</span> &amp;&amp; N==i*j)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0911-美团01"><a href="#0911-美团01" class="headerlink" title="0911-美团01"></a>0911-美团01</h2><h2 id="091158-同城01"><a href="#091158-同城01" class="headerlink" title="091158-同城01"></a>091158-同城01</h2><p>输入一个整数数组Array，长度为len，求指定长度sublen子数组和的最大值</p><p>输出最大子数组和以及最大子数组起始下标</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[1, 2, 30, 4, 5, 6, 7, 8, 9, 10], 10, 3</span><br><span class="line">输出</span><br><span class="line">[2， 39]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双指针，滑动窗口</span></span><br><span class="line"><span class="comment"> * left 从0遍历到len-sublen，即[0, len-sublen]</span></span><br><span class="line"><span class="comment"> * right = left + sublen -1</span></span><br><span class="line"><span class="comment"> * 滑动窗口 [left, left+sublen-1]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> len, <span class="keyword">int</span> sublen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxres=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>; left&lt;=len-sublen; left++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=left; i&lt;=left + sublen - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; maxres)&#123;</span><br><span class="line">            maxres = sum;</span><br><span class="line">            res.<span class="built_in">clear</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(i-sublen);</span><br><span class="line">            res.<span class="built_in">push_back</span>(maxres);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">30</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    res = <span class="built_in">maxSub</span>(arr, arr.<span class="built_in">size</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        cout &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0912-巨人网络"><a href="#0912-巨人网络" class="headerlink" title="0912- 巨人网络"></a>0912- 巨人网络</h2><p>【==列数未知==】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">//资源数量</span><br><span class="line">5</span><br><span class="line">//资源编号，大小，依赖资源编号</span><br><span class="line">1001， 5</span><br><span class="line">1002， 10</span><br><span class="line">1000， 3， 1001， 1002</span><br><span class="line">2000， 7</span><br><span class="line">3000， 2， 2000</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">//占用资源最大的资源编号及大小</span><br><span class="line">1000， 18</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;data.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            vec[i][j] = data[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(vec[i].<span class="built_in">size</span>()==<span class="number">2</span>) sum+=vec[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;vec[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; ++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vec[i][j]==vec[k][<span class="number">0</span>])&#123;</span><br><span class="line">                    sum += vec[k][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;vec[i][<span class="number">0</span>],sum+vec[i][<span class="number">1</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), [](vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>]&gt;b[<span class="number">1</span>];&#125;);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; res[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0913-bilibili02"><a href="#0913-bilibili02" class="headerlink" title="0913-bilibili02"></a>0913-bilibili02</h2><p>【==行数，列数未知==】</p><p>给定一个二维数组，每行严格递增，找出在这些行中出现的最小的元素，如没有输出-1</p><p><strong>输入</strong></p><ul><li>每行一个数组，每个数组逗号分隔</li></ul><p><strong>输出</strong></p><ul><li>输出一个整数</li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">1,23,4,5,9</span><br><span class="line">2,4,5,8,9</span><br><span class="line">3,5,7,9,11</span><br><span class="line">1,3,5,7,9</span><br><span class="line">输出</span><br><span class="line">5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-13 18:21:43</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-13 21:52:19</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//判断 整数 n 是否在数组 arr 中出现过</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">find</span>(arr[i])==st.<span class="built_in">end</span>())&#123;</span><br><span class="line">            st.<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> res = st.<span class="built_in">count</span>(n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s))&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//跳出输入</span></span><br><span class="line">        string tmp;</span><br><span class="line">        data.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp));<span class="comment">//先存行</span></span><br><span class="line">        &#125;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(data);<span class="comment">//再存每行数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](vector&lt;<span class="keyword">int</span>&gt; a,vector&lt;<span class="keyword">int</span>&gt; b) &#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vec[<span class="number">0</span>].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;vec.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            flag = flag &amp;&amp; <span class="built_in">contain</span>(vec[j],vec[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) res.<span class="built_in">push_back</span>(vec[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; res[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0916-zoom01"><a href="#0916-zoom01" class="headerlink" title="0916-zoom01"></a>0916-zoom01</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-16 16:39:35</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-17 14:30:04</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 列数未知， 输入一行判断结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">     <span class="keyword">int</span> tmp;</span><br><span class="line">     <span class="keyword">while</span>(cin&gt;&gt;tmp)&#123;</span><br><span class="line">         a.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">         <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;a[i],i+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; a.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; res.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[j].first == a[i])&#123;</span><br><span class="line">                    b = res[j].second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span>&lt;&lt; a[i] &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; res.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[j].first == a[i])&#123;</span><br><span class="line">                    b = res[j].second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span>&lt;&lt; a[i] &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">整理记录刷的算法题，好记性不如烂笔头啊！题解参考了Grand Yang(https://github.com/grandyang)</summary>
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/02/14/hello-world/"/>
    <id>http://example.com/2021/02/14/hello-world/</id>
    <published>2021-02-13T16:00:00.000Z</published>
    <updated>2021-07-24T06:25:23.797Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><p>[TOC]</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-hexo"><a href="#Install-hexo" class="headerlink" title="Install hexo"></a>Install hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="Create-myblog"><a href="#Create-myblog" class="headerlink" title="Create myblog"></a>Create myblog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init myblog</span><br></pre></td></tr></table></figure><p><strong>出现 hexo init 失败问题，<a href="https://blog.csdn.net/qq_43580193/article/details/117341489?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">解决方法</a>替换Github连接</strong></p><h3 id="将Hexo部署到GitHub"><a href="#将Hexo部署到GitHub" class="headerlink" title="将Hexo部署到GitHub"></a>将Hexo部署到GitHub</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git #冒号后面有空格</span><br><span class="line">  repository: git@github.com:xuhuigeren/xuhuigeren.github.io.git  #ssh/https仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><strong>回到 myblog 文件夹中，打开 Git Bash，安装Git部署插件，输入命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><strong>然后分别输入以下三条命令：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   <span class="comment">#清除缓存文件 db.json 和已生成的静态文件 public</span></span><br><span class="line">hexo g       <span class="comment">#生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span></span><br><span class="line">hexo d       <span class="comment">#自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span></span><br></pre></td></tr></table></figure><p><strong>完成以后，打开浏览器，输入 <a href="https://xuhuigeren.github.io/">https://xuhuigeren.github.io</a>  就可以打开你的网页了</strong></p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">Welcome to Hexo</summary>
    
    
    
    <category term="我的博客" scheme="http://example.com/categories/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
