<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Algorithm | 桥头打字员</title><meta name="keywords" content="Algorithm,Leetcode"><meta name="author" content="Henry"><meta name="copyright" content="Henry"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="整理记录刷的算法题，好记性不如烂笔头啊！题解参考了Grand Yang(https:&#x2F;&#x2F;github.com&#x2F;grandyang)">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm">
<meta property="og:url" content="http://example.com/2021/02/21/Algorithm/index.html">
<meta property="og:site_name" content="桥头打字员">
<meta property="og:description" content="整理记录刷的算法题，好记性不如烂笔头啊！题解参考了Grand Yang(https:&#x2F;&#x2F;github.com&#x2F;grandyang)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/60ead34a5132923bf8e4a1b8.jpg">
<meta property="article:published_time" content="2021-02-21T13:32:33.000Z">
<meta property="article:modified_time" content="2021-10-25T02:59:10.757Z">
<meta property="article:author" content="Henry">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/60ead34a5132923bf8e4a1b8.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/02/21/Algorithm/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Algorithm',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-25 10:59:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="桥头打字员" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://pic.imgdb.cn/item/60d1f5ae844ef46bb26cedfb.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/60ead34a5132923bf8e4a1b8.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">桥头打字员</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Algorithm</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-21T13:32:33.000Z" title="发表于 2021-02-21 21:32:33">2021-02-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-25T02:59:10.757Z" title="更新于 2021-10-25 10:59:10">2021-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Algorithm/">Algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Algorithm"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>整理分类做过的 <code>leetcode</code>，好记性不如烂笔头啊~</p>
<p>[TOC]</p>
<h1 id="滑动窗口-双指针"><a href="#滑动窗口-双指针" class="headerlink" title="滑动窗口/双指针"></a>滑动窗口/双指针</h1><p><strong>最短或最长的子串  最多可变k次</strong></p>
<h2 id="LC-3-无重复字符的最长子串"><a href="#LC-3-无重复字符的最长子串" class="headerlink" title="LC-3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LC-3. 无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （一）</span></span><br><span class="line"><span class="comment"> * 这里可以建立一个 HashMap，建立每个字符和其最后出现位置之间的映射</span></span><br><span class="line"><span class="comment"> * 然后定义两个变量 res 和 left，其中 res 用来记录最长无重复子串的长度</span></span><br><span class="line"><span class="comment"> * left 指向该无重复子串左边的起始位置的前一个，所以初始化就是 -1</span></span><br><span class="line"><span class="comment"> * 然后遍历整个字符串，对于每一个遍历到的字符，如果该字符已经在 HashMap 中存在了，</span></span><br><span class="line"><span class="comment"> * 并且如果其映射值大于 left 的话，那么更新 left 为当前映射值。然后映射值更新为当前坐标i，</span></span><br><span class="line"><span class="comment"> * 这样保证了 left 始终为当前边界的前一个位置，然后计算窗口长度的时候，直接用 i-left 即可，</span></span><br><span class="line"><span class="comment"> * 用来更新结果 res。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">-1</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(s[i]) &amp;&amp; m[s[i]] &gt; left) &#123;</span><br><span class="line">                left = m[s[i]];  </span><br><span class="line">            &#125;</span><br><span class="line">            m[s[i]] = i;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - left);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种解法使用了 <code>HashSet</code>，核心算法和上面的很类似，把出现过的字符都放入<code>HashSet</code>中，遇到 <code>HashSet </code>中没有的字符就加入<code> HashSet</code> 中并更新结果 <code>res</code>，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （二）</span></span><br><span class="line"><span class="comment"> * 下面这种解法使用了 HashSet，核心算法和上面的很类似，</span></span><br><span class="line"><span class="comment"> * 把出现过的字符都放入 HashSet 中，遇到 HashSet 中没有的字符就加入 HashSet</span></span><br><span class="line"><span class="comment"> * 并更新结果 res，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, res=<span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">find</span>(s[i])!=st.<span class="built_in">end</span>())&#123;</span><br><span class="line">                st.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">            res=<span class="built_in">max</span>(res,i-left+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LC-76-最小覆盖子串"><a href="#LC-76-最小覆盖子串" class="headerlink" title="LC-76. 最小覆盖子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">LC-76. 最小覆盖子串</a></h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p> <strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 105</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<p>这道题给了我们一个原字符串<code>s</code>，还有一个目标字符串<code>t</code>，让在<code>s</code>中找到一个最短的子串，使得其包含了<code>t</code>中的所有的字母，并且限制了时间复杂度为<code> O(n)</code>。这道题的要求是要在<code>O(n) </code>的时间度里实现找到这个最小窗口字串，暴力搜索 <code>Brute Force </code>肯定是不能用的，因为遍历所有的子串的时间复杂度是平方级的。那么来想一下，时间复杂度卡的这么严，说明必须在一次遍历中完成任务，当然遍历若干次也是<code> O(n)</code>，但不一定有这个必要，尝试就一次遍历拿下！那么再来想，既然要包含T中所有的字母，那么对于T中的每个字母，肯定要快速查找是否在子串中，既然总时间都卡在了<code> O(n)</code>，肯定不想在这里还浪费时间，就用空间换时间（也就算法题中可以这么干了，七老八十的富翁就算用大别野也换不来时间啊。依依东望，望的就是时间呐），使用<code> HashMap</code>，建立T中每个字母与其出现次数之间的映射。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * step1: 确定右边界</span></span><br><span class="line"><span class="comment"> * 先用 HashMap 统计好 t 串中字母的，再遍历 s 串，对于 s 中的每个字母</span></span><br><span class="line"><span class="comment"> * 都将 HashMap 中的映射值减1，如果减1后的映射值仍大于等于0，说明当前遍历到的字母是 t 串中的字母</span></span><br><span class="line"><span class="comment"> * 使用 cnt++ 记录。当cnt 和 t 串字母个数相等时，说明此时的窗口已经包含了 t 串中的所有字母</span></span><br><span class="line"><span class="comment"> * step2: 收缩左边界</span></span><br><span class="line"><span class="comment"> * 由于遍历的时候，映射值减了1，所以此时去除字母的时候，就要把减去的1加回来，</span></span><br><span class="line"><span class="comment"> * 此时如果加1后的值大于0了，说明当前遍历到的字母是 t 串中的字母，</span></span><br><span class="line"><span class="comment"> * 那么 cnt 值就要减1了，然后移动左边界left</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; letterCnt;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++letterCnt[c];         <span class="comment">//遍历t</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--letterCnt[s[i]] &gt;= <span class="number">0</span>) ++cnt;   <span class="comment">//--letterCnt[s[i]] &gt;= 0，s[i]在t中</span></span><br><span class="line">            <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                    res = s.<span class="built_in">substr</span>(left, minLen); <span class="comment">//从left开始，长度为minLen的字符串</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收缩左边界 ++letterCnt[s[left]] &gt; 0， 0-&gt;1 该元素在t中，</span></span><br><span class="line">                <span class="keyword">if</span> (++letterCnt[s[left]] &gt; <span class="number">0</span>) --cnt;   </span><br><span class="line">                <span class="comment">//因为不在t中的本来为0，先减去，现在再增加，最终还是0.</span></span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="pa-3-寻找最靠左的匹配子串"><a href="#pa-3-寻找最靠左的匹配子串" class="headerlink" title="pa-3.寻找最靠左的匹配子串"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/3">pa-3.寻找最靠左的匹配子串</a></h2><p>给定一个字符串 A 长度为 N，1 &lt;= N &lt;= 2*10^5，下标从 0 开始标号，仅包含 0 到 9 这十种字符。</p>
<p>再给定另一个字符串 B，长度为 M，1 &lt;= M &lt;= 2*10^5，下标从 0 开始标号，也是仅包含 0 到 9 这十种字符。</p>
<p>例如以下字符串就是一个合法的 A或 B</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">066465353473034515</span><br></pre></td></tr></table></figure>

<p>现在我们要在 A寻找一个连续的子串 s，使得 s包含 B中出现的所有字符，且要保证 s的<strong>长度尽可能短</strong>。如果存在多个符合上述条件的 s，<strong>返回最靠左</strong>的那个。</p>
<p>例如:</p>
<ul>
<li>B串：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3314</span><br></pre></td></tr></table></figure>

<ul>
<li>A串：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">563145633</span><br></pre></td></tr></table></figure>

<p>子串 A[2:7]为 <code>314563</code>，包含了 B串中出现的 <code>3</code>, <code>3</code>, <code>1</code>, <code>4</code>。</p>
<p>子串 A[3:8]为 <code>145633</code>，也包含了 B串中出现的 <code>3</code>, <code>3</code>, <code>1</code>, <code>4</code>。</p>
<p>两个子串长度一样，而前者更靠左，因此前者就是我们要找的答案。</p>
<p><strong>输入</strong></p>
<ul>
<li>每组测试数据的第一行是整数 T，$1 \leq T \leq 1000$，表示接下来有 T对 A, B串</li>
<li>接下来有 $2*T$行，每两行分别表示一对 A串和 B串</li>
<li>A<em>A</em> 串长度为 N，1 &lt;= N &lt;= 2*10^5</li>
<li>B<em>B</em> 串长度为 M，1 &lt;= M &lt;= 2*10^5</li>
<li>一组测试数据中字符总数为 C，  2 * T  &lt;= C &lt;= 2*10^6</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>输出 T行，每行两个整数，用空格分割，表示 A的子串下标</li>
<li>如果不存在这样的合法子串，输出 <code>-1 -1</code></li>
</ul>
<p>样例 1</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">563145633</span><br><span class="line">3314</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>样例 2</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">678</span><br><span class="line">123</span><br><span class="line">12345</span><br><span class="line">1233</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 -1</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （一）</span></span><br><span class="line"><span class="comment"> * 核心算法继承LC-76，先确定右边界再收缩左边界</span></span><br><span class="line"><span class="comment"> * 需要注意输入输出的练习</span></span><br><span class="line"><span class="comment"> * if else规范书写，一个小bug调式了好久</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s, t;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++mp[c];        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--mp[s[i]] &gt;= <span class="number">0</span>) ++cnt;   </span><br><span class="line">            <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                    res.<span class="built_in">clear</span>();</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;left,left+minLen<span class="number">-1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++mp[s[left]] &gt; <span class="number">0</span>) --cnt;   </span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-1</span> &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; res[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>  &lt;&lt; res[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">Solution</span>().<span class="built_in">minWindow</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （二）</span></span><br><span class="line"><span class="comment"> * 核心算法继承LC-76，</span></span><br><span class="line"><span class="comment"> * 代码稍微简洁，逻辑不变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s, t;</span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++mp[c];         </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--mp[s[i]] &gt;= <span class="number">0</span>) ++cnt;   </span><br><span class="line">        <span class="keyword">while</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                res.<span class="built_in">clear</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;left,left+minLen<span class="number">-1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++mp[s[left]] &gt; <span class="number">0</span>) --cnt;   </span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return res;</span></span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-1</span> &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; res[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>  &lt;&lt; res[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="pa-191-优雅地分割字符串"><a href="#pa-191-优雅地分割字符串" class="headerlink" title="pa-191.优雅地分割字符串"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/191">pa-191.优雅地分割字符串</a></h2><p>给定一个只包含小写字母的字符串，长度不超过 100000</p>
<p>将字符串分割成左右两半，要求左右两半的字符种类完全相等（个数可以不同）。</p>
<p>有多少种不同的分割方式？</p>
<p><strong>输入</strong></p>
<ul>
<li>多组测试数据，以 <code>EOF</code> 结束</li>
<li>每组测试数据一行字符串，仅包含小写字母，长度不超过 100000</li>
<li>多组测试数据的字符串长度总和不超过 100000</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>每组测试数据输出一行，一行一个整数，表示有多少种切割方式</li>
</ul>
<p>**样例 **</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">abcabc</span><br><span class="line">aaaa</span><br><span class="line">acbbbca</span><br><span class="line">输出</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-11-11 20:31:38</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-11-11 22:14:00</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">l</span><span class="params">(<span class="number">26</span>, INF)</span>, <span class="title">r</span><span class="params">(<span class="number">26</span>, <span class="number">-1</span>)</span>, <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// l[i] 第 i 个字符首次出现在 s 中的位置</span></span><br><span class="line">    <span class="comment">// r[i] 第 i 个字符最后出现在 s 中的位置</span></span><br><span class="line">    <span class="comment">// cnt[i] 第 i 个字符出现了多少次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = s[i] - <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// 在字母表中位置</span></span><br><span class="line">        l[k] = <span class="built_in">min</span>(l[k], i);</span><br><span class="line">        r[k] = <span class="built_in">max</span>(r[k], i);</span><br><span class="line">        cnt[k]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>, maxl = <span class="number">-1</span>, minr = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span> (cnt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i] == <span class="number">1</span>) &#123; <span class="comment">//只出现一次的字符 不满足</span></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxl = <span class="built_in">max</span>(maxl, l[i]);</span><br><span class="line">        minr = <span class="built_in">min</span>(minr, r[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割位置一定在 [maxl, minr)</span></span><br><span class="line">    <span class="comment">// max&#123;la, lb, lc ... lz&#125;  min&#123;ra, rb, rc ... rz&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (!flag || minr &lt; maxl) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minr - maxl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s) <span class="built_in">solve</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC-1-两数之和"><a href="#LC-1-两数之和" class="headerlink" title="LC-1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">LC-1. 两数之和</a></h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em>target</em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （一）</span></span><br><span class="line"><span class="comment"> * 笨方法</span></span><br><span class="line"><span class="comment"> * 最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</span></span><br><span class="line"><span class="comment"> * 当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，</span></span><br><span class="line"><span class="comment"> * 因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(target== nums[i]+nums[j])&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** （二）</span></span><br><span class="line"><span class="comment"> * 注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，</span></span><br><span class="line"><span class="comment"> * 能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</span></span><br><span class="line"><span class="comment"> * 使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)。</span></span><br><span class="line"><span class="comment"> * 这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，</span></span><br><span class="line"><span class="comment"> * 即可保证不会让 x 和自己匹配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(target-nums[i])!=mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(mp.<span class="built_in">find</span>(target-nums[i])-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mp.insert(pair&lt;int, int&gt;(nums[i], i));</span></span><br><span class="line">            mp[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （三）再精简一下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, m[target - nums[i]]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="LC-15-三数之和"><a href="#LC-15-三数之和" class="headerlink" title="LC-15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">LC-15. 三数之和</a></h2><p>难度中等3545收藏分享切换为英文接收动态反馈</p>
<p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序+双指针</span></span><br><span class="line"><span class="comment"> * 固定第一个数，转化为求两数之和</span></span><br><span class="line"><span class="comment"> * 特别注意相邻元素去重</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">3</span>)   <span class="keyword">return</span> &#123;&#125;;          <span class="comment">// 特判</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;res;            <span class="comment">// 保存结果（所有不重复的三元组）</span></span><br><span class="line">        std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// 排序（默认递增）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)      <span class="comment">// 固定第一个数，转化为求两数之和</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)  <span class="keyword">return</span> res; <span class="comment">// 第一个数大于 0，后面都是递增正数，不可能相加为零</span></span><br><span class="line">            <span class="comment">// 去重：如果此数已经选取过，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 双指针在nums[i]后面的区间中寻找和为0-nums[i]的另外两个数</span></span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] &gt; -nums[i])</span><br><span class="line">                    right--;    <span class="comment">// 两数之和太大，右指针左移</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; -nums[i])</span><br><span class="line">                    left++;     <span class="comment">// 两数之和太小，左指针右移</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 找到一个和为零的三元组，添加到结果中，左右指针内缩，继续寻找</span></span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="comment">// 去重：第二个数和第三个数也不重复选取</span></span><br><span class="line">                    <span class="comment">// 例如：[-4,1,1,1,2,3,3,3], i=0, left=1, right=5</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">-1</span>])  left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>])    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LC-40-组合总和-II"><a href="#LC-40-组合总和-II" class="headerlink" title="LC-40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">LC-40. 组合总和 II</a></h2><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p><strong>注意：</strong>解集不能包含重复的组合。 </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,2,2],</span><br><span class="line">[5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 100</code></li>
<li><code>1 &lt;= candidates[i] &lt;= 50</code></li>
<li><code>1 &lt;= target &lt;= 30</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回溯+剪枝</span></span><br><span class="line"><span class="comment"> * 特别注意相邻元素去重</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; target-candidates[i] &gt;= <span class="number">0</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; index &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//处理节点</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            <span class="built_in">backtrack</span>(candidates, target-candidates[i], i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯，撤销处理结果</span></span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//对candidates先排序</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LC-451-根据字符出现频率排序"><a href="#LC-451-根据字符出现频率排序" class="headerlink" title="LC-451.根据字符出现频率排序"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">LC-451.根据字符出现频率排序</a></h2><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<p>示例 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line">输出:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line">解释:</span><br><span class="line">&#x27;e&#x27;出现两次，&#x27;r&#x27;和&#x27;t&#x27;都只出现一次。</span><br><span class="line">因此&#x27;e&#x27;必须出现在&#x27;r&#x27;和&#x27;t&#x27;之前。此外，&quot;eetr&quot;也是一个有效的答案。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line">输出:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line">解释:</span><br><span class="line">&#x27;c&#x27;和&#x27;a&#x27;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。</span><br><span class="line">注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line">输出:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line">解释:</span><br><span class="line">此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。</span><br><span class="line">注意&#x27;A&#x27;和&#x27;a&#x27;被认为是两种不同的字符。。</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表记录每个字符出现的频率，将字符去重后存入列表</span></span><br><span class="line"><span class="comment"> * 再将列表中的字符按照频率降序排序</span></span><br><span class="line"><span class="comment"> * 生成排序后的字符串时，遍历列表中的每个字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:s) mp[it]++;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; vec; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) vec.<span class="built_in">push_back</span>(it);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;b)&#123;<span class="keyword">return</span> a.second &gt; b.second;&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [ch, num] : vec) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vector&lt;pair&lt;int,int&gt; &gt;vec</span></span><br><span class="line"><span class="comment"> * vec.push_back(make_pair&lt;int,int&gt;(10,50));</span></span><br><span class="line"><span class="comment"> * vec.push_back(make_pair(20,30));</span></span><br><span class="line"><span class="comment"> * vector&lt;pair&lt;int,int&gt;&gt; ::iterator iter;</span></span><br><span class="line"><span class="comment"> * for(iter=vec.begin();iter!=vec.end();iter++);</span></span><br><span class="line"><span class="comment"> * 第一个数据:(*iter).first</span></span><br><span class="line"><span class="comment"> * 第二个数据:(*iter).second</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="LC-165-比较版本号"><a href="#LC-165-比较版本号" class="headerlink" title="LC-165.比较版本号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/compare-version-numbers/">LC-165.比较版本号</a></h2><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p>
<p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p>
<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p>
<p>返回规则如下：</p>
<blockquote>
<ul>
<li>如果 version1 &gt; version2 返回 1，</li>
<li>如果 version1 &lt; version2 返回 -1，</li>
<li>除此之外返回 0。</li>
</ul>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：忽略前导零，&quot;01&quot; 和 &quot;001&quot; 都表示相同的整数 &quot;1&quot;</span><br><span class="line"></span><br><span class="line">输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：version1 没有指定下标为 2 的修订号，即视为 &quot;0&quot;</span><br><span class="line"></span><br><span class="line">输入：version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：version1 中下标为 0 的修订号是 &quot;0&quot;，version2 中下标为 0 的修订号是 &quot;1&quot; 。0 &lt; 1，所以 version1 &lt; version2</span><br><span class="line"></span><br><span class="line">输入：version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = version1.<span class="built_in">length</span>(), m = version2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n || j &lt; m) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; n &amp;&amp; version1[i] != <span class="string">&#x27;.&#x27;</span>; ++i) &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + version1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i; <span class="comment">// 跳过点号</span></span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; m &amp;&amp; version2[j] != <span class="string">&#x27;.&#x27;</span>; ++j) &#123;</span><br><span class="line">                y = y * <span class="number">10</span> + version2[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++j; <span class="comment">// 跳过点号</span></span><br><span class="line">            <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">                <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  stringstream + getline 分割</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">strtoint</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res1 = <span class="built_in">strtoint</span>(version1);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res2 = <span class="built_in">strtoint</span>(version2);</span><br><span class="line">        <span class="keyword">while</span>(res1.<span class="built_in">size</span>()&lt;res2.<span class="built_in">size</span>())  res1.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(res1.<span class="built_in">size</span>()&gt;res2.<span class="built_in">size</span>())  res2.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res1.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res1[i]&gt;res2[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(res1[i]&lt;res2[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="LC-136-只出现一次的数字"><a href="#LC-136-只出现一次的数字" class="headerlink" title="LC-136.只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">LC-136.只出现一次的数字</a></h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>**示例 **</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: 位运算</span></span><br><span class="line"><span class="comment"> * 任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a</span></span><br><span class="line"><span class="comment"> * 任何数和其自身做异或运算，结果是 0，即 a⊕a=0</span></span><br><span class="line"><span class="comment"> * 异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<p>给定一个数组，从数组中查找左右对称相加的和等于k的最长子数组</p>
<p>示例</p>
<p>arr = [2,4,4,5,10,5,6,9,8]   k=10</p>
<p>res = [4,5,10,5,6]</p>
<p>arr = [2,6,7,10,2,5,6,9]   k=12</p>
<p>res = [6,7,10,2,5,6]</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/yushiyi6453/article/details/76407640">时间复杂度</a></h2><p><img src="/2021/02/21/Algorithm/Projects\Gits\hexo\myblog\source_posts\Algorithm\排序.png" alt="排序"></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>快速排序稳定性</strong><br>快速排序是不稳定的算法，它不满足稳定算法的定义。</p>
<blockquote>
<p>算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的</p>
</blockquote>
<p><strong>快速排序时间复杂度</strong><br>快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)。<br>这句话很好理解：假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？至少lg(N+1)次，最多N次。</p>
<blockquote>
<ul>
<li>为什么最少是lg(N+1)次？快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。</li>
<li> 为什么最多是N次？这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。</li>
<li>在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，它就是一棵斜树。此时需要执行n‐1次递归调用，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是枢轴的位置，因此比较次数为 n(n-1)/2,最终其时间复杂度为O(n2)</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quicksort</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=left, j=right;</span><br><span class="line">        <span class="keyword">int</span> rd = <span class="built_in">rand</span>()%(right-left+<span class="number">1</span>)+left;</span><br><span class="line">        <span class="built_in">swap</span>(arr[rd], arr[right]);</span><br><span class="line">        <span class="comment">// 先以最右侧元素为基准</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// 先从左往右遍历</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[right]) i++;</span><br><span class="line">            <span class="comment">// 再从右往左遍历</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[right]) j--;</span><br><span class="line">            <span class="comment">// i所指元素小于基准，j所指元素大于基准</span></span><br><span class="line">            <span class="comment">// 交换i和j的元素</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">            <span class="comment">// 循环进行，直到i和j指向同一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不稳定性发生在中枢元素与a[i]交换的时刻</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[right]); <span class="comment">// 将基准元素换到循环停止的位置</span></span><br><span class="line">        <span class="comment">// 此时基准左边全小于它的数，右边全是大于它的数</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">partition</span>(arr,left,right);</span><br><span class="line">            <span class="built_in">quick_sort</span>(arr,left,t<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">quick_sort</span>(arr,t+<span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>原理</strong></p>
<blockquote>
<p>冒泡排序从小到大排序：一开始交换的区间为0~N-1，将第1个数和第2个数进行比较，前面大于后面，交换两个数，否则不交换。再比较第2个数和第三个数，前面大于后面，交换两个数否则不交换。依次进行，最大的数会放在数组最后的位置。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一维数组作为参数</span></span><br><span class="line"><span class="comment"> * int sum_arr (int att[] , int size)</span></span><br><span class="line"><span class="comment"> * int sum_arr (int *att , int size)</span></span><br><span class="line"><span class="comment"> * array[]为待排序数组，n为数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=array[j];</span><br><span class="line">                array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>原理</strong></p>
<blockquote>
<p>选择排序从小到大排序：一开始从0~ n-1区间上选择一个最小值，将其放在位置0上，然后在1~n-1范围上选取最小值放在位置1上。重复过程直到剩下最后一个元素，数组即为有序。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//array[]为待排序数组，n为数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j ,min ,k;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min=i; <span class="comment">//每趟排序最小值先等于第一个数，遍历剩下的数</span></span><br><span class="line">        <span class="keyword">for</span>( j=i+<span class="number">1</span>; j&lt;n; j++) <span class="comment">//从i下一个数开始检查</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[min]&gt;array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            k=array[min];</span><br><span class="line">            array[min]=array[i];</span><br><span class="line">            array[i]=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>原理</strong></p>
<blockquote>
<p>每一轮都会从输入地数据里移除一个元素，并将其正确地插入已经排好顺序地那个范围之内。至于移除是哪一个元素，则可以随机选取，直至将所有地元素都处理完为止。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insersort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, v;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">        v = a[i];</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span>(a[j<span class="number">-1</span>]&gt;v&amp;&amp;j&gt;=<span class="number">1</span> )&#123;</span><br><span class="line">            a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>原理</strong></p>
<blockquote>
<p>希尔排序也叫递减增量排序，是对插入排序的推广。对于本身已经基本上拍好顺序的数组来说，插入排序的处理效率比较高，而希尔排序可以视为跨度为n的插入排序。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n)</span>  <span class="comment">//希尔排序函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, step;</span><br><span class="line">	<span class="keyword">for</span> (step = n / <span class="number">2</span>; step &gt; <span class="number">0</span>; step = step / <span class="number">2</span>)&#123; <span class="comment">//这里的step步长是根据元素情况定义的</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; step; i++)&#123;  <span class="comment">//i是子数组的编号</span></span><br><span class="line">			<span class="keyword">for</span> (j = i + step; j &lt; n; j = j + step)&#123;  <span class="comment">//数组下标j，数组步长下标j+step</span></span><br><span class="line">				<span class="keyword">if</span> (array[j] &lt; array[j - step])&#123;</span><br><span class="line">					<span class="keyword">int</span> temp = array[j];  <span class="comment">//把数组下标j的值放到temp中</span></span><br><span class="line">					<span class="keyword">int</span> k = j - step;</span><br><span class="line">					<span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; temp &lt; array[k])&#123;</span><br><span class="line">						array[k + step] = array[k];  <span class="comment">//把大的值往后插入</span></span><br><span class="line">						k = k - step;</span><br><span class="line">					&#125;</span><br><span class="line">					array[k + step] = temp;  <span class="comment">//把小的值往前插入</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>原理</strong></p>
<blockquote>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
</blockquote>
<p><strong>算法描述</strong></p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#实现归并，并把数据都放在list1里面 </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merging</span><span class="params">(<span class="keyword">int</span> *list1, <span class="keyword">int</span> list1_size, <span class="keyword">int</span> *list2,  <span class="keyword">int</span> list2_size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>, m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp[MAXSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; list1_size &amp;&amp; j &lt; list2_size)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1[i]&lt;list2[j])&#123;</span><br><span class="line">            temp[k++] = list1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp[k++] = list2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;list1_size)&#123;</span><br><span class="line">        temp[k++] = list1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;list2_size)&#123;</span><br><span class="line">        temp[k++] = list2[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>; m &lt; (list1_size+list2_size); m++)&#123;</span><br><span class="line">        list1[m]=temp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果有剩下的，那么说明就是它是比前面的数组都大的，直接加入就可以了 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> *list1 = array;</span><br><span class="line">        <span class="keyword">int</span> list1_size = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> *list2 = array + n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> list2_size = n-list1_size;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">mergeSort</span>(list1, list1_size);</span><br><span class="line">        <span class="built_in">mergeSort</span>(list2, list2_size);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">merging</span>(list1, list1_size, list2, list2_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序复杂度分析：一趟归并需要将待排序列中的所有记录  </span></span><br><span class="line"><span class="comment">//扫描一遍，因此耗费时间为O(n),而由完全二叉树的深度可知，  </span></span><br><span class="line"><span class="comment">//整个归并排序需要进行[log2n],因此，总的时间复杂度为  </span></span><br><span class="line"><span class="comment">//O(nlogn),而且这是归并排序算法中平均的时间性能  </span></span><br><span class="line"><span class="comment">//空间复杂度：由于归并过程中需要与原始记录序列同样数量级的  </span></span><br><span class="line"><span class="comment">//存储空间去存放归并结果及递归深度为log2N的栈空间，因此空间  </span></span><br><span class="line"><span class="comment">//复杂度为O(n+logN)  </span></span><br><span class="line"><span class="comment">//也就是说，归并排序是一种比较占内存，但却效率高且稳定的算法 </span></span><br></pre></td></tr></table></figure>



<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="LC-122-买卖股票的最佳时机-II"><a href="#LC-122-买卖股票的最佳时机-II" class="headerlink" title="LC-122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LC-122. 买卖股票的最佳时机 II</a></h2><p>难度简单1290收藏分享切换为英文接收动态反馈</p>
<p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 10^4</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10^4</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="pa-9-套娃"><a href="#pa-9-套娃" class="headerlink" title="pa-9.套娃"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/9">pa-9.套娃</a></h2><p>小棒瓜瓜有 n个套娃，设第 i个套娃的体积为v_i，大套娃可以套住小套娃，同时要满足以下条件：</p>
<ul>
<li>一个大套娃想要套住另一个小套娃，体积至少是其 3 倍；例如大套娃体积为 10，小套娃体积为 3，前者是后者的 3.333… 倍，可以套住</li>
<li>一个大套娃只能套住一个小套娃，一旦套住后，小套娃不能再套其他更小的套娃，也就是说不能继续嵌套下去</li>
<li>当大套娃套住小套娃后，小套娃不再可见</li>
</ul>
<p>现在我们要帮小棒瓜瓜选择一种最优的套娃方案，使得最终可见的套娃数量最少。</p>
<p><strong>输入</strong></p>
<ul>
<li>第一行输入整数 T,  1 &lt;= T &lt;=1000，表示接下来有 T组数据</li>
<li>接下来有 T行，每行表示一组套娃的信息</li>
<li>对于每组套娃，第一个整数是 n，表示套娃数量，1 &lt;= n &lt;= 600；后面跟着 n个正整数，用空格分隔，表示每个套娃的体积，第 i个整数为 v_i, 1 &lt;= v_i &lt;= 10000​</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>输出 T行，每行一个整数，表示 T组套娃经过操作，可见套娃的最小数量</li>
</ul>
<p>样例 1</p>
<p><strong>输入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 1 3 7</span><br><span class="line">3 1 2 3</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>





<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  |-----------------|------------------|</span></span><br><span class="line"><span class="comment"> * a[0]              a[n/2]             a[n-1]</span></span><br><span class="line"><span class="comment"> * 根据条件2，一个大娃只能套一个小娃，所以最终可见套娃数量最少为 n/2</span></span><br><span class="line"><span class="comment"> * 所以小娃在前半部分，大娃在后半部分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n ;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        a.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> res = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n/<span class="number">2</span> &amp;&amp; j&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]/a[i] &gt;=<span class="number">3</span>)&#123;</span><br><span class="line">            res--;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> j++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pa-18-套娃II"><a href="#pa-18-套娃II" class="headerlink" title="pa-18.套娃II"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/18">pa-18.套娃II</a></h2><p>小棒瓜瓜在第一次得到 <a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/9">套娃</a> 玩具后，喜欢上了这种玩具，这次他准备用行李箱上带着套娃去旅游。</p>
<p>现在有 n个套娃，设第 i 个套娃的体积为 v_i，大套娃可以套住小套娃，同时要满足以下条件：</p>
<ul>
<li>一个大套娃想要套住另一个小套娃，体积至少是其 33 倍；例如大套娃体积为 10，小套娃体积为 3，前者是后者的 3.333… 倍，可以套住</li>
<li>一个大套娃只能套住一个小套娃，一旦套住后，小套娃不能再套其他更小的套娃，也就是说不能继续嵌套下去</li>
<li>当大套娃套住小套娃后，两者的体积就是大套娃的体积</li>
</ul>
<p>小棒瓜瓜有一个行李箱，它的容积是 C，希望能用行李箱装下 <strong>最多数量</strong> 的套娃，在能装下最多套娃的情况下，选择 <strong>占用空间最小</strong> 的方案。</p>
<p>来看一下实际的例子：</p>
<p>有 66 个套娃，它们的体积分别为[1,3,4,3,12,10]，行李箱的容积为 16</p>
<p> <strong>第一种方案</strong></p>
<ul>
<li>第三个套娃能套住第一个套娃，套住后两者体积为 4</li>
<li>第五个套娃能套住第二个套娃，套住后两者体积为 12</li>
<li>最终选择 4 个套娃，总体积为 16</li>
</ul>
<p> <strong>第二种方案</strong></p>
<ul>
<li>第二个套娃能套住第一个套娃，套住后两者体积为 3</li>
<li>第六个套娃能套住第四个套娃，套住后两者体积为 10</li>
<li>最终选择 4 个套娃，总体积为 13</li>
</ul>
<p><strong>第三种方案</strong></p>
<ul>
<li>第二个套娃能套住第一个套娃，套住后两者体积为 3</li>
<li>再选择第三，四个套娃，它们两个不套住其他的任何套娃，也不被别人套住，共占用体积 7</li>
<li>最终选择 4 个套娃，总体积为 10</li>
</ul>
<p>上述方案能带走的套娃数量是最多的，而第三种方案占用空间更小，选择第三种方案。</p>
<p> <strong>输入</strong></p>
<ul>
<li><p>第一行输入整数 T, ,1≤ T ≤100，表示接下来有 T 组数据</p>
</li>
<li><p>接下来有 T 行，每行表示套娃和行李箱的信息</p>
<ul>
<li>第一个整数是 n, 1≤ n ≤12，表示套娃数量</li>
<li>第二个整数为 C, 1≤ C ≤105，表示行李箱容积</li>
<li>后面跟着 n个正整数，用空格分隔，表示每个套娃的体积，第 i 个整数为 v_i, 1≤ vi ≤10000</li>
</ul>
</li>
</ul>
<p> <strong>输出</strong></p>
<ul>
<li>输出 T 行，每行两个整数，表示最多能带走多少个套娃，以及保证套娃数量最多的情况下，占用的最小空间</li>
</ul>
<p>样例 1</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">6 16 1 3 4 3 12 10</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 10</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 二进制枚举外部套娃</span></span><br><span class="line"><span class="comment"> * 2. 枚举未选中的套娃</span></span><br><span class="line"><span class="comment"> * 3. 双指针得出最小体积</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> T, n, C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; C;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)  cin &gt;&gt; a[i] ;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxcount=<span class="number">0</span>, mincap=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxstate = <span class="number">1</span>&lt;&lt;n;  <span class="comment">// 2^n方种状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始状态压缩枚举, 枚举 2^n方种状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;maxstate; ++s)&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visted</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>, cap=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (s&gt;&gt;i) &amp; <span class="number">1</span> )&#123; <span class="comment">//第 i 个外围套娃被选中</span></span><br><span class="line">                b.<span class="built_in">push_back</span>(i);</span><br><span class="line">                count++;</span><br><span class="line">                cap += a[i];</span><br><span class="line">                visted[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cap &gt; C) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; i&lt;n &amp;&amp; j&lt;b.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visted[i])&#123;</span><br><span class="line">                <span class="comment">//从未被选中的套娃里面依次判断是否可以放入外围套娃中</span></span><br><span class="line">                <span class="keyword">while</span>( j&lt;b.<span class="built_in">size</span>() &amp;&amp; a[i]*<span class="number">3</span> &gt; a[b[j]]) j++;</span><br><span class="line">                <span class="keyword">if</span>( j&lt;b.<span class="built_in">size</span>())  count++, j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新结果</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; maxcount || (count==maxcount &amp;&amp; cap &lt; mincap))&#123;</span><br><span class="line">                maxcount = count;</span><br><span class="line">                mincap = cap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxcout==<span class="number">0</span>)  mincap=<span class="number">0</span>; <span class="comment">//特例输出</span></span><br><span class="line">    cout &lt;&lt; maxcount &lt;&lt; <span class="string">&quot;　&quot;</span> &lt;&lt; mincap &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pa-201-部分和问题"><a href="#pa-201-部分和问题" class="headerlink" title="pa-201.部分和问题"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/201">pa-201.部分和问题</a></h2><p>给定 n个整数，判断是否能选出若干个数，使得它们的和恰好为 k。</p>
<p><strong>输入</strong></p>
<ul>
<li>多组测试数据，以 <code>EOF</code> 结束</li>
<li>每组测试数据由以下部分组成：<ul>
<li>第一行为整数 n (1≤n≤20)</li>
<li>第二行为 n 个整数 a_i (−10^8 ≤a_i≤ 10^8)</li>
<li>第三行为整数 k (−10^8 ≤k≤ 10^8)</li>
</ul>
</li>
<li>数据保证多组测试数据的 n 之和不超过 2020</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>每组测试输出一行，<code>Yes</code> 表示能成功，<code>No</code> 表示失败</li>
</ul>
<p><strong>样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">4</span><br><span class="line">1 2 4 7</span><br><span class="line">13</span><br><span class="line">4</span><br><span class="line">1 2 4 7</span><br><span class="line">15</span><br><span class="line">输出</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-11-16 10:14:16</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-11-16 10:36:03</span></span><br><span class="line"><span class="comment"> * @Description: 暴力枚举，搜索，状态压缩</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxs = <span class="number">1</span> &lt;&lt; n;    <span class="comment">// 2^n方 种状态</span></span><br><span class="line">    <span class="comment">//开始状态压缩枚举, 枚举 2^n方种状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; maxs; ++s) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            <span class="keyword">if</span> ((s &gt;&gt; i) &amp; <span class="number">1</span>) sum += a[i]; <span class="comment">//第 i 个数字被选中</span></span><br><span class="line">        <span class="keyword">if</span> (sum == k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="built_in">solve</span>();</span><br><span class="line">        cout &lt;&lt; (ret ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS/BFS"></a>DFS/BFS</h1><h2 id="LC-200-岛屿数量"><a href="#LC-200-岛屿数量" class="headerlink" title="LC-200.岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">LC-200.岛屿数量</a></h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<blockquote>
<p>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 300<br>grid(i)(j)的值为 ‘0’ 或 ‘1’</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. dfs+备忘录</span></span><br><span class="line"><span class="comment"> * 2. 枚举未选中的套娃</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; vis;  <span class="comment">//标记数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> dc[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; g, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; ++k)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = i + dr[k];</span><br><span class="line">            <span class="keyword">int</span> c = j + dc[k];</span><br><span class="line">            <span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;=n || c&lt;<span class="number">0</span> || c&gt;=m || g[r][c]==<span class="string">&#x27;0&#x27;</span> || vis[r][c])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(g, r, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        n = g.<span class="built_in">size</span>();</span><br><span class="line">        m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vis.<span class="built_in">assign</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[i][j]==<span class="literal">false</span> &amp;&amp; g[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    <span class="built_in">dfs</span>(g, i ,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. dfs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; g, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= g.<span class="built_in">size</span>() || j &gt;= g[<span class="number">0</span>].<span class="built_in">size</span>() || g[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        g[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//上下左右</span></span><br><span class="line">        <span class="built_in">dfs</span>(g, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(g, i, j + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(g, i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(g, i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = g.<span class="built_in">size</span>(),n = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(g, i, j);</span><br><span class="line">                    res ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LC-42-接雨水"><a href="#LC-42-接雨水" class="headerlink" title="LC-42.接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">LC-42.接雨水</a></h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="/2021/02/21/Algorithm/Projects\Gits\hexo\myblog\source_posts\Algorithm\接雨水.png" alt="接雨水"></p>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br><span class="line"></span><br><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>1 &lt;= n &lt;= 2 * 104</code></li>
<li><code>0 &lt;= height[i] &lt;= 105</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 维护一个单调递减的栈，使用栈来存储条形块的索引下标</span></span><br><span class="line"><span class="comment"> * 遍历数组：当栈非空且h[st.top()]&lt;h[i])</span></span><br><span class="line"><span class="comment"> * 意味着栈中元素可以被弹出。弹出栈顶元素 top</span></span><br><span class="line"><span class="comment"> * 计算当前元素和栈顶元素的距离，准备进行填充操作,distance = right-left-1</span></span><br><span class="line"><span class="comment"> * 找出界定高度,height = min(h[right], h[left])-h[cur]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;h.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="comment">// 如果栈不空并且当前索引位置的高度大于栈顶高度就一直循环</span></span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; h[st.<span class="built_in">top</span>()]&lt;h[i])&#123;</span><br><span class="line">                <span class="comment">// 栈顶的小元素出栈</span></span><br><span class="line">                <span class="keyword">int</span> cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">int</span> right = i;</span><br><span class="line">                <span class="keyword">int</span> height = <span class="built_in">min</span>(h[right], h[left])-h[cur];</span><br><span class="line">                <span class="keyword">int</span> distance = right-left<span class="number">-1</span>;</span><br><span class="line">                res = res + distance * height;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双指针，一次遍历</span></span><br><span class="line"><span class="comment"> * 初始化left 指针为 0 并且right 指针为 size-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = h.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_max =<span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h[left]&lt;h[right])&#123;</span><br><span class="line">                h[left]&gt;=left_max ? (left_max=h[left]) : res +=(left_max-h[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                h[right]&gt;=right_max ? (right_max=h[right]) : res += (right_max-h[right]);</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h1><h2 id="LC-5-最长回文子串"><a href="#LC-5-最长回文子串" class="headerlink" title="LC-5. 最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">LC-5. 最长回文子串</a></h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= s.length &lt;= 1000</code></p>
</li>
<li><p><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （一）中心扩展法</span></span><br><span class="line"><span class="comment"> * 由于回文串的长度可奇可偶，比如 “bob” 是奇数形式的回文，”noon” 就是偶数形式的回文，</span></span><br><span class="line"><span class="comment"> * 两种形式的回文都要搜索，对于奇数形式的，我们就从遍历到的位置为中心，向两边进行扩散，</span></span><br><span class="line"><span class="comment"> * 对于偶数情况，我们就把当前位置和下一个位置当作偶数行回文的最中间两个字符，然后向两边进行搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;    <span class="comment">//记录回文子串起始位置</span></span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>;      <span class="comment">//记录回文子串终止位置</span></span><br><span class="line">        <span class="keyword">int</span> mlen=<span class="number">0</span>;     <span class="comment">//记录最大回文子串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len1=<span class="built_in">expendaroundcenter</span>(s,i,i);     <span class="comment">//一个元素为中心</span></span><br><span class="line">            <span class="keyword">int</span> len2=<span class="built_in">expendaroundcenter</span>(s,i,i+<span class="number">1</span>);   <span class="comment">//两个元素为中心</span></span><br><span class="line">            mlen=<span class="built_in">max</span>(<span class="built_in">max</span>(len1,len2),mlen);</span><br><span class="line">            <span class="keyword">if</span>(mlen&gt;end-start+<span class="number">1</span>)&#123;</span><br><span class="line">                start=i-(mlen<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                end=i+mlen/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,mlen);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expendaroundcenter</span><span class="params">(string s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//计算以left和right为中心的回文串长度</span></span><br><span class="line">        <span class="keyword">int</span> L=left;</span><br><span class="line">        <span class="keyword">int</span> R=right;</span><br><span class="line">        <span class="keyword">while</span>(L&gt;=<span class="number">0</span> &amp;&amp; R&lt;s.<span class="built_in">length</span>() &amp;&amp; s[R]==s[L])&#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R-L<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （一）中心扩展法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//以 s[left] s[right] 为中心向两端扩散的回文串</span></span><br><span class="line">    <span class="function">string <span class="title">expendaroundcenter</span><span class="params">(string &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//防止索引越界</span></span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.<span class="built_in">size</span>()&amp;&amp;s[left]==s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left+<span class="number">1</span>,right-left<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string s1=<span class="built_in">expendaroundcenter</span>(s,i,i);</span><br><span class="line">            string s2=<span class="built_in">expendaroundcenter</span>(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//res=longest(res,s1,s1)</span></span><br><span class="line">            res=res.<span class="built_in">size</span>()&gt;s1.<span class="built_in">size</span>()?res:s1;</span><br><span class="line">            res=res.<span class="built_in">size</span>()&gt;s2.<span class="built_in">size</span>()?res:s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （二）动态规划</span></span><br><span class="line"><span class="comment"> * 1.确定dp数组（dp table）以及下标的含义</span></span><br><span class="line"><span class="comment"> * 2.确定递推公式</span></span><br><span class="line"><span class="comment"> * 3.dp数组如何初始化</span></span><br><span class="line"><span class="comment"> * 4.确定遍历顺序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在确定递推公式时，就要分析如下几种情况。</span></span><br><span class="line"><span class="comment"> * 整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</span></span><br><span class="line"><span class="comment"> * 当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</span></span><br><span class="line"><span class="comment"> * 当s[i]与s[j]相等时，这就复杂一些了，又有如下三种情况</span></span><br><span class="line"><span class="comment"> *  情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</span></span><br><span class="line"><span class="comment"> *  情况二：下标i 与 j相差为1，例如aa，也是回文子串</span></span><br><span class="line"><span class="comment"> *  情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，</span></span><br><span class="line"><span class="comment"> *  我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，</span></span><br><span class="line"><span class="comment"> *  这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *     —— —— —— —— —  —— —— —— ——</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *    |             |  dp[i][j]  |</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *     —— —— —— —— —  —— —— —— ——</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *    |dp[i+1][j-1] |            |</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *    |             |            |</span></span><br><span class="line"><span class="comment"> *     —— —— —— —— —  —— —— —— ——</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本题目是少有的动态规划非最优解的问题 （时间 O(n^2) ！空间O(n^2)）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，</span></span><br><span class="line">        <span class="comment">// 如果是dp[i][j]为true，否则为false。</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxlenth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j]由dp[i+1][j-1]确定，因此从左下向右上遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;    <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlenth) &#123;</span><br><span class="line">                    maxlenth = j - i + <span class="number">1</span>;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以上代码是为了凸显情况一二三，当然是可以简洁一下的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxlenth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlenth) &#123;</span><br><span class="line">                    maxlenth = j - i + <span class="number">1</span>;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(left, maxlenth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="JZ-47-礼物的最大价值"><a href="#JZ-47-礼物的最大价值" class="headerlink" title="JZ-47.礼物的最大价值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">JZ-47.礼物的最大价值</a></h2><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。</p>
<p>你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。</p>
<p>给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>**示例 **</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 提示：<br>0 &lt; grid.length &lt;= 200<br>0 &lt; grid[0].length &lt;= 200</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * dp状态定义：dp[i][j]表示从“start”位置走到(i,j)位置的最大权重 </span></span><br><span class="line"><span class="comment"> * dp转移方程：dp[i][j] = max(dp[i-1][j], dp[i][j-1])+grid[i][j] 只能从上面dp[i-1][j] 或 左边dp[i][j-1] 走过来</span></span><br><span class="line"><span class="comment"> * dp初始化：</span></span><br><span class="line"><span class="comment"> *  - dp[0][0] = grid[0][0]</span></span><br><span class="line"><span class="comment"> *  - dp[0][j] = dp[0][j-1] + grid[0][j]</span></span><br><span class="line"><span class="comment"> *  - dp[i][0] = dp[i-1][0] + grid[i][0]</span></span><br><span class="line"><span class="comment"> * 最终结果：res = dp[m-1][n-1] </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=grid.<span class="built_in">size</span>(), n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector &lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt; (n,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)  dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i<span class="number">-1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; ++i)  dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; ++j)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res=dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="JZ-63-股票最大利润"><a href="#JZ-63-股票最大利润" class="headerlink" title="JZ-63.股票最大利润"></a><a href>JZ-63.股票最大利润</a></h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p><strong>示例 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p>限制：</p>
<blockquote>
<p>0 &lt;= 数组长度 &lt;= 10^5</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *  maxValue保存遍历到当前日期所能达到的最大利润</span></span><br><span class="line"><span class="comment">        *  minValue保存数组中最低的股票价格</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>, minValue = INT_MAX;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="comment">// 更新股票最大利润</span></span><br><span class="line">            maxValue = <span class="built_in">max</span>(maxValue, price - minValue);</span><br><span class="line">            <span class="comment">// 更新最低股票价格</span></span><br><span class="line">            minValue = <span class="built_in">min</span>(minValue, price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 判空</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *  创建动态规划数组，全部初始为0</span></span><br><span class="line"><span class="comment">        *  dp[i]保存的是前i天的股票最大利润</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// minValue保存数组中股票的最低价格</span></span><br><span class="line">        <span class="keyword">int</span> minValue = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 更新最低股票价格</span></span><br><span class="line">            minValue = <span class="built_in">min</span>(minValue, prices[i]);</span><br><span class="line">            <span class="comment">// 更新动态规划数组</span></span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], prices[i] - minValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="pa-185-种植棒瓜"><a href="#pa-185-种植棒瓜" class="headerlink" title="pa-185.种植棒瓜"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/185">pa-185.种植棒瓜</a></h2><p>小棒瓜瓜在自己的果园中种植棒瓜。</p>
<p>每一天他都能掌握一定的种植经验，经验越丰富，种植出来的棒瓜越甜美。</p>
<p>但是小棒瓜瓜的记性不太好，时间一长，曾经积累下来的经验就会忘掉。</p>
<p>假设他的记忆力为 K，表示能记住 K 天内的事情。也就是说，在第 i 天，他能记住第 i-K, i-K+1, i-K+2 … i-1 天内的所有事情。</p>
<p>完成第 i 天的种植工作后，小棒瓜瓜能获得经验值 A_i</p>
<p>在进行第 i 天工作时，他拥有的全部经验为 A_{i-K} + A_{i-K+1} + A_{i-K+2} … + A_{i-1} 。</p>
<p>请问哪一天，小棒瓜瓜的种植经验是最丰富的？如果有多天的种植经验都是最丰富的，选最靠后的那天。</p>
<p><strong>输入</strong></p>
<p>多组测试数据，以 EOF 结束</p>
<p>每组测试数据占一行：</p>
<p>第一个整数是 n(1≤n≤10^5)，表示有 n 天</p>
<p>第二个整数是 K(1≤K≤n)，表示记忆力</p>
<p>后面跟着 n 个整数，第 i 个整数为 A_i(1≤A_i≤100)</p>
<p>数据保证：多组数据的 n 之和不超过 10^5</p>
<p><strong>输出</strong></p>
<p>输出若干行，每行一个整数，表示哪一天小棒瓜瓜的种植经验最丰富</p>
<p><strong>提示</strong></p>
<p>天数从 1 到 n 进行编号</p>
<blockquote>
<p>样例 1<br>输入<br>4 2<br>1 2 2 3</p>
<p>输出<br>4</p>
<p>提示<br>一组测试数据。<br>一共 4 天，记忆力为 2。<br>第一天种植时，掌握的经验为 0。<br>第二天种植时，掌握的经验为 1。<br>第三天种植时，掌握的经验为 1 + 2 = 3。<br>第四天种植时，掌握的经验为 2 + 2 = 4。<br>第四天的种植经验最丰富。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 状态定义: f[i] 表示执行第 i 天种植任务时掌握的经验总和</span></span><br><span class="line"><span class="comment"> * 由题意可知:</span></span><br><span class="line"><span class="comment"> * 	- f[i] = A[i-K] + A[i-K+1] ... + A[i-1]</span></span><br><span class="line"><span class="comment"> * 	- f[i+1] = A[i-K+1] + A[i-K+2] ... + A[i]</span></span><br><span class="line"><span class="comment"> * 上面两个式子相减，去掉同类项目可得：f[i+1] - f[i] = A[i] - A[i-K] </span></span><br><span class="line"><span class="comment"> * 上面式子左右移项可得：f[i+1] = f[i] + A[i] - A[i-K]</span></span><br><span class="line"><span class="comment"> * 到这里，我们得到了递推公式</span></span><br><span class="line"><span class="comment"> * 注意边界情况：前 K+1 天，f[i] = A[1] + A[2] ... + A[i-1]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; k)&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>, maxsum=<span class="number">0</span>, sum=<span class="number">0</span>, a[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre = i-k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre&gt;<span class="number">0</span>) sum-=a[pre];  <span class="comment">//sum至多为k个元素的累加和</span></span><br><span class="line">            <span class="keyword">if</span>(sum&gt;=maxsum)&#123;</span><br><span class="line">                maxsum=sum;</span><br><span class="line">                res=i;</span><br><span class="line">            &#125;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            sum+=a[i];  </span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LC-97-字符串交错"><a href="#LC-97-字符串交错" class="headerlink" title="LC-97.字符串交错"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/interleaving-string/">LC-97.字符串交错</a></h2><p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</p>
<p>两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p>
<blockquote>
<p>s = s1 + s2 + … + sn</p>
<p>t = t1 + t2 + … + tm</p>
<p>|n - m| &lt;= 1</p>
<p>交错 是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …</p>
</blockquote>
<p><strong>提示</strong>：a + b 意味着字符串 a 和 b 连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">输入：s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;</span><br><span class="line">输出：true</span><br><span class="line">i/j: 0 a a b c c e</span><br><span class="line">  0	[T,T,F,F,F,F,F]</span><br><span class="line">  b [F,T,T,F,F,F,F]</span><br><span class="line">  a	[F,T,T,F,F,F,F]</span><br><span class="line">  c	[F,F,T,T,T,T,T]</span><br><span class="line">  c	[F,F,F,F,T,F,T]</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 状态定义：f[i][j]表示 s1的前i个元素和s2的前j个元素是否能交错组成 s3的前i+j个元素</span></span><br><span class="line"><span class="comment"> * 转移方程：f[i][j] = (f[i-1][j] &amp;&amp; s1[i-1]==s3[i+j-1]) || (f[i][j-1] &amp;&amp; s2[j-1]==s3[i+j-1]);</span></span><br><span class="line"><span class="comment"> * 初始化：</span></span><br><span class="line"><span class="comment"> *  - f[0][0] = 1</span></span><br><span class="line"><span class="comment"> *  - f[i][0] = f[i-1][0]  &amp;&amp; s1[i-1]==s3[i-1];</span></span><br><span class="line"><span class="comment"> *  - f[0][j] = f[0][j-1]  &amp;&amp; s2[j-1]==s3[j-1];</span></span><br><span class="line"><span class="comment"> * 最终结果：f[n][m] </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s1.<span class="built_in">size</span>(), m=s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>( n+m != s3.<span class="built_in">size</span>() )  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector &lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">f</span>(n+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)  f[i][<span class="number">0</span>]= f[i<span class="number">-1</span>][<span class="number">0</span>] &amp;&amp; s1[i<span class="number">-1</span>]==s3[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; ++j)  f[<span class="number">0</span>][j]= f[<span class="number">0</span>][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>]==s3[j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; ++j)&#123;</span><br><span class="line">                f[i][j] = (f[i<span class="number">-1</span>][j] &amp;&amp; s1[i<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]) || (f[i][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="pa-39-数字三角形"><a href="#pa-39-数字三角形" class="headerlink" title="pa-39.数字三角形"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/39">pa-39.数字三角形</a></h2><p>下方是一个数字金字塔。</p>
<p>请查找从 <strong>最高点</strong> 到 <strong>底部任意处结束</strong> 的路径，使路径经过数字的和最大。</p>
<p>每一步可以走到左下方或右下方的点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   	    7</span><br><span class="line">      3   8</span><br><span class="line">    8   1   0</span><br><span class="line">  2   7   4   4</span><br><span class="line">4   5   2   6   5</span><br><span class="line">解释：路径 7-&gt;3-&gt;8-&gt;7-&gt;5 产生的和最大</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<ul>
<li>第一个行一个正整数 r(1≤<em>r</em>≤1000)，表示行的数目。</li>
<li>下面 r行，每行 r个数字，用空格分隔，表示该行的数字。</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>一行，一个整数，表示最大的路径和。</li>
</ul>
<p><strong>样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">3 8</span><br><span class="line">8 1 0</span><br><span class="line">2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br><span class="line">输出</span><br><span class="line">30</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 状态定义：dp[i]到最底层第i个元素的路径和</span></span><br><span class="line"><span class="comment"> * 状态转移：每层最左，最右只有一种选择，中间元素有两种选择</span></span><br><span class="line"><span class="comment"> * 边界条件： dp[0]=a[0][0]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[r];   <span class="comment">//底层元素个数，接下来动态更新dp</span></span><br><span class="line">    dp[<span class="number">0</span>]=a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;r; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == i)     <span class="comment">//塔层末尾值只能选择左上方元素</span></span><br><span class="line">                dp[j] = dp[j<span class="number">-1</span>] + a[i][j];  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>)  <span class="comment">//塔层首位值只能选择正上方元素</span></span><br><span class="line">                dp[j] += a[i][<span class="number">0</span>];  </span><br><span class="line">            <span class="keyword">else</span>            <span class="comment">//中间值选择正上方和左上方元素最大值</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j<span class="number">-1</span>]) + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(dp, dp+r);</span><br><span class="line">    <span class="keyword">return</span> dp[r<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;r; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; ++j)&#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">solve</span>();</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pa-130-合并两个序列II"><a href="#pa-130-合并两个序列II" class="headerlink" title="pa-130.合并两个序列II"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/130">pa-130.合并两个序列II</a></h2><p>给定两个正整数序列 a,b 长度分别为 A,B 我们要将它们合并为一个新序列，同时保证 a 的元素相对顺序不变，b 的元素相对顺序不变，例如：</p>
<ul>
<li>a=[1,2,3]</li>
<li>b=[4,5,6]</li>
<li>一种合法的合并结果为 [1,2,4,3,5,6]，因为 [1,2,3]相对顺序不变，[4,5,6]相对顺序也没变</li>
<li>一种 <strong>不合法</strong> 的合并结果为 [2,4,1,3,5,6]因为 [1,2,3] 的变为了 [2,1,3]</li>
</ul>
<p>现在让我们计算一下，一种有多少种合并方案</p>
<p><strong>输入</strong></p>
<ul>
<li>第一行输入 T, 1≤T≤10000，表示接下来有 T组测试数据</li>
<li>接下来 T行，每行两个整数 A,B, 0≤A,B≤1000，分别表示两个序列的长度</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>输出 T行，每行一个正整数，表示有多少种合并方案</li>
<li>结果对 1e9+7 取模</li>
</ul>
<p><strong>提示</strong></p>
<ul>
<li>两个序列的长度都可能为 0</li>
<li>如果两者长度都为 0，答案为 1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: DP</span></span><br><span class="line"><span class="comment"> * 状态：f(a, b) 用掉了a个红球，b个蓝球，有多少种放置关系</span></span><br><span class="line"><span class="comment"> * 转移：f(a, b) = f(a-1, b) + f(a, b-1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f)); <span class="comment">//初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; ++i) f[<span class="number">0</span>][i] = f[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//边界条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;N; ++j)&#123;</span><br><span class="line">            f[i][j] = (f[i<span class="number">-1</span>][j] + f[i][j<span class="number">-1</span>]) % base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        cout &lt;&lt; f[a][b] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pa-131-合并两个序列III"><a href="#pa-131-合并两个序列III" class="headerlink" title="pa-131.合并两个序列III"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/131">pa-131.合并两个序列III</a></h2><p>给定两个正整数序列 a,b 长度分别为 A,B 我们要将它们合并为一个新序列，同时保证 a 的元素相对顺序不变，b 的元素相对顺序不变，例如：</p>
<ul>
<li>a=[1,2,3]</li>
<li>b=[4,5,6]</li>
<li>一种合法的合并结果为 [1,2,4,3,5,6]，因为 [1,2,3]相对顺序不变，[4,5,6]相对顺序也没变</li>
<li>一种 <strong>不合法</strong> 的合并结果为 [2,4,1,3,5,6]，因为 [1,2,3] 的变为了 [2,1,3]</li>
</ul>
<p>现在让我们计算一下，一种有多少种合并方案</p>
<p><strong>输入</strong></p>
<ul>
<li>第一行输入 T, 1≤T≤10000，表示接下来有 T组测试数据</li>
<li>接下来 T行，每行两个整数 A,B, 0≤A,B≤<strong>1e5</strong>，分别表示两个序列的长度</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>输出 T行，每行一个正整数，表示有多少种合并方案</li>
<li>结果对 1e9+7 取模</li>
</ul>
<p><strong>提示</strong></p>
<ul>
<li>两个序列的长度都可能为 0</li>
<li>如果两者长度都为 0，答案为 1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 组合数学</span></span><br><span class="line"><span class="comment"> * (x/y)%m = x*y^(m-2)</span></span><br><span class="line"><span class="comment"> * 快速幂：二分/位运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line">ll f[<span class="number">2</span>*N];  <span class="comment">// f[i]等于 i 的阶乘</span></span><br><span class="line">ll g[<span class="number">2</span>*N];  <span class="comment">// g[i]等于 i 的阶乘的 mod - 2 次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">power</span><span class="params">(ll x, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll tmp = <span class="built_in">power</span>(x, m/<span class="number">2</span>);</span><br><span class="line">    tmp = (tmp * tmp) % mod;</span><br><span class="line">    <span class="keyword">if</span>(m &amp; <span class="number">1</span>) tmp = tmp * x %mod;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>, g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">2</span>*N; ++i)&#123;</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>] * i % mod;</span><br><span class="line">        g[i] = <span class="built_in">power</span>(f[i], mod<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * C(A, A+B) </span></span><br><span class="line"><span class="comment">         * = (A+B) * (A+B-1) .. * (B+1) / A! % MOD</span></span><br><span class="line"><span class="comment">         * = (A+B)! / B! / A! % MOD</span></span><br><span class="line"><span class="comment">         * = (A+B)! * B!^(MOD-2) * A!^(MOD-2) % MOD</span></span><br><span class="line"><span class="comment">         * f[A+B] * g[B] % MOD * g[A] % MOD</span></span><br><span class="line"><span class="comment">         */</span>        </span><br><span class="line">        cout &lt;&lt; f[a+b] * g[b] % mod * g[a] % mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="高频面试系列"><a href="#高频面试系列" class="headerlink" title="高频面试系列"></a>高频面试系列</h1><h2 id="atoi-atof"><a href="#atoi-atof" class="headerlink" title="atoi atof"></a>atoi atof</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//字符型转浮点型</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myatof</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">double</span> n = <span class="number">0</span>,m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;-&#x27;</span>)&#123;<span class="comment">//处理符号</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*(s + i) != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(*(s + i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *(s + i) &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;<span class="comment">//处理整数部分</span></span><br><span class="line">            n = n * <span class="number">10</span> + (*(s + i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            i ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        i ++;</span><br><span class="line">        <span class="keyword">while</span>(*(s + i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *(s + i) &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;<span class="comment">//处理小数部分</span></span><br><span class="line">            m = m * <span class="number">10</span> + (*(s + i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            k *= <span class="number">10</span>;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        d = n + m / k ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        d = <span class="number">-1</span> * (n + m / k);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符型转整形</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myatoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>,i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;-&#x27;</span>)&#123;<span class="comment">//处理符号</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*(s + i) != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *(s + i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *(s + i) &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        n = n * <span class="number">10</span> + (*(s + i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        i ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        n = n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n = <span class="number">-1</span> * n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// char s[10];</span></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">char</span> ss[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Input a string!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="comment">// cout&lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; myatof(s.c_str())&lt;&lt;endl;</span></span><br><span class="line">    cout &lt;&lt;<span class="built_in">myatof</span>(s.<span class="built_in">c_str</span>())&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断合法IP"><a href="#判断合法IP" class="headerlink" title="判断合法IP"></a>判断合法IP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_valid_ip</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> section = <span class="number">0</span>; <span class="comment">//每一节的十进制值</span></span><br><span class="line">    <span class="keyword">int</span> dot = <span class="number">0</span>;     <span class="comment">//几个点分隔符</span></span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">-1</span>;   <span class="comment">//每一节中上一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (*ip)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*ip == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            dot++;</span><br><span class="line">            <span class="keyword">if</span> (dot &gt; <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (section &gt;= <span class="number">0</span> &amp;&amp; section &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">                section = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*ip &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *ip &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            section = section * <span class="number">10</span> + *ip - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = *ip;</span><br><span class="line">        ip++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (section &gt;= <span class="number">0</span> &amp;&amp; section &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">3</span> == dot)&#123;</span><br><span class="line">            section = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;IP address success!\n&quot;);</span></span><br><span class="line">            <span class="comment">// printf(&quot;true&quot;);</span></span><br><span class="line">            <span class="comment">//printf (&quot;%d\n&quot;,dot);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else printf(&quot;false&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> res = is_valid_ip(<span class="string">&quot;92.49.01.133&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/tingyun_say/article/details/52343897">约瑟夫环</a></h2><p><strong>在一间房间总共有n个人（下标0～n-1），只能有最后一个人活命。</strong></p>
<p>按照如下规则去排除人：</p>
<ul>
<li>所有人围成一圈</li>
<li>顺时针报数，每次报到q的人将被排除掉</li>
<li>被排除掉的人将从房间内被移走</li>
<li>然后从被kill掉的下一个人重新报数，继续报q，再清除，直到剩余一人</li>
</ul>
<p><img src="/2021/02/21/Algorithm/Projects\Gits\hexo\myblog\source_posts\Algorithm\josephus.png" alt="josephus"></p>
<p><code>(old - q) % n = new</code>  ==&gt;  <code>old = (new + q) % n</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: 约瑟夫环</span></span><br><span class="line"><span class="comment"> * old = josephus(n), new = josephus(n-1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">josephus</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">josephus</span>(n<span class="number">-1</span>, q)+q)%n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">josephus</span>(n, q);</span><br><span class="line">    cout &lt;&lt; res+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="寻找素数"><a href="#寻找素数" class="headerlink" title="寻找素数"></a>寻找素数</h2><p> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-primes/">LC-204. 计数质数</a></p>
<p>统计所有小于非负整数 <em>n</em> 的质数的数量。[如果⼀个数如果只能被 1 和它本⾝整除，那么这个数就是素数]</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 5 * 10^6</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Eratosthenes筛选法</span></span><br><span class="line"><span class="comment"> * 从2开始遍历到n</span></span><br><span class="line"><span class="comment"> * i=2,并排除2的倍数</span></span><br><span class="line"><span class="comment"> * i=3,并排除3的倍数</span></span><br><span class="line"><span class="comment"> * i=5,并排除5的倍数</span></span><br><span class="line"><span class="comment"> * 。。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始默认所有数为质数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i) &#123;</span><br><span class="line">                    <span class="comment">//排除i的倍数</span></span><br><span class="line">                    res[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="模幂运算"><a href="#模幂运算" class="headerlink" title="模幂运算"></a>模幂运算</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/super-pow/">LC-372. 超级次方</a></p>
<p>你的任务是计算 <code>ab</code> 对 <code>1337</code> 取模，<code>a</code> 是一个正整数，<code>b</code> 是一个非常大的正整数且会以数组形式给出。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = [3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = [1,0]</span><br><span class="line">输出：1024</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 1, b = [4,3,3,8,5,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2147483647, b = [2,0,0]</span><br><span class="line">输出：1198</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= a &lt;= 231 - 1</code></li>
<li><code>1 &lt;= b.length &lt;= 2000</code></li>
<li><code>0 &lt;= b[i] &lt;= 9</code></li>
<li><code>b</code> 不含前导 0</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1337</span>;</span><br><span class="line">    <span class="comment">//求 a 的 k 次方， 对 mod 取余</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">modPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        a %= mod;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            res *= a;</span><br><span class="line">            res %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">size</span>() == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = b.<span class="built_in">back</span>();</span><br><span class="line">        b.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 将原问题化简，缩小规模递归求解</span></span><br><span class="line">        <span class="keyword">int</span> part1 = <span class="built_in">modPow</span>(a, last);</span><br><span class="line">        <span class="keyword">int</span> part2 = <span class="built_in">modPow</span>(<span class="built_in">superPow</span>(a, b), <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 合并出结果</span></span><br><span class="line">        <span class="keyword">return</span> (part1 * part2)%mod;</span><br><span class="line">        <span class="comment">// return (modPow(a, last) * modPow(superPow(a, b), 10)) % mod;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1337</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">modPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        a %= mod;</span><br><span class="line">        <span class="comment">// k 是奇数</span></span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>)  <span class="keyword">return</span> (a * <span class="built_in">modPow</span>(a, k - <span class="number">1</span>)) % mod;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// k 是偶数</span></span><br><span class="line">            <span class="keyword">int</span> sub = <span class="built_in">modPow</span>(a, k / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> (sub * sub) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="pa-3-寻找最靠左的匹配子串-1"><a href="#pa-3-寻找最靠左的匹配子串-1" class="headerlink" title="pa-3.寻找最靠左的匹配子串"></a>pa-3.寻找最靠左的匹配子串</h2><p><a href="#%5Bpa-3.%E5%AF%BB%E6%89%BE%E6%9C%80%E9%9D%A0%E5%B7%A6%E7%9A%84%E5%8C%B9%E9%85%8D%E5%AD%90%E4%B8%B2%5D(https://www.papamelon.com/problem/3)">跳转</a></p>
<h2 id="pa-4-长度为-K-的回文子串"><a href="#pa-4-长度为-K-的回文子串" class="headerlink" title="pa-4.长度为 K 的回文子串"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/4">pa-4.长度为 K 的回文子串</a></h2><p><img src="/2021/02/21/Algorithm/pa-4.png" alt="pa-4"></p>
<p>样例 1</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6 3</span><br><span class="line">acdcxb</span><br><span class="line">6 5</span><br><span class="line">acdcxb</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 测试用例 20/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left]!=s[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> left++,right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+k<span class="number">-1</span>&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i,i+k<span class="number">-1</span>))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 字符串哈希 O(1)</span></span><br><span class="line"><span class="comment">* https://www.bilibili.com/video/BV1Tv41157YX?p=5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ull = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line">ull p[N];           <span class="comment">//k的幂次</span></span><br><span class="line">ull h0[N], h1[N];   <span class="comment">// 从左到右扫描，维护所有前缀的映射值（哈希值）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  h0[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">    h0[i] = h0[i - <span class="number">1</span>] * P + s[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">//idx 对应的是 s 的 n - i + 1 下标</span></span><br><span class="line">    <span class="keyword">int</span> idx = n - i + <span class="number">1</span>;</span><br><span class="line">    h1[i] = h1[i - <span class="number">1</span>] * P + s[idx];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">query0</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> h0[r] - h0[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function">ull <span class="title">query1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> h1[r] - h1[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  cin&gt;&gt;s;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">init</span>();   <span class="comment">//预处理哈希值，幂次</span></span><br><span class="line">  <span class="comment">//枚举回文串的左端点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + m - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> half = m &gt;&gt; <span class="number">1</span>;   <span class="comment">//int half = m/2;</span></span><br><span class="line">    ull ret1 = <span class="built_in">query0</span>(i, i + half - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = n - (i + m - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = n - (i + m - half) + <span class="number">1</span>;</span><br><span class="line">    ull ret2 = <span class="built_in">query1</span>(l, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret1 == ret2) &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  cin&gt;&gt;T;</span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="pa-29-回文平方数"><a href="#pa-29-回文平方数" class="headerlink" title="pa-29.回文平方数"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/29">pa-29.回文平方数</a></h2><p>Palindromic Squares</p>
<p>回文数是指从左向右念和从右向左念都一样的数。如 1232112321 就是一个典型的回文数。</p>
<p>给定一个用十进制正整数 B<em>B</em>，在 [1, 300]中寻找所有特殊的整数 <em>X</em>，满足 X^2用 B进制表示时是回文数。</p>
<p>其中，2≤B≤20。大于 9 的数，用字母表示。例如用 A表示 10，B表示 11，用第 n个大写字母表示 n+9。</p>
<p> <strong>输入</strong></p>
<ul>
<li>输入一个正整数 B, 2≤B≤20</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>输出多行，每行分左右两部分，用空格隔开<ul>
<li>左边的部分是 [1,300] 内的一个正整数 X的 B进制表示</li>
<li>右边的部分是 X^2 的 B进制表示</li>
</ul>
</li>
<li>输出的数据按左部分的十进制值从小到大排序</li>
</ul>
<p>**样例 **</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">2 4</span><br><span class="line">3 9</span><br><span class="line">11 121</span><br><span class="line">22 484</span><br><span class="line">26 676</span><br><span class="line">101 10201</span><br><span class="line">111 12321</span><br><span class="line">121 14641</span><br><span class="line">202 40804</span><br><span class="line">212 44944</span><br><span class="line">264 69696</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 十进制转 K 进制：短除法</span></span><br><span class="line"><span class="comment"> * 实际上就是一个不断模 K 除 K 的过程。我们可以举一个实际的例子，将 345 转成 6 进制数</span></span><br><span class="line"><span class="comment"> * 346÷6=57...4</span></span><br><span class="line"><span class="comment"> * 57÷6=9...3</span></span><br><span class="line"><span class="comment"> * 9÷6=1...3</span></span><br><span class="line"><span class="comment"> * 1÷6=0...1</span></span><br><span class="line"><span class="comment"> * 当商等于 0 时算法停止，然后我们将余数逆序保存，得到 1334，这就是对应的 6 进制表达</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="comment">//回文串判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left]!=s[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> left++,right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进制转换</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">char</span>&gt; <span class="title">tobint</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">char</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=a%b;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;<span class="number">9</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&#x27;A&#x27;</span>+tmp<span class="number">-10</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//int强转char--&gt; char(intval+48)</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in"><span class="keyword">char</span></span>(tmp+<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        a=a/b; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">300</span>;++i)&#123;</span><br><span class="line">        vector&lt;<span class="keyword">char</span>&gt; vec1=<span class="built_in">tobint</span>(i*i,b);</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="built_in">check</span>(vec1,<span class="number">0</span>,vec1.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">char</span>&gt; vec0=<span class="built_in">tobint</span>(i,b);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it0=vec0.<span class="built_in">begin</span>();it0!=vec0.<span class="built_in">end</span>();++it0)&#123;</span><br><span class="line">                cout&lt;&lt;*it0;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it1=vec1.<span class="built_in">begin</span>();it1!=vec1.<span class="built_in">end</span>();++it1)&#123;</span><br><span class="line">                cout&lt;&lt;*it1;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="pa-30-双重回文数"><a href="#pa-30-双重回文数" class="headerlink" title="pa-30.双重回文数"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/30/submissions">pa-30.双重回文数</a></h2><p>Dual Palindromes</p>
<p>从左往右读和从右往左读都一样的数字叫做 <strong>回文数</strong>。例如，12321就是一个回文数，而 77778 就不是。</p>
<p>当然，回文数的首和尾都应是非零的，因此 0220不是回文数。</p>
<p>有一些数，例如 21，在十进制时不是回文数，但在其它进制，如二进制时为 10101时是回文数。</p>
<p>给定两个十进制数 n,s，然后找出前 n个满足大于 s且在不少于两种进制（二进制至十进制）上是回文数的十进制数。</p>
<p>本问题的解决方案不需要使用大于 32 位的整型数</p>
<p> 输入</p>
<ul>
<li>只有一行，用空格隔开的两个正整数 n,s, 1≤<em>n</em>≤15,1≤<em>s</em>≤9999。</li>
</ul>
<p> 输出</p>
<ul>
<li>n行, 每行一个满足上述要求的数，并按从小到大的顺序输出。</li>
</ul>
<p>样例 1</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 25</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 s+1 开始枚举</span></span><br><span class="line"><span class="comment"> * 对于每个数字，从二进制到十进制枚举，将该数转换为对应进制下的值，再看看这个值是否为回文数</span></span><br><span class="line"><span class="comment"> * 如果有至少两个进制下的值是回文数，该数就是双重回文数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="comment">//回文串判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left]!=s[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> left++,right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进制转换</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tobint</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(a%b);</span><br><span class="line">        a=a/b; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力枚举</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>,k=<span class="number">0</span>;k&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;=<span class="number">10</span>&amp;&amp;count&lt;<span class="number">2</span>; ++j)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec = <span class="built_in">tobint</span>(i,j);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(vec, <span class="number">0</span>, vec.<span class="built_in">size</span>()<span class="number">-1</span>))  count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">2</span>)&#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pa-27-挤牛奶"><a href="#pa-27-挤牛奶" class="headerlink" title="pa-27.挤牛奶"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/27/submissions">pa-27.挤牛奶</a></h2><p>这是一个关于农夫和奶牛的问题，直接来看一个实际的例子：</p>
<ul>
<li>第一个农民在 [300, 1000) 秒给奶牛挤奶</li>
<li>第二个农民在 [700, 1200) 秒给奶牛挤奶</li>
<li>第三个农民在 [1500, 2100) 秒给奶牛挤奶</li>
</ul>
<p>期间最长的至少有一个农民在挤奶的连续时间为 900 秒 (也就是 [300, 1200) 秒)。</p>
<p>而最长的无人挤奶的连续时间为 300 秒 (也就是 [1200, 1500) 秒)。</p>
<p>你的任务是编一个程序，读入 n个农民的工作时间列表，计算以下两点(均以秒为单位):</p>
<ul>
<li>最长至少有一人在挤奶的时间段。</li>
<li>最长的无人挤奶的时间段。（从有人挤奶开始算起）</li>
</ul>
<p> 输入</p>
<ul>
<li>第一行一个正整数 n, 1 ≤<em>n</em>≤5000</li>
<li>接下来 n行，每行两个非负整数 l,r，表示一个农民的工作时间。</li>
</ul>
<p> 输出</p>
<ul>
<li>一行，两个整数，即题目所要求的两个答案。</li>
</ul>
<p>样例 1</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">300 1000</span><br><span class="line">700 1200</span><br><span class="line">1500 2100</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">900 300</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  【经典的区间合并问题】</span></span><br><span class="line"><span class="comment"> * 我们把农民工作的时候看作区间，每个区间用 [start_i, end_i) 表示</span></span><br><span class="line"><span class="comment"> * 对所有区间按左端点从小到大排序</span></span><br><span class="line"><span class="comment"> * 挨个遍历这些区间，并且维护一个 “当前合并区间” S，用 [resa, reab) 表示 S 的左右端点</span></span><br><span class="line"><span class="comment"> * 当遍历到第一个区间的时候，它就是 S，即 resa=start_0, resb=end_0</span></span><br><span class="line"><span class="comment"> * 当遍历到一个新区间，可能出现两种情况：</span></span><br><span class="line"><span class="comment"> *    start_i &lt;= resb, 合并区间 S，并更新右端点，resb=max(end_i, resb)</span></span><br><span class="line"><span class="comment"> *    start_i &gt; resb,  将 S 保存下来,重置区间S的左右端点，resa=start_i, resb=end_i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector &lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; ma, mi;</span><br><span class="line"><span class="keyword">int</span> resa, resb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    resa=vec[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    resb=vec[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    ma.<span class="built_in">push_back</span>(resb-resa);</span><br><span class="line">    mi.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i][<span class="number">0</span>] &lt;= resb)&#123;</span><br><span class="line">            resb=<span class="built_in">max</span>(vec[i][<span class="number">1</span>],resb);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ma.<span class="built_in">push_back</span>(resb-resa);</span><br><span class="line">            mi.<span class="built_in">push_back</span>(vec[i][<span class="number">0</span>]-resb);</span><br><span class="line">            resa=vec[i][<span class="number">0</span>];</span><br><span class="line">            resb=vec[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ma.<span class="built_in">push_back</span>(vec[n<span class="number">-1</span>][<span class="number">1</span>]-vec[n<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">    cout&lt;&lt;*<span class="built_in">max_element</span>(ma.<span class="built_in">begin</span>(),ma.<span class="built_in">end</span>()) &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; *<span class="built_in">max_element</span>(mi.<span class="built_in">begin</span>(),mi.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line">        cin &gt;&gt; start &gt;&gt; end;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(&#123;start, end&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="pa-19-后缀0"><a href="#pa-19-后缀0" class="headerlink" title="pa-19.后缀0"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/19">pa-19.后缀0</a></h2><p>小棒瓜瓜得到了一个正整数 n，他需要计算 n，即要计算 1 * 2 * 3 * 4 … * n。最后让我们统计一下，这个结果有多少个后缀 0，也就是从结果的末尾往前数有多少个连续的 0。</p>
<p><strong>输入</strong></p>
<p>第一行是整数 T, 1≤T≤1000，表示接下来有 T 组数据</p>
<p>接下来有 TT 行，每行一个整数 n, 1≤n≤1000，表示要我们统计 n! 的后缀 0 数量</p>
<p><strong>输出</strong></p>
<p>输出 T 行，每行一个整数，表示 n! 的后缀 0 的数量</p>
<p>样例 1<br>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 提示<br>4 的阶乘是 24，后缀 0 数量为 0<br>8 的阶乘为 40320，后缀 0 的数量为 1</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 容斥原理</span></span><br><span class="line"><span class="comment"> * 有一对【2，5】才能产生一个 0</span></span><br><span class="line"><span class="comment"> * 在每 5 个数为一组的区间， 2^x  5^y  ====&gt; x &gt; y</span></span><br><span class="line"><span class="comment"> * 最后求[0,n]中 5 的幂次方的个数 5^a, 25^b, 125^c 625^d</span></span><br><span class="line"><span class="comment"> * 后缀0的个数即为 a+b+c+d</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>, base=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span>(base &lt;= n)&#123;</span><br><span class="line">        res += n/base;</span><br><span class="line">        base = base*<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pa-20-合适篮筐的数量"><a href="#pa-20-合适篮筐的数量" class="headerlink" title="pa-20.合适篮筐的数量"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/20">pa-20.合适篮筐的数量</a></h2><p>小棒瓜瓜现在有 m 个甜美的棒瓜，每个棒瓜都有相应的体积，设第 i 个棒瓜的体积为 v_i</p>
<p>现在他要寻找一个 合适的篮筐，要求这个 篮筐的容量至少是其中一个棒瓜的体积的整数倍。</p>
<p>小棒瓜瓜来到集市，发现有 n 个篮筐，这些篮筐的容量恰好是连续的正整数，最小的篮筐容量为 C，最大的篮筐容量为 C + n - 1，也就是说，这些篮筐的容量分别为 [C, C+1, C+2, C+3, … , C+n-1]</p>
<p>现在他要在这些篮筐中，找出所有合适的篮筐，请你帮忙统计合适的篮筐个数。</p>
<p>下面来看一个例子</p>
<p>一共有 3 个棒瓜，它们的体积分别为 [2,3,4]</p>
<p>集市里有 6 个篮筐，最小篮筐容量为 11，所有的篮筐容量为 [1,2,3,4,5,6]</p>
<p>合适的篮筐一共有 4 个，包括 [2,3,4,6]，它们的容量至少是一个棒瓜体积的整数倍</p>
<p><strong>输入</strong></p>
<ul>
<li><p>第一行是整数 T, 1≤T≤1000，表示接下来有 T 组数据</p>
</li>
<li><p>每组数据位于一行:</p>
<ul>
<li><p>前 3 个是正整数 m, n, C，分别表示棒瓜的数量和集市中篮筐的数量，以及最小的篮筐容量，其中 1≤m≤10, 1≤n≤10^6, 1≤C≤10^8</p>
</li>
<li><p>接下来是 m 个正整数，表示 m 个棒瓜的体积，设第 i 个棒瓜的体积为 1&lt;=vi&lt;=500,<strong>同时保证所有棒瓜的体积相乘不会超过</strong>10^18</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>样例 1<br>输入<br>1<br>3 6 1 2 3 4<br>输出<br>4</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.枚举所有集合重叠的情况 </span></span><br><span class="line"><span class="comment"> *  -所谓的集合，指的是 vi 的倍数</span></span><br><span class="line"><span class="comment"> *  -&#123;v0&#125;, &#123;v1&#125;, &#123;v2&#125; ... &#123;vm-1&#125;</span></span><br><span class="line"><span class="comment"> *  -&#123;v0,v1&#125;, &#123;v0,v2&#125;... &#123;vm-2,vm-1&#125;</span></span><br><span class="line"><span class="comment"> *  -&#123;v0,v1,v2&#125; ... &#123;vm-3,vm-2,vm-1&#125;</span></span><br><span class="line"><span class="comment"> *  - ...</span></span><br><span class="line"><span class="comment"> * 2.计算重叠集合的最小公倍数， LCM = &#123;vi, vj ... vk&#125;,  n/LCM = 重叠集合的大小</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.根据容斥原理， 奇加 偶减</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n ,c;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)  cin &gt;&gt; v[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxs = <span class="number">1</span> &lt;&lt; m; <span class="comment">//总共状态数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>; s&lt;maxs; ++s)&#123; <span class="comment">//一共maxs-1重状态，s从1开始</span></span><br><span class="line">        ll lcm=<span class="number">1LL</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i) <span class="keyword">if</span> ((s &gt;&gt; i) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// a*b=p*q 最小公倍数于最大公约数的关系</span></span><br><span class="line">            lcm = lcm * v[i] / __gcd(lcm, <span class="number">1LL</span> * v[i]) ; <span class="comment">// &#123;vi, vj ... vk&#125;的最小公倍数</span></span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> count = (c+n<span class="number">-1</span>)/lcm - (c<span class="number">-1</span>)/lcm;</span><br><span class="line">        <span class="keyword">if</span>(cnt &amp;<span class="number">1</span> )  res += count;</span><br><span class="line">        <span class="keyword">else</span> res -= count;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="pa-9-套娃-1"><a href="#pa-9-套娃-1" class="headerlink" title="pa-9.套娃"></a>pa-9.套娃</h2><p><a href="#%5Bpa-9.%E5%A5%97%E5%A8%83%5D(https://www.papamelon.com/problem/9)">跳转</a></p>
<h2 id="pa-18-套娃II-1"><a href="#pa-18-套娃II-1" class="headerlink" title="pa-18.套娃II"></a>pa-18.套娃II</h2><p><a href="#%5Bpa-18.%E5%A5%97%E5%A8%83II%5D(https://www.papamelon.com/problem/18)">跳转</a></p>
<h2 id="pa-10-计算第k个排列"><a href="#pa-10-计算第k个排列" class="headerlink" title="pa-10.计算第k个排列"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/10">pa-10.计算第k个排列</a></h2><p>给定我们整数 n，表示我们有 [1,2,3,4 … n-1, n] 这 n 个数字，我们可以构造出 n! 个的升序排序的排列。</p>
<p>例如，n = 3，所有的排列为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>

<p>现在再给定我们一个整数 K, 1≤K≤n!，让我们找到第 K 个排列。</p>
<p>例如，n = 3, K = 1，目标排列是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure>

<p> n= 3, K = 3，目标排列是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1 3</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<p>第一行是整数 T 表示接下来有 T 组 n, K，其中 1≤T≤1000</p>
<p>接下来有 T 行，每行两个数字用空格分隔，分别为 n, K，1≤n≤20,1≤K≤n!</p>
<p><strong>输出</strong></p>
<p>输出 T 行，每行是相应的目标排列，每个数字间用空格相隔，注意每行最后不要输出多余空格</p>
<p>样例 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">2</span><br><span class="line">3 1</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出:</span><br><span class="line">1 2 3</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-08-11 21:53:14</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-08-12 10:49:45</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">ll f[N+<span class="number">5</span>];         <span class="comment">//计算阶乘 f[i]=!i</span></span><br><span class="line"><span class="keyword">bool</span> visit[N+<span class="number">5</span>];   <span class="comment">//visit[i]=true 表示 i 已经被选到排列中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ll K;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">    <span class="comment">// 从左到右，按位确认被选中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pos = n; pos&gt;<span class="number">0</span>; pos--) &#123;</span><br><span class="line">        ll sum=<span class="number">0</span>;     <span class="comment">//跳过多少个排列</span></span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">1</span>;    <span class="comment">//选中的元素，pos=n时，每个分组有 f(n-1)个排列</span></span><br><span class="line">        <span class="comment">//确认分组</span></span><br><span class="line">        <span class="keyword">for</span> (; cur &lt;= n; cur++) <span class="keyword">if</span> (!visit[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + f[pos - <span class="number">1</span>] &gt;= K) <span class="keyword">break</span>;</span><br><span class="line">            sum += f[pos - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        visit[cur] = <span class="literal">true</span>;</span><br><span class="line">        cout &lt;&lt; cur &lt;&lt; (pos==<span class="number">1</span> ? <span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        K -= sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) f[i] = f[i - <span class="number">1</span>] * i;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="pa-10-计算排列的编号"><a href="#pa-10-计算排列的编号" class="headerlink" title="pa-10.计算排列的编号"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/11">pa-10.计算排列的编号</a></h2><p>给定正整数 n，表示我们有 [1,2,3,4 … n-1, n] 这 n 个数字，我们可以构造出 n! 个升序排序的排列。</p>
<p>例如，n = 3，所有的排列为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>

<p>现在，从中选择其中一个排列，计算它的编号，例如：</p>
<ul>
<li>以下排列属于第 1 个：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure></li>
<li>以下排列属于第 3 个:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1 3</span><br></pre></td></tr></table></figure></li>
<li>以下排列属于第 5 个：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 1 2</span><br></pre></td></tr></table></figure></li>
<li><em>输入</em>*</li>
</ul>
<p>第一行是整数 T，表示接下来有 T 组 排列，其中 1≤T≤10000</p>
<p>接下来有 T 行，每行的第一个数字为 n, 1≤n≤20，后面跟着 n 个整数，是一个关于 n 的排列，所有数字用空格分 隔</p>
<p><strong>输出</strong></p>
<p>输出 T 行，每行表示排列的编号</p>
<blockquote>
<p>样例 1</p>
<p>输入</p>
<p>2</p>
<p>3 2 1 3</p>
<p>3 3 1 2</p>
<p>输出</p>
<p>3</p>
<p>5</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于给定的序列，按位确定</span></span><br><span class="line"><span class="comment"> * 对于当前 a[i]，先计算 a[i] 在可用的元素里面排第几位(count)</span></span><br><span class="line"><span class="comment"> * 对于当前第 i 轮，确认了 a[i] 后，其余元素可以任意排，产生的排列数量是 (n-1-i)!</span></span><br><span class="line"><span class="comment"> * 实际跳过的排列的数量 = (n-1-i)! * count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>; <span class="comment">//标记数组</span></span><br><span class="line">    </span><br><span class="line">    ll skip = <span class="number">0</span>; <span class="comment">//跳过多少个排列</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;  <span class="comment">// a[i] 在可用的数字里面，是第几个</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>; x&lt;=n &amp;&amp; x!=a[i]; x++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[x]) count++;</span><br><span class="line">        skip += f[n<span class="number">-1</span>-i]*count;</span><br><span class="line">        vis[a[i]]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; skip+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; ++i)&#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]*i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pa-140-公司团建"><a href="#pa-140-公司团建" class="headerlink" title="pa-140.公司团建"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/140">pa-140.公司团建</a></h2><p>公司终于去团建啦！这次参加团建的一共有 n 个小伙伴，为了使得团建可以愉快进行，我们保证 n 一共是 偶数，同时我们希望小伙伴们能两两组队，这样旅途中不会太无聊。</p>
<p>请你帮忙计算一下，一共有多少种组队方案？</p>
<p>请注意以下细节</p>
<p>(A, B) 和 (B,A) 被认为是一个队伍。也就是说，如果 n=2，只有一种组队方案</p>
<p>匹配后的队伍，并无前后顺序之分，例如 n=4:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以下两种组队方案被认为是同一种</span><br><span class="line">1 2  // 1 2 组队</span><br><span class="line">3 4  // 3 4 组队</span><br><span class="line"></span><br><span class="line">3 4  // 3 4 组队</span><br><span class="line">1 2  // 1 2 组队</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<p>只有一行，整数 n (2≤n≤16), 保证 n 一定是 <strong>偶数</strong></p>
<p><strong>输出</strong></p>
<p>只有一行，表示有多少种组队方案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 所有的组合都可以归结为 a_0(1) &lt; b_i(n-1) a_1(1) &lt; b_i(n-3)...</span></span><br><span class="line"><span class="comment"> * 最后的结果为(n-1)*(n-3)*(n-5)* ... * 1</span></span><br><span class="line"><span class="comment"> * 递推公式 f[i]=f[i-2]*(i-1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> f[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=N; i=i+<span class="number">2</span>)&#123;</span><br><span class="line">        f[i] = f[i<span class="number">-2</span>] * (i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; f[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pa-141-公司团建II"><a href="#pa-141-公司团建II" class="headerlink" title="pa-141.公司团建II"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/141">pa-141.公司团建II</a></h2><p>题干同140.</p>
<p><strong>输入</strong></p>
<ul>
<li>第一行为整数 T (1≤T≤10000)，表示有 T 组测试数据</li>
<li>接下来 T行，每行一个整数 n (2≤n≤10^6), 保证 n 一定是 <strong>偶数</strong></li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>输出 T行，每行一个整数，表示有多少种组队方案</li>
<li>结果对 <code>998244353</code> 取模</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多了取模</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span>;</span><br><span class="line">ll f[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=N; i=i+<span class="number">2</span>)&#123;</span><br><span class="line">        f[i] = f[i<span class="number">-2</span>] * (i<span class="number">-1</span>) % <span class="number">998244353</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">   </span><br><span class="line">        cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pa-15-刷房子"><a href="#pa-15-刷房子" class="headerlink" title="pa-15.刷房子"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/15">pa-15.刷房子</a></h2><p>小棒瓜瓜有 n 个房子排成一排，同时他有红黄蓝三种颜色的油漆。现在他要给每个房子刷上一种颜色的油漆，同时要求任意两个相邻房子的油漆颜色不得相同。</p>
<p>另外，即便是同一种颜色的油漆，刷不同的房子，所需的花费也是不同的。</p>
<p>现在我们得到每个房子刷上 33 种油漆的代价，请帮小棒瓜瓜计算一下，为所有房子都刷上油漆且没有任意两个相邻房子的颜色相同的最小总花费。</p>
<p><strong>输入</strong></p>
<ul>
<li><p>第一行是整数 T，表示接下来有 TT 组数据，1≤T≤1000</p>
</li>
<li><p>每组数据由 n + 1 行组成，第一行是整数 nn，表示有 n 个房子，1≤n≤10^5</p>
</li>
<li><p>接下来是 n 行，每行 3 个正整数。第 i 行的 3 个正整数分别为 cost[i][0], cost[i][1], cost[i][2]，表示给第 i 个房子刷上红黄蓝三种油漆的花费。1≤cost[i][j]≤1000</p>
</li>
<li><p>T 组数据中所有 n 的总和为 S, T≤S≤10^6</p>
</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>输出 T 行，每行一个正整数，表示为所有房子都刷上油漆且没有任意两个相邻房子的颜色相同的最小总花费</li>
</ul>
<blockquote>
<p>样例 1<br>输入<br>3<br>1<br>1 2 3</p>
<p>2<br>1 2 1<br>2 1 2</p>
<p>3<br>100 200 300<br>200 300 400<br>1 2 3</p>
<p>输出<br>1<br>2<br>401</p>
<p>提示<br>第 3 组测试用例中：<br>第一个房子选用红色油漆，花费为 100<br>第二个房子选用黄色油漆，花费为 300<br>第三个房子选用红色油漆，花费为 1<br>最小总花费为 401</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  DP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector &lt;<span class="keyword">int</span>&gt; <span class="built_in">x</span>(<span class="number">3</span>,<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 初始状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)  cin &gt;&gt; x[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; ++j)&#123;<span class="comment">// 当前房子颜色状态只与前面房子颜色相关</span></span><br><span class="line">            <span class="keyword">int</span> val;</span><br><span class="line">            cin &gt;&gt; val;</span><br><span class="line">            y[j]=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">3</span>; ++k) <span class="keyword">if</span>(j!=k)&#123; <span class="comment">//当前房子处最小花费</span></span><br><span class="line">                y[j]=<span class="built_in">min</span>(y[j], x[k]+val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);  <span class="comment">// 滚动数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res=INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)&#123;</span><br><span class="line">        res=<span class="built_in">min</span>(res, x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pa-17-刷房子II"><a href="#pa-17-刷房子II" class="headerlink" title="pa-17.刷房子II"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/17">pa-17.刷房子II</a></h2><p>小棒瓜瓜在完成了第一次 刷房子 任务后，又迎来了第二个任务。</p>
<p>现在有 n 个房子排成一排，同时有红黄蓝三种颜色的油漆，每种油漆分别有 na, nb, nc 桶。</p>
<p>刷一个房子要耗费一桶油漆，同时要求任意两个相邻房子的油漆颜色不得相同。</p>
<p>另外，即便是同一种颜色的油漆，刷不同的房子，所需的花费也是不同的。</p>
<p>现在我们得到每个房子刷上 3 种油漆的代价，请帮小棒瓜瓜计算一下，为所有房子都刷上油漆且没有任意两个相邻房子的颜色相同的总花费是多少。</p>
<p>如果无法为每个房子都刷上油漆，花费为 -1</p>
<p><strong>输入</strong></p>
<p>第一行是整数 T，表示接下来有 T 组数据，1≤T≤10</p>
<p>每组数据由 n + 1 行组成</p>
<p>第一行是整数 n, na, nb, nc，表示有 n 个房子，红黄蓝油漆的桶数分别为 na, nb, nc, 1≤n,na,nb,nc≤25，</p>
<p>接下来是 n 行，每行 3 个正整数。第 i 行的 3 个正整数分别为 cost[i][0], cost[i][1], cost[i][2]，表示给第 i 个房子刷上红黄蓝三种油漆的花费。1≤cost[i][j]≤1000</p>
<p><strong>输出</strong></p>
<p>输出 T 行，每行一个正整数，表示为所有房子都刷上油漆且没有任意两个相邻房子的颜色相同的最小花费</p>
<p>如果无法为所有房子都刷上油漆，输出 -1</p>
<blockquote>
<p>样例 1<br>输入<br>1<br>3 1 1 1<br>1 5 10<br>15 2 20<br>25 30 3</p>
<p>输出<br>6</p>
<p>提示<br>第一个房子选择红色油漆，花费为 1<br>第二个房子选择黄色油漆，花费为 2<br>第三个房子选择蓝色油漆，花费为 3<br>总花费为 6</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  DP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">4</span>][N][N][N], vis[N][<span class="number">4</span>][N][N][N];</span><br><span class="line"><span class="keyword">int</span> n, cnt[<span class="number">3</span>], cost[N][<span class="number">3</span>];<span class="comment">//房子数量n 每个颜料数量 cnt[i] 花费数组cost[n][i];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==n) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果计算过 直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vis[cur][col][cnt[<span class="number">0</span>]][cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]])</span><br><span class="line">        <span class="keyword">return</span> f[cur][col][cnt[<span class="number">0</span>]][cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">     vis[cur][col][cnt[<span class="number">0</span>]][cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span>&amp; res = f[cur][col][cnt[<span class="number">0</span>]][cnt[<span class="number">1</span>]][cnt[<span class="number">2</span>]];<span class="comment">//引用</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;<span class="number">3</span>; c++) <span class="keyword">if</span>(c !=col &amp;&amp; cnt[c] )&#123; <span class="comment">//颜料使用限制条件</span></span><br><span class="line">         cnt[c]--;</span><br><span class="line">         res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(cur+<span class="number">1</span>, c) + cost[cur][c]);</span><br><span class="line">         cnt[c]++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)   cin &gt;&gt; cnt[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; ++j)</span><br><span class="line">            cin &gt;&gt; cost[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f3f3f3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(res == INF)  res=<span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="pa-153-平面分割"><a href="#pa-153-平面分割" class="headerlink" title="pa-153.平面分割"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/153">pa-153.平面分割</a></h2><p>平面上有 n 条直线，最多把平面切割成多少块?</p>
<p>输入</p>
<p>多组测试数据，以 EOF 结束</p>
<p>每组测试数据一个整数 n (0≤n≤500)</p>
<p>输出</p>
<p>每组测试数据输出一个整数，表示最多把平面切割成多少块</p>
<p>提示</p>
<p>当 n=0 时，表示平面上没有直线，平面被视为一整块，答案是 1</p>
<blockquote>
<p>样例 1<br>输入<br>1<br>2</p>
<p>输出<br>2<br>4</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 先枚举，找找规律</span></span><br><span class="line"><span class="comment"> * f[0]=1</span></span><br><span class="line"><span class="comment"> * f[i] = f[i-1] + i （i≥1）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> f[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; ++i)&#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ( cin&gt;&gt;n )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pa-151-走楼梯"><a href="#pa-151-走楼梯" class="headerlink" title="pa-151.走楼梯"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/151">pa-151.走楼梯</a></h2><p>我们在地面上，有 n 级楼梯，能让我们上到第 n 层。</p>
<p>每次我们可以走 1 级或 2 级楼梯。问我们走完 n 级楼梯有多少种方案？</p>
<p>例：n=3，一共有 3 种可能</p>
<p>1,1,1，每次走一级，走三步</p>
<p>1,2，走两步，第一步走一级，第二步走两级</p>
<p>2,1，走两步，第一步走两级，第二步走一级</p>
<p><strong>输入</strong><br>一个整数 n(1≤n≤36)，表示有多少级楼梯</p>
<p><strong>输出</strong><br>一个整数，表示有多少种走法</p>
<blockquote>
<p>样例 1<br>输入<br>3</p>
</blockquote>
<blockquote>
<p>输出<br>3</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归，动规</span></span><br><span class="line"><span class="comment"> * f[i]=f[i−1]+f[i−2]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[n];</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>,f[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pa-157-拆分相等集合"><a href="#pa-157-拆分相等集合" class="headerlink" title="pa-157.拆分相等集合"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/157">pa-157.拆分相等集合</a></h2><p>给定正整数 n，将 1 2 3 4 5… n 这 n个数字划分到两个集合中，使得两个集合的和相等。</p>
<p>每个集合都不能为空。每个数字只能且必须在其中一个集合。两个集合的元素个数不必相等。</p>
<p>如果能成功划分则输出 <code>YES</code>，同时 <strong>输出任意一种划分方案</strong>。如果不能成功划分则输出 <code>NO</code></p>
<p><strong>输入</strong></p>
<ul>
<li>一个正整数 n (1≤n≤106)</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li><p>第一行输出 <code>YES</code> 或 <code>NO</code></p>
</li>
<li><p>如果答案为<code>YES</code>，接下来继续输出4行</p>
<ul>
<li>第一行为第一个集合的元素个数 C1</li>
</ul>
</li>
<li><p>第二行为 C1个整数，用空格分隔，表示含有哪些元素</p>
<ul>
<li>第三行为第二个集合的元素个数 C2</li>
<li>第四行为 C2个整数，用空格分隔，表示含有哪些元素</li>
</ul>
</li>
</ul>
<p><strong>提示</strong></p>
<ul>
<li>输出任意一种划分方案即可</li>
<li><strong>本题答案不是唯一，测试用例详情里的答案不予显示</strong></li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">7</span><br><span class="line">输出</span><br><span class="line">YES</span><br><span class="line">4</span><br><span class="line">1 2 4 7</span><br><span class="line">3</span><br><span class="line">3 5 6</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 证明出数组可以被平均的拆分成两半，由n(n+1)/2能被2整除条件，</span></span><br><span class="line"><span class="comment"> * 若n为偶数，那么可推导出n%4等于0,且能由偶数对的（n+1）</span></span><br><span class="line"><span class="comment"> * 若n+1为偶数，那么可推导出n%3等于0,那么就有偶数对的 n</span></span><br><span class="line"><span class="comment"> * 剩下的拆分即可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>( n%<span class="number">4</span>!=<span class="number">0</span> &amp;&amp; n%<span class="number">4</span>!=<span class="number">3</span> )&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//构造答案</span></span><br><span class="line">    <span class="comment">// n % 4 == 0，每一对的和为 n + 1</span></span><br><span class="line">    <span class="comment">// n % 4 == 3，每一对的和为 n </span></span><br><span class="line"></span><br><span class="line">    ll s = (<span class="number">1LL</span>+n)*n/<span class="number">2</span>;  <span class="comment">// 1LL 非常重要</span></span><br><span class="line">    ll h = s/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> t = n%<span class="number">4</span> ==<span class="number">0</span> ? n+<span class="number">1</span> : n;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;<span class="number">0</span> &amp;&amp; a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>()&lt;n; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h)&#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">int</span> x = t-i;</span><br><span class="line">            <span class="keyword">if</span>(x) a.<span class="built_in">push_back</span>(x);</span><br><span class="line">            h = h-t;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">int</span> x = t-i;</span><br><span class="line">            <span class="keyword">if</span>(x) b.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:a) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; b.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:b) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pa-194-抽签"><a href="#pa-194-抽签" class="headerlink" title="pa-194.抽签"></a><a target="_blank" rel="noopener" href="https://www.papamelon.com/problem/194">pa-194.抽签</a></h2><p>一个袋子中有 n<em>n</em> 个数字纸片，每张上面都写了一个数字。</p>
<p>我们有 44 次机会，每次从袋子中选一个纸片，记录下数字，然后放回去（因此一个纸片可能多次被选中）。</p>
<p>当存在一个可能，使得 44 张纸片的数字总和等于 m<em>m</em>，则输出 <code>Yes</code>，否则输出 <code>No</code></p>
<p><strong>输入</strong></p>
<ul>
<li>第一行输入整数 n (1≤n≤50)</li>
<li>第二行输入整数 m (1≤m≤108)</li>
<li>第三行输入 n 个整数，表示每个纸片上的数字 k_i (1≤k_i≤108)</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>一行，<code>Yes</code> 或 <code>No</code></li>
</ul>
<p><strong>样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">3</span><br><span class="line">10</span><br><span class="line">1 3 5</span><br><span class="line">输出</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-11-14 10:51:29</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-11-14 11:32:52</span></span><br><span class="line"><span class="comment"> * @Description: 暴力枚举  unordered_set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">k</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) cin &gt;&gt; k[i];</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(k[i] + k[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> x : res)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = m-x;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">count</span>(tmp))&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="数组-字符串"><a href="#数组-字符串" class="headerlink" title="数组/字符串"></a>数组/字符串</h1><h2 id="LC-14-最长公共前缀"><a href="#LC-14-最长公共前缀" class="headerlink" title="LC-14.最长公共前缀"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-prefix/">LC-14.最长公共前缀</a></h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br><span class="line"></span><br><span class="line">输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，</span></span><br><span class="line"><span class="comment"> * 如果相同则继续对下一列进行比较，</span></span><br><span class="line"><span class="comment"> * 如果不相同则当前列不再属于公共前缀，</span></span><br><span class="line"><span class="comment"> * 当前列之前的部分为最长公共前缀。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = strs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> count = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].<span class="built_in">size</span>() || strs[j][i] != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="合并k个有序数组"><a href="#合并k个有序数组" class="headerlink" title="合并k个有序数组"></a>合并k个有序数组</h2><p>假定有k个有序数组，每个数组中含有n个元素，您的任务是将它们合并为单独的一个有序数组，该数组共有kn个元素。设计和实现 一个有效的分治算法解决k-路合并操作问题，并分析时间复杂度。</p>
<p>时间复杂度：O(nlogk)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mergeTowArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;A,vector&lt;<span class="keyword">int</span>&gt;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">    temp.<span class="built_in">resize</span>(A.<span class="built_in">size</span>() + B.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, j = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; A.<span class="built_in">size</span>() &amp;&amp; j &lt; B.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; B[j])</span><br><span class="line">            temp[index++] = A[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[index++] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            temp[index++] = A[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            temp[index++] = B[j++];</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">kMergeSort</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;A, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span> A[start];</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;Left = <span class="built_in">kMergeSort</span>(A, start, mid);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;Right = <span class="built_in">kMergeSort</span>(A, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mergeTowArrays</span>(Left, Right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mergeSortArrays</span><span class="params">(vector &lt;vector&lt;<span class="keyword">int</span>&gt;&gt;A)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">empty</span>() || A.<span class="built_in">size</span>() == <span class="number">0</span> || A[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    temp = <span class="built_in">kMergeSort</span>(A, <span class="number">0</span>, A.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><p>从键盘输入一个string字符串  ‘’m=2,n=3’。现在要把字符串中的数字2和3提取出来分别赋值给两个 int 类型变量 a 和 b</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * c++中引入了流的概念</span></span><br><span class="line"><span class="comment"> * stringstream ss;</span></span><br><span class="line"><span class="comment"> * ss &lt;&lt; t;//向流中传值</span></span><br><span class="line"><span class="comment"> * ss &gt;&gt; res;//向res中写入值，可用作int转string</span></span><br><span class="line"><span class="comment"> * cout &lt;&lt; ss.str(); //cout 输出</span></span><br><span class="line"><span class="comment"> * printf(&quot;%s\n&quot;, ss.str().c_str()); //printf 输出</span></span><br><span class="line"><span class="comment"> * stringstream清空，ss.str(&quot;&quot;);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * getline()函数的定义</span></span><br><span class="line"><span class="comment"> * 	- istream&amp; getline ( istream &amp;is , string &amp;str , char delim );</span></span><br><span class="line"><span class="comment"> * 	- is 进行读入操作的输入流 </span></span><br><span class="line"><span class="comment"> * 	- str 用来存储读入的内容</span></span><br><span class="line"><span class="comment"> * 	- delim 终结符，遇到该字符停止读取操作，不写的话默认为回车</span></span><br><span class="line"><span class="comment"> * while(getline(cin,str)) 会一直循环，因为回车只会终止getline()函数的读入操作。</span></span><br><span class="line"><span class="comment"> * getline()函数终止后又进行while（）判断（即判断输入流是否有效，你的输入流当然有效，满足条件）</span></span><br><span class="line"><span class="comment"> * 所以又运行getline()函数，导致程序永远跳不出循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">     cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp.<span class="built_in">substr</span>(tmp.<span class="built_in">size</span>()<span class="number">-1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;data.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-01 18:45:34</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-02 10:42:23</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">     cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">int</span> idx = s.<span class="built_in">find</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(<span class="number">2</span>, idx - <span class="number">2</span>));</span><br><span class="line">    n = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(idx + <span class="number">3</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; m &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h2><p>给出一个二维字符数组和一个单词，判断单词是否在数组中出现，</p>
<p>单词由相邻单元格的字母连接而成，相邻单元指的是上下左右相邻。同一单元格的字母不能多次使用。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给出的字符数组=</span><br><span class="line">[</span><br><span class="line">  [&quot;XYZE&quot;],</span><br><span class="line">  [&quot;SFZS&quot;],</span><br><span class="line">  [&quot;XDEE&quot;]</span><br><span class="line">]</span><br><span class="line">单词 =&quot;XYZZED&quot;, -&gt; 返回 true,</span><br><span class="line">单词 =&quot;SEE&quot;, -&gt;返回 true,</span><br><span class="line">单词 =&quot;XYZY&quot;, -&gt; 返回 fXlse.</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ DFS backtracking 的算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOut</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c&lt;<span class="number">0</span> || c&gt;=cols || r&lt;<span class="number">0</span> || r&gt;=rows;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="keyword">int</span> r, <span class="keyword">int</span> c, string &amp;word, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=word.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isOut</span>(r, c, board.<span class="built_in">size</span>(), board[<span class="number">0</span>].<span class="built_in">size</span>())||word[start]!=board[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dx[]=&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[]=&#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> tmp=board[r][c];</span><br><span class="line">        board[r][c]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">DFS</span>(board, r+dx[i], c+dy[i], word, start+<span class="number">1</span>))</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[r][c]=tmp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt; &gt; &amp;board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows=board.<span class="built_in">size</span>(), cols=board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;rows; ++r)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;cols; ++c)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[r][c]==word[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">DFS</span>(board, r, c, word, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="LC-4-寻找两个正序数组的中位数"><a href="#LC-4-寻找两个正序数组的中位数" class="headerlink" title="LC-4.寻找两个正序数组的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">LC-4.寻找两个正序数组的中位数</a></h2><h2 id="定长子数组和"><a href="#定长子数组和" class="headerlink" title="定长子数组和!!"></a>定长子数组和!!</h2><h2 id="最大子矩阵和"><a href="#最大子矩阵和" class="headerlink" title="最大子矩阵和"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43175029/article/details/94592427">最大子矩阵和</a></h2><h1 id="链表-树"><a href="#链表-树" class="headerlink" title="链表/树"></a>链表/树</h1><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p><strong>二叉树定义</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>递归</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*前序遍历*/</span></span><br><span class="line">    <span class="comment">//1.确定递归函数的参数和返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preordertraversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        <span class="comment">//2.确定终⽌条件</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//3.确定单层递归的逻辑</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);            <span class="comment">// 根</span></span><br><span class="line">        <span class="built_in">preordertraversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">preordertraversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*中序遍历*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inordertraversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inordertraversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);           <span class="comment">// 根</span></span><br><span class="line">        <span class="built_in">inordertraversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*后序遍历*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postordertraversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">postordertraversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">postordertraversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);             <span class="comment">// 根</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">preordertraversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>迭代</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*前序遍历*/</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; st;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">/*根入栈，出栈；右子树进栈，左子树进栈；左子树出栈，右子树出栈*/</span></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode *node = st.<span class="built_in">top</span>(); <span class="comment">// 根</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                st.<span class="built_in">push</span>(node-&gt;left);  <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*中序遍历*/</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode *&gt; st;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>)&#123; <span class="comment">//指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur);    <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left; <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出数据就是要处理的数据（放进result数组）</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 根</span></span><br><span class="line">                cur = cur-&gt;right;           <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*后序遍历*/</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; st;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode *node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                st.<span class="built_in">push</span>(node-&gt;left);  <span class="comment">// 相对于前序遍历，更改入栈顺序（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">                st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果翻转之后就是左右根的顺序</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>层序遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode *root)&#123;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size()是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="LC-2-两数之和"><a href="#LC-2-两数之和" class="headerlink" title="LC-2.两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">LC-2.两数之和</a></h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2--&gt;4--&gt;3</span><br><span class="line">5--&gt;6--&gt;4</span><br><span class="line">----------</span><br><span class="line">7--&gt;0--&gt;8</span><br><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]       </span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br><span class="line"></span><br><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br><span class="line"></span><br><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br><span class="line">9--&gt;9--&gt;9--&gt;9--&gt;9--&gt;9--&gt;9</span><br><span class="line">9--&gt;9--&gt;9--&gt;9</span><br><span class="line">-------------------------</span><br><span class="line">8--&gt;9--&gt;9--&gt;9--&gt;0--&gt;0--&gt;0--&gt;1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur = res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( l1 || l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> val1 = l1? l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> val2 = l2? l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = (val1 + val2 +c);</span><br><span class="line">            c = sum/<span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(l1) l1=l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c) cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>); <span class="comment">//最后还有进位的情况，case3</span></span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="LC-21-合并两个有序链表"><a href="#LC-21-合并两个有序链表" class="headerlink" title="LC-21.合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">LC-21.合并两个有序链表</a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br><span class="line"></span><br><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = preHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LC-23-合并k个有序升序链表"><a href="#LC-23-合并k个有序升序链表" class="headerlink" title="LC-23.合并k个有序升序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">LC-23.合并k个有序升序链表</a></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  分治</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;; </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 合并两个有序链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge2</span><span class="params">(ListNode* p1, ListNode* p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p1) <span class="keyword">return</span> p2;</span><br><span class="line">        <span class="keyword">if</span>(!p2) <span class="keyword">return</span> p1;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val &lt;= p2-&gt;val)&#123;</span><br><span class="line">            p1-&gt;next = <span class="built_in">merge2</span>(p1-&gt;next, p2);</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p2-&gt;next = <span class="built_in">merge2</span>(p1, p2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span> lists[start];</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        ListNode* l1 = <span class="built_in">merge</span>(lists, start, mid);</span><br><span class="line">        ListNode* l2 = <span class="built_in">merge</span>(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="JZ-24-翻转链表"><a href="#JZ-24-翻转链表" class="headerlink" title="JZ-24.翻转链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">JZ-24.翻转链表</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 迭代</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next; <span class="comment">// 暂存后继节点 cur.next</span></span><br><span class="line">            cur-&gt;next = pre;           <span class="comment">// 修改 next 引用指向</span></span><br><span class="line">            pre = cur;                 <span class="comment">// pre 暂存 cur</span></span><br><span class="line">            cur = tmp;                 <span class="comment">// cur 访问下一节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">时间复杂度 <span class="built_in">O</span>(N) ： 遍历链表使用线性大小时间。</span><br><span class="line">空间复杂度 <span class="built_in">O</span>(<span class="number">1</span>) ： 变量 pre 和 cur 使用常数大小额外空间</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*递归*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* newhead=<span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next=head;</span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">时间复杂度 <span class="built_in">O</span>(N) ： 遍历链表使用线性大小时间。</span><br><span class="line">空间复杂度 <span class="built_in">O</span>(N) ： 遍历链表的递归深度达到 N，系统使用 <span class="built_in">O</span>(N) 大小额外空间。</span><br></pre></td></tr></table></figure>

<h2 id="LC-92-反转链表-II"><a href="#LC-92-反转链表-II" class="headerlink" title="LC-92.反转链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">LC-92.反转链表 II</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br><span class="line"></span><br><span class="line">输入：head = [5], left = 1, right = 1</span><br><span class="line">输出：[5]</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummyNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">时间复杂度：<span class="built_in">O</span>(N)，其中 N 是链表总节点数。最多只遍历了链表一次，就完成了反转。</span><br><span class="line">空间复杂度：<span class="built_in">O</span>(<span class="number">1</span>)。只使用到常数个变量。</span><br></pre></td></tr></table></figure>



<h2 id="LC-141-环形链表"><a href="#LC-141-环形链表" class="headerlink" title="LC-141.环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">LC-141.环形链表</a></h2><p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p><strong>进阶：</strong></p>
<p>你能用 *O(1)*（即，常量）内存解决此问题吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line"> 3--&gt;2--&gt;0--&gt;-4--</span><br><span class="line"> 	 ^           |</span><br><span class="line"> 	 |___________|		 </span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  快慢指针，快指针每次走两步，慢指针每次走一步</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LC-42-环形链表-II"><a href="#LC-42-环形链表-II" class="headerlink" title="LC-42. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">LC-42. 环形链表 II</a></h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<p>进阶：</p>
<p>你是否可以使用 O(1) 空间解决此题？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点</span><br></pre></td></tr></table></figure>





<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast=head, *slow=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span> || fast-&gt;next==<span class="literal">nullptr</span>)  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快慢指针 fast  slow</span></span><br><span class="line"><span class="comment"> * 链表头到环的长度为 a，环的长度为 b</span></span><br><span class="line"><span class="comment"> * 第一次相遇时：</span></span><br><span class="line"><span class="comment"> *  - fast 走的步数是 slow 步数的 2倍，即 f = 2s</span></span><br><span class="line"><span class="comment"> *  - fast 比 slow 多走了 n 个环的长度，即 f = s + nb</span></span><br><span class="line"><span class="comment"> *  - 可推导得 f = 2s = 2nb</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果让指针从链表头部一直向前走并统计步数 k，那么所有走到链表入口节点时的步数是</span></span><br><span class="line"><span class="comment"> * k = a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）</span></span><br><span class="line"><span class="comment"> * 第一次相遇时 slow 走了 nb 步。因此只要再让 slow 走 a 步停下来，就可以到环的入口</span></span><br><span class="line"><span class="comment"> * 令 fast = head, slow不变，此时： f = 0, s = nb</span></span><br><span class="line"><span class="comment"> * 第二次相遇时：</span></span><br><span class="line"><span class="comment"> *  - f = a, s = a + nb</span></span><br><span class="line"><span class="comment"> * 返回 fast 指针指向的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2 id="LC-146-LRU缓存机制"><a href="#LC-146-LRU缓存机制" class="headerlink" title="LC-146.LRU缓存机制"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">LC-146.LRU缓存机制</a></h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p>
<ul>
<li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li>
<li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>
<li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ul>
<p><strong>进阶</strong>：你是否可以在 O(1) 时间复杂度内完成这两种操作？<strong>双向链表插入、删除时间复杂度 O(1)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
<ul>
<li>1 &lt;= capacity &lt;= 3000</li>
<li>0 &lt;= key &lt;= 10000</li>
<li>0 &lt;= value &lt;= 10^5</li>
<li>最多调用 2 * 10^5 次 get 和 put</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">      <span class="keyword">int</span> key, val;</span><br><span class="line">      Node *pre, *next;</span><br><span class="line">      <span class="built_in">Node</span>(<span class="keyword">int</span> k, <span class="keyword">int</span> v)&#123;</span><br><span class="line">          key = k;</span><br><span class="line">          val = v;</span><br><span class="line">          pre = next = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node *head, *tail;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, Node*&gt; pos;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        c = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos.<span class="built_in">count</span>(key)==<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        Node* ptr = pos[key];</span><br><span class="line">        <span class="built_in">remove</span>(ptr);   <span class="comment">//先从双向链表中删除</span></span><br><span class="line">        <span class="built_in">insert</span>(ptr);   <span class="comment">//再插入到head节点后</span></span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos.<span class="built_in">count</span>(key)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//insert (增加节点)</span></span><br><span class="line">            <span class="keyword">if</span>(pos.<span class="built_in">size</span>()==c)&#123;</span><br><span class="line">                Node* ptr = tail-&gt;pre;</span><br><span class="line">                <span class="built_in">remove</span>(ptr);</span><br><span class="line">                pos.<span class="built_in">erase</span>(ptr-&gt;key);</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            Node* ptr = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">            pos[ptr-&gt;key] = ptr;</span><br><span class="line">            <span class="built_in">insert</span>(ptr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update (不会增加节点)</span></span><br><span class="line">        Node* ptr = pos[key];</span><br><span class="line">        ptr-&gt;val = value;</span><br><span class="line">        <span class="built_in">remove</span>(ptr);</span><br><span class="line">        <span class="built_in">insert</span>(ptr); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node* ptr)</span></span>&#123;</span><br><span class="line">        Node* a = ptr-&gt;pre;</span><br><span class="line">        Node* b = ptr-&gt;next;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        b-&gt;pre = a;</span><br><span class="line"></span><br><span class="line">        ptr-&gt;pre = ptr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* ptr)</span></span>&#123;</span><br><span class="line">        Node* a = head-&gt;next;</span><br><span class="line">        a-&gt;pre = ptr;</span><br><span class="line">        ptr-&gt;next = a;</span><br><span class="line">        ptr-&gt;pre = head;</span><br><span class="line">        head-&gt;next= ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span> </span><br></pre></td></tr></table></figure>
<h2 id="JZ-22-链表中倒数第k个节点"><a href="#JZ-22-链表中倒数第k个节点" class="headerlink" title="JZ-22.链表中倒数第k个节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">JZ-22.链表中倒数第k个节点</a></h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *former=head, *latter=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; ++i)&#123;</span><br><span class="line">            former = former-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(former!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            former = former-&gt;next;</span><br><span class="line">            latter = latter-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * head: [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"> * k: 2</span></span><br><span class="line"><span class="comment"> * former: [3,4,5]         [4,5]        [5]          []</span></span><br><span class="line"><span class="comment"> * latter: [1,2,3,4,5]     [2,3,4,5]    [3,4,5]      [4,5]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="LC-19-删除链表中倒数第k个节点"><a href="#LC-19-删除链表中倒数第k个节点" class="headerlink" title="LC-19.删除链表中倒数第k个节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LC-19.删除链表中倒数第k个节点</a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br><span class="line"></span><br><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">getLength</span>(head);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="JZ-40-最小的k个数"><a href="#JZ-40-最小的k个数" class="headerlink" title="JZ-40.最小的k个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">JZ-40.最小的k个数</a></h2><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<blockquote>
<p>0 &lt;= k &lt;= arr.length &lt;= 10000<br>0 &lt;= arr[i] &lt;= 10000</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=left, j=right;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//初始化随机数种子 </span></span><br><span class="line">        <span class="keyword">int</span> rd = <span class="built_in">rand</span>()%(right-left+<span class="number">1</span>)+left;</span><br><span class="line">        <span class="built_in">swap</span>(nums[rd], nums[right]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[i]&lt;=nums[right]) i++;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[j]&gt;=nums[right]) j--;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[right]);</span><br><span class="line">        <span class="keyword">return</span> i;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="built_in">partition</span>(arr,left,right);</span><br><span class="line">            <span class="keyword">if</span>(pos==k<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos&lt;k<span class="number">-1</span>) left=pos+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos&gt;k<span class="number">-1</span>) right=pos<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span> || k &gt; nums.<span class="built_in">size</span>()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">quick_sort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>,k);</span><br><span class="line">        res.<span class="built_in">assign</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">begin</span>()+k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="JZ2-53-二叉搜索树的中序后继"><a href="#JZ2-53-二叉搜索树的中序后继" class="headerlink" title="JZ2-53.二叉搜索树的中序后继"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/P5rCT8/">JZ2-53.二叉搜索树的中序后继</a></h2><p>给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null </p>
<p>节点 p 的后继是值比 p.val 大的节点中键值最小的节点，即按中序遍历的顺序节点 p 的下一个节点</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3], p = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：这里 1 的中序后继是 2</span><br><span class="line"></span><br><span class="line">输入：root = [5,3,6,2,4,null,null,1], p = 6</span><br><span class="line">输出：0</span><br><span class="line">解释：因为给出的节点没有中序后继，所以答案就返回 0</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<blockquote>
<p>树中节点的数目在范围 [1, 104] 内。<br>-105 &lt;= Node.val &lt;= 105<br>树中各节点的值均保证唯一。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 二叉树的中序遍历</span></span><br><span class="line"><span class="comment"> * found 来标记是否已经遍历到节点 p, found 的初始值为 fasle</span></span><br><span class="line"><span class="comment"> * 遍历到节点 p 之后置为 true，在这个变量变为 true 之后第一个遍历到的节点就是结果</span></span><br><span class="line"><span class="comment"> * 二叉搜索树的高度为 h,节点数为 n, 时间复杂度为 O(n)，空间复杂度为 O(h)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">inorderSuccessor</span><span class="params">(TreeNode *root, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; sta;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                sta.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (found)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;val == p)&#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeNode *dummy = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">    TreeNode *tmp = dummy;</span><br><span class="line">    tmp-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    tmp-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">6</span>);</span><br><span class="line">    tmp = tmp-&gt;left;</span><br><span class="line">    tmp-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    tmp-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    tmp = tmp-&gt;left;</span><br><span class="line">    tmp-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    res = <span class="built_in">Solution</span>().<span class="built_in">inorderSuccessor</span>(dummy, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JZ-54-二叉搜索数的第k大节点"><a href="#JZ-54-二叉搜索数的第k大节点" class="headerlink" title="JZ-54.二叉搜索数的第k大节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">JZ-54.二叉搜索数的第k大节点</a></h2><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p><strong>示例 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<blockquote>
<p>1 ≤ k ≤ 二叉搜索树元素个数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  迭代</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k=k;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> res,k;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(--k==<span class="number">0</span>)&#123;</span><br><span class="line">            res=root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 递归  + 中序遍历 【 左 根 右】</span></span><br><span class="line"><span class="comment"> * 求第k大节点， 中序倒序遍历即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur -&gt; right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// ans.insert(ans.begin(), cur -&gt; val);</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur = cur -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[k <span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="二叉搜索数的第k小节点"><a href="#二叉搜索数的第k小节点" class="headerlink" title="二叉搜索数的第k小节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">二叉搜索数的第k小节点</a></h2><p><strong>示例 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = k;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res, count;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)  <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(--count==<span class="number">0</span>)&#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<p>小汪作为一个有数学天分的程序猿，设计了一套密码生成器来搞定自己的密码问题。<br>密码生成器由N个槽位组成，槽位的下标为0~N-1，每个槽位存储一个数。起初每个槽位都是0。<br>密码生成器会进行M轮计算，每轮计算，小汪会输入两个数L,R(L&lt;=R),密码生成器会将这两个数作为下标，将两个下标之间（包含）的所有槽位赋值为i（i为当前的轮次，i∈[1,M]）。<br>M轮计算完成后，密码生成器会根据槽位的最终值生成一条密码，密码的生成规则为：<br>（0<em>a[0] + 1</em>a[1] + 2*a[2] + … + (N-1)*a[N-1]) mod 100000009<br>其中a[i]表示第i个槽位的最终值。<br>请帮助小汪把他的密码生成器实现为代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lchild(x) ((x) &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rchild(x) (((x) &lt;&lt; 1) + 1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">100000009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">9</span>)<span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">op</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="comment">//[l, r]的区间和</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sum</span><span class="params">(ll l, ll r)</span> </span>&#123;<span class="keyword">return</span> (l + r) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> x[maxn &lt;&lt; <span class="number">1</span>], x_size, realx_size, c[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> L, R;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> value, tag_Set;</span><br><span class="line">    &#125;nodes[maxn &lt;&lt; <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">SegmentTree</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(nodes, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(nodes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        nodes[root].value = nodes[<span class="built_in">Lchild</span>(root)].value + nodes[<span class="built_in">Rchild</span>(root)].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        nodes[root].tag_Set = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r)nodes[root].value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">Lchild</span>(root), l, m);</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">Rchild</span>(root), m + <span class="number">1</span>, r);</span><br><span class="line">            <span class="built_in">pushup</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nodes[root].tag_Set) &#123;</span><br><span class="line">            nodes[<span class="built_in">Lchild</span>(root)].tag_Set = nodes[<span class="built_in">Rchild</span>(root)].tag_Set = nodes[root].tag_Set;</span><br><span class="line">            nodes[<span class="built_in">Lchild</span>(root)].value = (m - l + <span class="number">1</span>) * nodes[root].tag_Set;</span><br><span class="line">            nodes[<span class="built_in">Rchild</span>(root)].value = (r - m) * nodes[root].tag_Set;</span><br><span class="line">            nodes[root].tag_Set = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">updateSet</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> curl, <span class="keyword">int</span> curr, <span class="keyword">int</span> tarl, <span class="keyword">int</span> tarr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tarr &lt; curl || curr &lt; tarl)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (tarl &lt;= curl &amp;&amp; curr &lt;= tarr) &#123;</span><br><span class="line">            nodes[root].tag_Set = k;</span><br><span class="line">            nodes[root].value = (curr - curl + <span class="number">1</span>) * k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(root, curl, curr);</span><br><span class="line">        <span class="keyword">int</span> m = (curl + curr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tarl &lt;= m) <span class="built_in">updateSet</span>(<span class="built_in">Lchild</span>(root), curl, m, tarl, tarr, k);</span><br><span class="line">        <span class="keyword">if</span> (tarr &gt; m) <span class="built_in">updateSet</span>(<span class="built_in">Rchild</span>(root), m + <span class="number">1</span>, curr, tarl, tarr, k);</span><br><span class="line">        <span class="built_in">pushup</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> curl, <span class="keyword">int</span> curr, <span class="keyword">int</span> tarl, <span class="keyword">int</span> tarr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tarr &lt; curl || curr &lt; tarl)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tarl &lt;= curl &amp;&amp; curr &lt;= tarr) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodes[root].value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(root, curl, curr);</span><br><span class="line">        <span class="keyword">int</span> m = (curl + curr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tarl &lt;= m) ret += <span class="built_in">query</span>(<span class="built_in">Lchild</span>(root), curl, m, tarl, tarr);</span><br><span class="line">        <span class="keyword">if</span> (tarr &gt; m) ret += <span class="built_in">query</span>(<span class="built_in">Rchild</span>(root), m + <span class="number">1</span>, curr, tarl, tarr);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">SegmentTree tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        x[++x_size] = a[i].l = <span class="built_in">read</span>();</span><br><span class="line">        x[++x_size] = a[i].r = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(x + <span class="number">1</span>, x + x_size + <span class="number">1</span>);</span><br><span class="line">    realx_size = <span class="built_in">unique</span>(x + <span class="number">1</span>, x + x_size + <span class="number">1</span>) - x - <span class="number">1</span>;</span><br><span class="line">    x_size = realx_size;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x_size; ++i)</span><br><span class="line">        <span class="keyword">if</span>(x[i] - x[i - <span class="number">1</span>] &gt; <span class="number">1</span>) x[++realx_size] = x[i] - <span class="number">1</span>, x[++realx_size] = x[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    x_size = realx_size;</span><br><span class="line">    <span class="built_in">sort</span>(x + <span class="number">1</span>, x + x_size + <span class="number">1</span>);</span><br><span class="line">    realx_size = <span class="built_in">unique</span>(x + <span class="number">1</span>, x + x_size + <span class="number">1</span>) - x - <span class="number">1</span>;</span><br><span class="line">    tree.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, realx_size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        L = <span class="built_in">lower_bound</span>(x + <span class="number">1</span>, x + realx_size + <span class="number">1</span>, a[i].l) - x;</span><br><span class="line">        R = <span class="built_in">lower_bound</span>(x + <span class="number">1</span>, x + realx_size + <span class="number">1</span>, a[i].r) - x;</span><br><span class="line">        tree.<span class="built_in">updateSet</span>(<span class="number">1</span>, <span class="number">1</span>, realx_size, L, R, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= realx_size; ++i)</span><br><span class="line">        c[i] = tree.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, realx_size, i, i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; realx_size; ++i)</span><br><span class="line">        ans = (ans + <span class="built_in">sum</span>(x[i], x[i + <span class="number">1</span>] - <span class="number">1</span>) * (<span class="number">1ll</span> * c[i])) % MOD;</span><br><span class="line">    ans = (ans + x[realx_size] * (<span class="number">1ll</span> * c[realx_size])) % MOD;</span><br><span class="line">    <span class="built_in">write</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><strong>接雨水</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">LC-42.接雨水</a></p>
<h1 id="堆-栈"><a href="#堆-栈" class="headerlink" title="堆/栈"></a>堆/栈</h1><h2 id="LC-20-有效的括号"><a href="#LC-20-有效的括号" class="headerlink" title="LC-20.有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">LC-20.有效的括号</a></h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">输入：s = &quot;([)]&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">输入：s = &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; pairs = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pairs.<span class="built_in">count</span>(ch)) &#123; <span class="comment">//左括号为0，压入栈</span></span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != pairs[ch]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="棋盘-最短路径"><a href="#棋盘-最短路径" class="headerlink" title="棋盘 最短路径"></a>棋盘 最短路径</h1><p>重要</p>
<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="0831-pdd01"><a href="#0831-pdd01" class="headerlink" title="0831-pdd01"></a>0831-pdd01</h2><p><strong>输入描述：</strong></p>
<blockquote>
<p>第一行包含一个整数 T (1&lt;=T&lt;=5)，表示有 T 组数据</p>
<p>接下俩魅族数据三行输入，第一行包含3个整数 n，m，k(1&lt;=n,m&lt;=10000,0&lt;=k&lt;=100)</p>
<p>分别表示红色方块数，蓝色方块数和能配对消除的最大数字差异</p>
<p>第二行包含n个整数，ai（1&lt;=ai&lt;=100）表示第 i 个红色方块上的数字</p>
<p>第三行包含n个整数，bi（1&lt;=bi&lt;=100）表示第 i 个蓝色方块上的数字</p>
</blockquote>
<p><strong>输出描述：</strong></p>
<blockquote>
<p>每组数据输出一行ans，表示该剧游戏最多能获得的分数</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">1</span><br><span class="line">3 4 1</span><br><span class="line">5 2 3</span><br><span class="line">1 2 9 7</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">说明</span><br><span class="line">第1组数据中</span><br><span class="line">第2个红色方块和第1个蓝色方块配对消除</span><br><span class="line">第3个红色方块和第2个蓝色方块配对消除</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-08-31 23:51:48</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-01 15:54:31</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,T;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn],match[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;cin&gt;&gt;a[i];&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;cin&gt;&gt;b[i];&#125;</span><br><span class="line">        <span class="built_in">sort</span>(a,a+n);<span class="built_in">sort</span>(b,b+m);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;m) &#123;</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">abs</span>(a[i]-b[j]) &lt;= k )&#123;</span><br><span class="line">                i++,j++;</span><br><span class="line">                ans ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(b[j]-a[i] &gt; k ) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]-b[j] &gt; k ) j++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0831-pdd02"><a href="#0831-pdd02" class="headerlink" title="0831-pdd02"></a>0831-pdd02</h2><p>一个字符串，长为<code>len</code>，对于<code> 0&lt;= i &lt;= len-1</code>，字符串下标<code>i</code>和<code> len -1 -i</code>可以交换位置</p>
<p>给定两个字符串 a，b，a的任何状态的字典序小于 b 的任何状态的字典序，则a&lt;b</p>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">2</span><br><span class="line">dcba</span><br><span class="line">abcd</span><br><span class="line">输出</span><br><span class="line">dcba</span><br><span class="line">abcd</span><br><span class="line">说明：2代表接下来2行输入2个字符串，字典序相等时优先输出先输入的字符串</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">2</span><br><span class="line">abcde</span><br><span class="line">abcdeaf</span><br><span class="line">输出</span><br><span class="line">abcdeaf</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义排序</span></span><br><span class="line"><span class="comment"> * 比较待排序字符串数组的minstring</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minstring</span><span class="params">(string &amp;s)</span></span>&#123; <span class="comment">//传引用，形参修饰实参</span></span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len/<span class="number">2</span>; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[j]&gt;s[len<span class="number">-1</span>-j]) <span class="built_in">swap</span>(s[j],s[len<span class="number">-1</span>-j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(string s1, string s2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">minstring</span>(s1);</span><br><span class="line">    <span class="built_in">minstring</span>(s2);</span><br><span class="line">    <span class="keyword">return</span> s1 &lt; s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)  cin &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        cout &lt;&lt; s[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="0831-pdd03"><a href="#0831-pdd03" class="headerlink" title="0831-pdd03"></a>0831-pdd03</h2><p>有n根火柴，最多能拼成多少个1*1的小正方形</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 数学模拟</span></span><br><span class="line"><span class="comment"> * 假设先凑一个边长m的正方形，则一共需要2m(m+1)根火柴</span></span><br><span class="line"><span class="comment"> * 先开根求m，然后一次模拟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll m = <span class="built_in">sqrt</span>(n / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        ll ans = m * m;</span><br><span class="line">        n -= <span class="number">2</span> * (m + <span class="number">1</span>) * m;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//一侧开始外扩</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">3</span>)</span><br><span class="line">                ans++, n -= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">2</span> * m - <span class="number">2</span>)&#123;</span><br><span class="line">                ans += m - <span class="number">1</span>;</span><br><span class="line">                n -= <span class="number">2ll</span> * m - <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans += n / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//另一侧开始外扩</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">3</span>)</span><br><span class="line">                ans++, n -= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">2</span> * m)&#123;</span><br><span class="line">                ans += m;</span><br><span class="line">                n -= <span class="number">2ll</span> * m;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans += n / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="0901-小米"><a href="#0901-小米" class="headerlink" title="0901-小米"></a>0901-小米</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">LC-88.合并两个有序数组(小米笔试)</a></p>
<p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br><span class="line"></span><br><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line"></span><br><span class="line">输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<blockquote>
<ul>
<li>nums1.length == m + n</li>
<li>nums2.length == n</li>
<li>0 &lt;= m, n &lt;= 200</li>
<li>1 &lt;= m + n &lt;= 200</li>
<li>-10^9 &lt;= nums1[i], nums2[j] &lt;= 10^9</li>
</ul>
</blockquote>
<p><strong>设计实现一个时间复杂度为 O(m + n) 的算法解决此问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-02 22:12:46</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-02 22:35:20</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt; &amp;nums2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = m + m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span>)</span><br><span class="line">            nums1[len--] = nums2[j--];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">            nums1[len--] = nums1[i--];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j])</span><br><span class="line">            nums1[len--] = nums2[j--];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums1[len--] = nums1[i--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int idx = s.find(&#x27;,&#x27;);</span></span><br><span class="line">    <span class="comment">// m = stoi(s.substr(2, idx - 2));</span></span><br><span class="line">    <span class="comment">// n = stoi(s.substr(idx + 3, s.size() - 1));</span></span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ss,tmp,<span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp.<span class="built_in">substr</span>(<span class="number">2</span>,tmp.<span class="built_in">size</span>()<span class="number">-1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    m = data[<span class="number">0</span>], n=data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(m + n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge</span>(a, m, b, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a[a.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> * m=3,n=3</span></span><br><span class="line"><span class="comment"> * 1 2 3</span></span><br><span class="line"><span class="comment"> * 2 5 6</span></span><br><span class="line"><span class="comment"> * 输出：</span></span><br><span class="line"><span class="comment"> * 1 2 2 3 5 6</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="0906-莉莉丝01"><a href="#0906-莉莉丝01" class="headerlink" title="0906-莉莉丝01"></a>0906-莉莉丝01</h2><p>有一个链表，头节点为head，先要对链表重新排序，排序规则如下，即以链表头元素为初始节点，原链表的节点一次作为新链表的为节点和头节点插入链表，返回新的链表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">输入</span><br><span class="line">1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line">输出</span><br><span class="line">5-&gt;3-&gt;1-&gt;2-&gt;4</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双向队列 deque</span></span><br><span class="line"><span class="comment"> * 使用dummy节点新建链表 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">formatList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        deque&lt;ListNode *&gt; de;</span><br><span class="line">        de.<span class="built_in">push_back</span>(head);</span><br><span class="line">        ListNode *cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                de.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                de.<span class="built_in">push_front</span>(cur);</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *tmp = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; de.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            tmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(de[i]-&gt;val);</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//新建链表，并输出</span></span><br><span class="line">    <span class="comment">// ListNode *myhead = new ListNode(1);</span></span><br><span class="line">    <span class="comment">// ListNode *a = myhead, *b;</span></span><br><span class="line">    <span class="comment">// for (int i = 2; i &lt; 6; ++i)&#123;</span></span><br><span class="line">    <span class="comment">//     b = new ListNode(i);</span></span><br><span class="line">    <span class="comment">//     a-&gt;next = b;</span></span><br><span class="line">    <span class="comment">//     a = b;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// while (myhead-&gt;next)&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; myhead-&gt;val &lt;&lt; &quot;-&gt;&quot;;</span></span><br><span class="line">    <span class="comment">//     myhead = myhead-&gt;next;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; myhead-&gt;val &lt;&lt; endl;\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode *tmp = dummy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; ++i)&#123;</span><br><span class="line">        tmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i);</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    res = <span class="built_in">Solution</span>().formatList(dummy-&gt;next);</span><br><span class="line">    <span class="keyword">while</span>(res-&gt;next)&#123;</span><br><span class="line">        cout &lt;&lt; res-&gt;val &lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0906-莉莉丝02"><a href="#0906-莉莉丝02" class="headerlink" title="0906-莉莉丝02"></a>0906-莉莉丝02</h2><p>有一个链表，头节点为head，先要对链表重新排序，排序规则如下，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">输入</span><br><span class="line">2-&gt;1-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出</span><br><span class="line">1-&gt;2-&gt;3-&gt;1-&gt;2</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">3-&gt;2-&gt;3-&gt;1-&gt;1-&gt;3</span><br><span class="line">输出</span><br><span class="line">1-&gt;2-&gt;3-&gt;1-&gt;3-&gt;3</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * max_element</span></span><br><span class="line"><span class="comment"> * vector&lt;pair&lt;int, int&gt;&gt; vec</span></span><br><span class="line"><span class="comment"> * 千万别 unordered_map&lt;ListNode*, int&gt; mp</span></span><br><span class="line"><span class="comment"> * 新建链表，输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur)&#123;</span><br><span class="line">            mp[cur-&gt;val]++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : mp)</span><br><span class="line">            vec.<span class="built_in">push_back</span>(it);</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">max_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)&#123; <span class="keyword">return</span> a.second &lt; b.second; &#125;);</span><br><span class="line">        <span class="keyword">int</span> maxnum = it-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)&#123; <span class="keyword">return</span> a.first &lt; b.first; &#125;);</span><br><span class="line"></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *tmp = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxnum; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (vec[j].second &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    tmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(vec[j].first);</span><br><span class="line">                    vec[j].second--;</span><br><span class="line">                    tmp = tmp-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode *tmp = dummy;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">8</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">        tmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(arr[i]);</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    res = <span class="built_in">Solution</span>().<span class="built_in">sortList</span>(dummy-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (res-&gt;next)&#123;</span><br><span class="line">        cout &lt;&lt; res-&gt;val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;2-&gt;4-&gt;2-&gt;4</span></span><br></pre></td></tr></table></figure>



<h2 id="0907-百度01"><a href="#0907-百度01" class="headerlink" title="0907-百度01"></a>0907-百度01</h2><p>大致题意为：有大小为N的方形矩阵，现将矩阵放大k倍，返回放大后的矩阵</p>
<p><strong>输入描述</strong></p>
<p>第一行输入两个整数N，K；接下来N行输入方向矩阵</p>
<p><strong>输出描述</strong></p>
<p>输出放大后的矩阵</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">2 2</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br><span class="line">输出</span><br><span class="line">0 0 1 1</span><br><span class="line">0 0 1 1 </span><br><span class="line">1 1 0 0 </span><br><span class="line">1 1 0 0 </span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">3 3</span><br><span class="line">1 0 1</span><br><span class="line">0 0 0</span><br><span class="line">1 0 1</span><br><span class="line">输出</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br><span class="line">1 1 1 0 0 0 1 1 1</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 模拟 先对列或行进行操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, K;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(N, vector&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            cin &gt;&gt; vec[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(K * N, vector&lt;<span class="keyword">int</span>&gt;(K * N, <span class="number">0</span>));</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; K; ++k)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; K; ++t)&#123;</span><br><span class="line">                    res[i * K + k][j * K + t] = vec[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K * N; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K * N; ++j)&#123;</span><br><span class="line">            cout &lt;&lt; res[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="0907-百度02"><a href="#0907-百度02" class="headerlink" title="0907-百度02"></a>0907-百度02</h2><p>大致题意为：给定一个整数N，若gcd(x,y)=1，且lcm(x,y)=N，则(x,y)为一对符合要求的答案。如N=30，(1，30)、(2，15)、(3，10)、(5，6)为满足条件的4对数。注：(2，15)和(15，2)为一对符合要求的答案</p>
<p><strong>输入描述</strong></p>
<p>第一行给出一个自然数T，表示测试用例的数量</p>
<p>接下来T行测试用例，每行给出一个自然数N</p>
<p>1 &lt;= T &lt;= 10^3    1 &lt;= N &lt;= 10^8</p>
<p><strong>输出描述</strong></p>
<p>按顺序输出每个测试用例的答案</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">1</span><br><span class="line">30</span><br><span class="line">输出</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">2</span><br><span class="line">16</span><br><span class="line">2021</span><br><span class="line">输出</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gcd(x,y) * lcm(x,y)  = x * y</span></span><br><span class="line"><span class="comment"> * __gcd(x,y)为自带求解最小公约数的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	<span class="keyword">int</span> count= <span class="number">0</span>;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="built_in">sqrt</span>(N); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = N/i;</span><br><span class="line">        <span class="keyword">if</span>(__gcd(i,j)==<span class="number">1</span> &amp;&amp; N==i*j)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0911-美团01"><a href="#0911-美团01" class="headerlink" title="0911-美团01"></a>0911-美团01</h2><h2 id="091158-同城01"><a href="#091158-同城01" class="headerlink" title="091158-同城01"></a>091158-同城01</h2><p>输入一个整数数组Array，长度为len，求指定长度sublen子数组和的最大值</p>
<p>输出最大子数组和以及最大子数组起始下标</p>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[1, 2, 30, 4, 5, 6, 7, 8, 9, 10], 10, 3</span><br><span class="line">输出</span><br><span class="line">[2， 39]</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双指针，滑动窗口</span></span><br><span class="line"><span class="comment"> * left 从0遍历到len-sublen，即[0, len-sublen]</span></span><br><span class="line"><span class="comment"> * right = left + sublen -1</span></span><br><span class="line"><span class="comment"> * 滑动窗口 [left, left+sublen-1]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> len, <span class="keyword">int</span> sublen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxres=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>; left&lt;=len-sublen; left++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=left; i&lt;=left + sublen - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; maxres)&#123;</span><br><span class="line">            maxres = sum;</span><br><span class="line">            res.<span class="built_in">clear</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(i-sublen);</span><br><span class="line">            res.<span class="built_in">push_back</span>(maxres);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">30</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    res = <span class="built_in">maxSub</span>(arr, arr.<span class="built_in">size</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        cout &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0912-巨人网络"><a href="#0912-巨人网络" class="headerlink" title="0912- 巨人网络"></a>0912- 巨人网络</h2><p>【==列数未知==】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">//资源数量</span><br><span class="line">5</span><br><span class="line">//资源编号，大小，依赖资源编号</span><br><span class="line">1001， 5</span><br><span class="line">1002， 10</span><br><span class="line">1000， 3， 1001， 1002</span><br><span class="line">2000， 7</span><br><span class="line">3000， 2， 2000</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">//占用资源最大的资源编号及大小</span><br><span class="line">1000， 18</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;data.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            vec[i][j] = data[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(vec[i].<span class="built_in">size</span>()==<span class="number">2</span>) sum+=vec[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;vec[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; ++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vec[i][j]==vec[k][<span class="number">0</span>])&#123;</span><br><span class="line">                    sum += vec[k][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;vec[i][<span class="number">0</span>],sum+vec[i][<span class="number">1</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), [](vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>]&gt;b[<span class="number">1</span>];&#125;);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; res[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0913-bilibili02"><a href="#0913-bilibili02" class="headerlink" title="0913-bilibili02"></a>0913-bilibili02</h2><p>【==行数，列数未知==】</p>
<p>给定一个二维数组，每行严格递增，找出在这些行中出现的最小的元素，如没有输出-1</p>
<p><strong>输入</strong></p>
<ul>
<li>每行一个数组，每个数组逗号分隔</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>输出一个整数</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">1,23,4,5,9</span><br><span class="line">2,4,5,8,9</span><br><span class="line">3,5,7,9,11</span><br><span class="line">1,3,5,7,9</span><br><span class="line">输出</span><br><span class="line">5</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-13 18:21:43</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-13 21:52:19</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//判断 整数 n 是否在数组 arr 中出现过</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">find</span>(arr[i])==st.<span class="built_in">end</span>())&#123;</span><br><span class="line">            st.<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> res = st.<span class="built_in">count</span>(n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s))&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//跳出输入</span></span><br><span class="line">        string tmp;</span><br><span class="line">        data.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(tmp));<span class="comment">//先存行</span></span><br><span class="line">        &#125;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(data);<span class="comment">//再存每行数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](vector&lt;<span class="keyword">int</span>&gt; a,vector&lt;<span class="keyword">int</span>&gt; b) &#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vec[<span class="number">0</span>].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;vec.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            flag = flag &amp;&amp; <span class="built_in">contain</span>(vec[j],vec[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) res.<span class="built_in">push_back</span>(vec[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">0</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; res[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0916-zoom01"><a href="#0916-zoom01" class="headerlink" title="0916-zoom01"></a>0916-zoom01</h2><p><strong>输入</strong></p>
<p>一个不知道列数的一维数组</p>
<p><strong>输出</strong></p>
<p>返回前3大个数，及其在原数组种的下标</p>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">63 23 22 28 57 46 85 71</span><br><span class="line">输出</span><br><span class="line">(7, 85) (8, 71) (1, 63) </span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-09-16 16:39:35</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-09-17 14:30:04</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 列数未知， 输入一行判断结束  多行输入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">     <span class="keyword">int</span> tmp;</span><br><span class="line">     <span class="keyword">while</span>(cin&gt;&gt;tmp)&#123;</span><br><span class="line">         a.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">         <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;a[i],i+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; a.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; res.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[j].first == a[i])&#123;</span><br><span class="line">                    b = res[j].second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span>&lt;&lt; a[i] &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; res.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[j].first == a[i])&#123;</span><br><span class="line">                    b = res[j].second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span>&lt;&lt; a[i] &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0916-腾讯音乐03"><a href="#0916-腾讯音乐03" class="headerlink" title="0916 -腾讯音乐03"></a>0916 -腾讯音乐03</h2><p>k进制下 1-m 中数字1出现的次数，记作F(m, k)，例如F(5, 3) = 5，因为三进制 1-5为{1， 2， 10， 11， 12}，数字1出现了5次，先给定k和n，求使得 F(m, k) &gt;=n 的最小m，返回吗。</p>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">5，3</span><br><span class="line">输出</span><br><span class="line">5</span><br><span class="line">说明</span><br><span class="line">F(m, 3)&gt;=5，最小的m为5</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">10，10</span><br><span class="line">输出</span><br><span class="line">17</span><br><span class="line">说明</span><br><span class="line">F(m, 10)&gt;=10，最小的m为17</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  转k进制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">intTox</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t=num%k;</span><br><span class="line">            <span class="keyword">if</span>(t&gt;=<span class="number">0</span> &amp;&amp; t&lt;<span class="number">9</span>) res += t + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> res += t<span class="number">-10</span>+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            num /= k;</span><br><span class="line">        &#125;<span class="keyword">while</span>(num!=<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == <span class="string">&#x27;1&#x27;</span>) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">intT</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t=num%k;</span><br><span class="line">            <span class="keyword">if</span>(t&gt;=<span class="number">10</span>) res += t<span class="number">-10</span>+<span class="string">&#x27;a&#x27;</span>; <span class="comment">//大于10进制</span></span><br><span class="line">            <span class="keyword">else</span> res += t + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            num /= k;</span><br><span class="line">        &#125;<span class="keyword">while</span>(num!=<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">minM</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here        </span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; res &lt; n; ++i)&#123;</span><br><span class="line">            res += <span class="built_in">intTox</span>(i, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">    ans = <span class="built_in">Solution</span>().<span class="built_in">minM</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ans;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0918电信云02"><a href="#0918电信云02" class="headerlink" title="0918电信云02"></a>0918电信云02</h2><p>实现简单计算器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="keyword">char</span>&gt; op;</span><br><span class="line">stack&lt;<span class="keyword">double</span>&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chartoint</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c - <span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isoperate</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priori</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">iswhatandcompute</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">double</span> n1, <span class="keyword">double</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">return</span> n1 * n2;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;/&#x27;</span>) <span class="keyword">return</span> n2 / n1;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> n2 + n1;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> n2 - n1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> size_s = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size_s;) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>) &#123;i++; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isoperate</span>(s[i])) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!op.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">char</span> t = op.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">priori</span>(t) &gt;= <span class="built_in">priori</span>(s[i])) &#123;</span><br><span class="line">                    <span class="keyword">double</span> n1 = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">double</span> n2 = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">double</span> n3 = <span class="built_in">iswhatandcompute</span>(t, n1, n2);</span><br><span class="line">                    num.<span class="built_in">push</span>(n3);</span><br><span class="line">                    op.<span class="built_in">pop</span>();</span><br><span class="line">                    op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> n = <span class="built_in">chartoint</span>(s[i]);</span><br><span class="line">            num.<span class="built_in">push</span>(n);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!op.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = op.<span class="built_in">top</span>(); op.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">double</span> t1 = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">double</span> t2 = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">double</span> t3 = <span class="built_in">iswhatandcompute</span>(t, t1, t2);</span><br><span class="line">            num.<span class="built_in">push</span>(t3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> n = num.<span class="built_in">top</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="built_in">compute</span>(s);</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0919寒武纪"><a href="#0919寒武纪" class="headerlink" title="0919寒武纪"></a>0919寒武纪</h2><p>为使数组有序，最少交换次数</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">5 2 1 4 3</span><br><span class="line">输出</span><br><span class="line">2</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 更倾向getminswap方法 哈希表对重复元素不🆗</span></span><br><span class="line"><span class="comment"> * val idx      pair     交换1次   交换2次           </span></span><br><span class="line"><span class="comment"> *  5   0      1   2     3   4    5   0</span></span><br><span class="line"><span class="comment"> *  2   1      2   1     2   1    2   1</span></span><br><span class="line"><span class="comment"> *  1   2      3   4     1   2    1   2</span></span><br><span class="line"><span class="comment"> *  4   3      4   3     4   3    4   3</span></span><br><span class="line"><span class="comment"> *  3   4      5   0     5   0    3   4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getminswap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  vec.<span class="built_in">push_back</span>(&#123;arr[i], i&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[i].second == i)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(vec[i].first, vec[vec[i].second].first);</span><br><span class="line">        <span class="built_in">swap</span>(vec[i].second, vec[vec[i].second].second);</span><br><span class="line">        <span class="keyword">if</span> (i != vec[i].second)&#123;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getminswap2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  vec.<span class="built_in">push_back</span>(&#123;arr[i], i&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;b)&#123;<span class="keyword">return</span> a.first &gt; b.first;&#125;);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[i].second == i)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(vec[i].first, vec[vec[i].second].first);</span><br><span class="line">            <span class="built_in">swap</span>(vec[i].second, vec[vec[i].second].second);</span><br><span class="line">            <span class="keyword">if</span> (i != vec[i].second)&#123;</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// int n;</span></span><br><span class="line">        <span class="comment">// cin &gt;&gt; n;</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; vec(n,0);</span></span><br><span class="line">        <span class="comment">// for(int i=0; i&lt;n; ++i) cin &gt;&gt; vec[i];</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">data</span><span class="params">(vec)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) mp[data[i]] = i;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">flag</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">while</span> (!flag[j])&#123;</span><br><span class="line">                    flag[j] = <span class="literal">true</span>;</span><br><span class="line">                    j = mp[vec[j]];</span><br><span class="line">                &#125;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) mp2[data[i]] = n-i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res2=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">flag2</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag2[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">while</span> (!flag2[j])&#123;</span><br><span class="line">                    flag2[j] = <span class="literal">true</span>;</span><br><span class="line">                    j = mp2[vec[j]];</span><br><span class="line">                &#125;</span><br><span class="line">                res2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">min</span>(n - res, n - res2);</span><br><span class="line">        <span class="comment">// int ans = min(getminswap(vec, vec.size()), getminswap2(vec, vec.size()));</span></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1009京东"><a href="#1009京东" class="headerlink" title="1009京东"></a>1009京东</h2><p><strong>输入</strong></p>
<ul>
<li>第一行有一个整数n，表示产品的数量</li>
<li>第二行有n个空格隔开的整数，一致度为n个数中出现次数最多的个数</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>两个下标</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">6</span><br><span class="line">4 2 1 2 2 3</span><br><span class="line">输出</span><br><span class="line">2 5</span><br><span class="line">解释：一致性为3，所选序列 2 1 2 2，下标从2到5</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Henry</span></span><br><span class="line"><span class="comment"> * @Date: 2021-10-08 18:05:15</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2021-10-10 18:45:10</span></span><br><span class="line"><span class="comment"> * @Description: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// int n;</span></span><br><span class="line">    <span class="comment">// cin &gt;&gt; n;</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt; a(n);</span></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; ++i) cin &gt;&gt; a[i];</span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">8</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:a) mp[x]++;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; ma;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:mp)&#123;</span><br><span class="line">        ma.<span class="built_in">push_back</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ma.<span class="built_in">begin</span>(), ma.<span class="built_in">end</span>(), [](pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; b)&#123;<span class="keyword">return</span> a.second &gt; b.second;&#125;);</span><br><span class="line">    <span class="comment">// int maxlen = ma[0].second;</span></span><br><span class="line">    <span class="comment">// int maxnum = ma[0].first;</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>, d=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ma[d].second=ma[d+<span class="number">1</span>].second)&#123;</span><br><span class="line">        c++;</span><br><span class="line">        d++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; left, right, len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]==ma[i].first)&#123;</span><br><span class="line">                left.<span class="built_in">push_back</span>(j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;<span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]==ma[i].first)&#123;</span><br><span class="line">                right.<span class="built_in">push_back</span>(j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len.<span class="built_in">push_back</span>(right[i]-left[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">min_element</span>(len.<span class="built_in">begin</span>(), len.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:len) cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dis = <span class="built_in">distance</span>(len.<span class="built_in">begin</span>(),it); <span class="comment">//根据迭代器求下标</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; left[dis]+<span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; right[dis]+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Henry</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/02/21/Algorithm/">http://example.com/2021/02/21/Algorithm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">桥头打字员</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a><a class="post-meta__tags" href="/tags/Leetcode/">Leetcode</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/60ead34a5132923bf8e4a1b8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/02/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><img class="prev-cover" src="https://pic.imgdb.cn/item/60ead34a5132923bf8e4a1b8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">网络编程</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/14/hello-world/"><img class="next-cover" src="https://pic.imgdb.cn/item/60ead34a5132923bf8e4a1b8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/03/15/shell/" title="shell"><img class="cover" src="https://pic.imgdb.cn/item/60ead34a5132923bf8e4a1b8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-15</div><div class="title">shell</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://pic.imgdb.cn/item/60d1f5ae844ef46bb26cedfb.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Henry</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.</span> <span class="toc-text">滑动窗口&#x2F;双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">1.1.</span> <span class="toc-text">LC-3. 无重复字符的最长子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">1.2.</span> <span class="toc-text">LC-76. 最小覆盖子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-3-%E5%AF%BB%E6%89%BE%E6%9C%80%E9%9D%A0%E5%B7%A6%E7%9A%84%E5%8C%B9%E9%85%8D%E5%AD%90%E4%B8%B2"><span class="toc-number">1.3.</span> <span class="toc-text">pa-3.寻找最靠左的匹配子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-191-%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.4.</span> <span class="toc-text">pa-191.优雅地分割字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.5.</span> <span class="toc-text">LC-1. 两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.6.</span> <span class="toc-text">LC-15. 三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-number">1.7.</span> <span class="toc-text">LC-40. 组合总和 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text">LC-451.根据字符出现频率排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">1.9.</span> <span class="toc-text">LC-165.比较版本号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">1.10.</span> <span class="toc-text">LC-136.只出现一次的数字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">2.2.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">2.3.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.5.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">2.6.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.</span> <span class="toc-text">归并排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">3.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="toc-number">3.1.</span> <span class="toc-text">LC-122. 买卖股票的最佳时机 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-9-%E5%A5%97%E5%A8%83"><span class="toc-number">3.2.</span> <span class="toc-text">pa-9.套娃</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-18-%E5%A5%97%E5%A8%83II"><span class="toc-number">3.3.</span> <span class="toc-text">pa-18.套娃II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-201-%E9%83%A8%E5%88%86%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">pa-201.部分和问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS-BFS"><span class="toc-number">4.</span> <span class="toc-text">DFS&#x2F;BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">4.1.</span> <span class="toc-text">LC-200.岛屿数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">4.2.</span> <span class="toc-text">LC-42.接雨水</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP"><span class="toc-number">5.</span> <span class="toc-text">动态规划DP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">5.1.</span> <span class="toc-text">LC-5. 最长回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ-47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">5.2.</span> <span class="toc-text">JZ-47.礼物的最大价值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ-63-%E8%82%A1%E7%A5%A8%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-number">5.3.</span> <span class="toc-text">JZ-63.股票最大利润</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-185-%E7%A7%8D%E6%A4%8D%E6%A3%92%E7%93%9C"><span class="toc-number">5.4.</span> <span class="toc-text">pa-185.种植棒瓜</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-97-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E9%94%99"><span class="toc-number">5.5.</span> <span class="toc-text">LC-97.字符串交错</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-39-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">5.6.</span> <span class="toc-text">pa-39.数字三角形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-130-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%BA%8F%E5%88%97II"><span class="toc-number">5.7.</span> <span class="toc-text">pa-130.合并两个序列II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-131-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%BA%8F%E5%88%97III"><span class="toc-number">5.8.</span> <span class="toc-text">pa-131.合并两个序列III</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">高频面试系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#atoi-atof"><span class="toc-number">6.1.</span> <span class="toc-text">atoi atof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%90%88%E6%B3%95IP"><span class="toc-number">6.2.</span> <span class="toc-text">判断合法IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF"><span class="toc-number">6.3.</span> <span class="toc-text">约瑟夫环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E7%B4%A0%E6%95%B0"><span class="toc-number">6.4.</span> <span class="toc-text">寻找素数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%B9%82%E8%BF%90%E7%AE%97"><span class="toc-number">6.5.</span> <span class="toc-text">模幂运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-3-%E5%AF%BB%E6%89%BE%E6%9C%80%E9%9D%A0%E5%B7%A6%E7%9A%84%E5%8C%B9%E9%85%8D%E5%AD%90%E4%B8%B2-1"><span class="toc-number">6.6.</span> <span class="toc-text">pa-3.寻找最靠左的匹配子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-4-%E9%95%BF%E5%BA%A6%E4%B8%BA-K-%E7%9A%84%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">6.7.</span> <span class="toc-text">pa-4.长度为 K 的回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-29-%E5%9B%9E%E6%96%87%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">6.8.</span> <span class="toc-text">pa-29.回文平方数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-30-%E5%8F%8C%E9%87%8D%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-number">6.9.</span> <span class="toc-text">pa-30.双重回文数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-27-%E6%8C%A4%E7%89%9B%E5%A5%B6"><span class="toc-number">6.10.</span> <span class="toc-text">pa-27.挤牛奶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-19-%E5%90%8E%E7%BC%800"><span class="toc-number">6.11.</span> <span class="toc-text">pa-19.后缀0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-20-%E5%90%88%E9%80%82%E7%AF%AE%E7%AD%90%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">6.12.</span> <span class="toc-text">pa-20.合适篮筐的数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-9-%E5%A5%97%E5%A8%83-1"><span class="toc-number">6.13.</span> <span class="toc-text">pa-9.套娃</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-18-%E5%A5%97%E5%A8%83II-1"><span class="toc-number">6.14.</span> <span class="toc-text">pa-18.套娃II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-10-%E8%AE%A1%E7%AE%97%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">6.15.</span> <span class="toc-text">pa-10.计算第k个排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-10-%E8%AE%A1%E7%AE%97%E6%8E%92%E5%88%97%E7%9A%84%E7%BC%96%E5%8F%B7"><span class="toc-number">6.16.</span> <span class="toc-text">pa-10.计算排列的编号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-140-%E5%85%AC%E5%8F%B8%E5%9B%A2%E5%BB%BA"><span class="toc-number">6.17.</span> <span class="toc-text">pa-140.公司团建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-141-%E5%85%AC%E5%8F%B8%E5%9B%A2%E5%BB%BAII"><span class="toc-number">6.18.</span> <span class="toc-text">pa-141.公司团建II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-15-%E5%88%B7%E6%88%BF%E5%AD%90"><span class="toc-number">6.19.</span> <span class="toc-text">pa-15.刷房子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-17-%E5%88%B7%E6%88%BF%E5%AD%90II"><span class="toc-number">6.20.</span> <span class="toc-text">pa-17.刷房子II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-153-%E5%B9%B3%E9%9D%A2%E5%88%86%E5%89%B2"><span class="toc-number">6.21.</span> <span class="toc-text">pa-153.平面分割</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-151-%E8%B5%B0%E6%A5%BC%E6%A2%AF"><span class="toc-number">6.22.</span> <span class="toc-text">pa-151.走楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-157-%E6%8B%86%E5%88%86%E7%9B%B8%E7%AD%89%E9%9B%86%E5%90%88"><span class="toc-number">6.23.</span> <span class="toc-text">pa-157.拆分相等集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pa-194-%E6%8A%BD%E7%AD%BE"><span class="toc-number">6.24.</span> <span class="toc-text">pa-194.抽签</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">7.</span> <span class="toc-text">数组&#x2F;字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-number">7.1.</span> <span class="toc-text">LC-14.最长公共前缀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">7.2.</span> <span class="toc-text">合并k个有序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2"><span class="toc-number">7.3.</span> <span class="toc-text">字符串分割</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-number">7.4.</span> <span class="toc-text">单词搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">LC-4.寻找两个正序数组的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">7.6.</span> <span class="toc-text">定长子数组和!!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C"><span class="toc-number">7.7.</span> <span class="toc-text">最大子矩阵和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8-%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">链表&#x2F;树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">8.1.</span> <span class="toc-text">二叉树遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-2-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">8.2.</span> <span class="toc-text">LC-2.两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">8.3.</span> <span class="toc-text">LC-21.合并两个有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">8.4.</span> <span class="toc-text">LC-23.合并k个有序升序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ-24-%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">8.5.</span> <span class="toc-text">JZ-24.翻转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="toc-number">8.6.</span> <span class="toc-text">LC-92.反转链表 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">8.7.</span> <span class="toc-text">LC-141.环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-42-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="toc-number">8.8.</span> <span class="toc-text">LC-42. 环形链表 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">8.9.</span> <span class="toc-text">LC-146.LRU缓存机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">8.10.</span> <span class="toc-text">JZ-22.链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">8.11.</span> <span class="toc-text">LC-19.删除链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="toc-number">8.12.</span> <span class="toc-text">JZ-40.最小的k个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ2-53-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="toc-number">8.13.</span> <span class="toc-text">JZ2-53.二叉搜索树的中序后继</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="toc-number">8.14.</span> <span class="toc-text">JZ-54.二叉搜索数的第k大节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0%E7%9A%84%E7%AC%ACk%E5%B0%8F%E8%8A%82%E7%82%B9"><span class="toc-number">8.15.</span> <span class="toc-text">二叉搜索数的第k小节点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">9.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86-%E6%A0%88"><span class="toc-number">10.</span> <span class="toc-text">堆&#x2F;栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">10.1.</span> <span class="toc-text">LC-20.有效的括号</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%8B%E7%9B%98-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">11.</span> <span class="toc-text">棋盘 最短路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%94%E8%AF%95"><span class="toc-number">12.</span> <span class="toc-text">笔试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0831-pdd01"><span class="toc-number">12.1.</span> <span class="toc-text">0831-pdd01</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0831-pdd02"><span class="toc-number">12.2.</span> <span class="toc-text">0831-pdd02</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0831-pdd03"><span class="toc-number">12.3.</span> <span class="toc-text">0831-pdd03</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0901-%E5%B0%8F%E7%B1%B3"><span class="toc-number">12.4.</span> <span class="toc-text">0901-小米</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0906-%E8%8E%89%E8%8E%89%E4%B8%9D01"><span class="toc-number">12.5.</span> <span class="toc-text">0906-莉莉丝01</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0906-%E8%8E%89%E8%8E%89%E4%B8%9D02"><span class="toc-number">12.6.</span> <span class="toc-text">0906-莉莉丝02</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0907-%E7%99%BE%E5%BA%A601"><span class="toc-number">12.7.</span> <span class="toc-text">0907-百度01</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0907-%E7%99%BE%E5%BA%A602"><span class="toc-number">12.8.</span> <span class="toc-text">0907-百度02</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0911-%E7%BE%8E%E5%9B%A201"><span class="toc-number">12.9.</span> <span class="toc-text">0911-美团01</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#091158-%E5%90%8C%E5%9F%8E01"><span class="toc-number">12.10.</span> <span class="toc-text">091158-同城01</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0912-%E5%B7%A8%E4%BA%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">12.11.</span> <span class="toc-text">0912- 巨人网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0913-bilibili02"><span class="toc-number">12.12.</span> <span class="toc-text">0913-bilibili02</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0916-zoom01"><span class="toc-number">12.13.</span> <span class="toc-text">0916-zoom01</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0916-%E8%85%BE%E8%AE%AF%E9%9F%B3%E4%B9%9003"><span class="toc-number">12.14.</span> <span class="toc-text">0916 -腾讯音乐03</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0918%E7%94%B5%E4%BF%A1%E4%BA%9102"><span class="toc-number">12.15.</span> <span class="toc-text">0918电信云02</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0919%E5%AF%92%E6%AD%A6%E7%BA%AA"><span class="toc-number">12.16.</span> <span class="toc-text">0919寒武纪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1009%E4%BA%AC%E4%B8%9C"><span class="toc-number">12.17.</span> <span class="toc-text">1009京东</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/07/17/gstreamer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gobject%E7%B1%BB%E5%AF%B9%E8%B1%A1/" title="GStreamer学习笔记--GObject类对象"><img src="https://pic.imgdb.cn/item/60ead34a5132923bf8e4a1b8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GStreamer学习笔记--GObject类对象"/></a><div class="content"><a class="title" href="/2021/07/17/gstreamer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gobject%E7%B1%BB%E5%AF%B9%E8%B1%A1/" title="GStreamer学习笔记--GObject类对象">GStreamer学习笔记--GObject类对象</a><time datetime="2021-07-17T08:48:47.000Z" title="发表于 2021-07-17 16:48:47">2021-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/10/week-2-2/" title="Deepstream 检测安全帽👷"><img src="https://pic.imgdb.cn/item/60ead34a5132923bf8e4a1b8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Deepstream 检测安全帽👷"/></a><div class="content"><a class="title" href="/2021/07/10/week-2-2/" title="Deepstream 检测安全帽👷">Deepstream 检测安全帽👷</a><time datetime="2021-07-10T05:32:29.000Z" title="发表于 2021-07-10 13:32:29">2021-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/09/week-2-1/" title="Installing  GStreamer"><img src="https://pic.imgdb.cn/item/60ead34a5132923bf8e4a1b8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Installing  GStreamer"/></a><div class="content"><a class="title" href="/2021/07/09/week-2-1/" title="Installing  GStreamer">Installing  GStreamer</a><time datetime="2021-07-09T13:01:50.000Z" title="发表于 2021-07-09 21:01:50">2021-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/02/week-1/" title="Jetson 部署 Deepstream"><img src="https://pic.imgdb.cn/item/60ead34a5132923bf8e4a1b8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Jetson 部署 Deepstream"/></a><div class="content"><a class="title" href="/2021/07/02/week-1/" title="Jetson 部署 Deepstream">Jetson 部署 Deepstream</a><time datetime="2021-07-02T12:13:16.000Z" title="发表于 2021-07-02 20:13:16">2021-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="面向对象"><img src="https://pic.imgdb.cn/item/60ead34a5132923bf8e4a1b8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面向对象"/></a><div class="content"><a class="title" href="/2021/05/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="面向对象">面向对象</a><time datetime="2021-05-21T14:32:12.000Z" title="发表于 2021-05-21 22:32:12">2021-05-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Henry</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>