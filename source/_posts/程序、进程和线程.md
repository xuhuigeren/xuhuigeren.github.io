---
title: 程序、进程和线程
date: 2021-03-03 22:12:17
tags: [pthread,Linux]
categories: 操作系统
description: 学习操作系统的核心概念——进程和线程
---





[TOC]

## sleep()和usleep()

函数名:**sleep()**

头文件:`#include <unistd.h> `  // 在`gcc`编译器中，使用的头文件因`gcc`版本的不同而不同

功 能: 执行挂起指定的秒数
语 法: `unsigned sleep(unsigned seconds);`

函数名:**usleep()**
头文件:` #include <unistd.h>`
功  能:` usleep`功能把进程挂起一段时间， 单位是微秒（百万分之一秒）
语  法:` void usleep(int micro_seconds);`
内容说明：本函数可暂时使程序停止执行。参数 `micro_seconds `为要暂停的微秒数(us)。

## 线程间的互斥

下面是一个线程互斥的例子。代码用线程互斥的方法构建了以哦个生产者和消费者的例子。代码中建立了两个线程，函数`producter_f()`用于生成，函数`consumer_f()`用于消费。

```c
/*
* mutex.c
* 线程实例
*/
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <sched.h>
void *producter_f (void *arg);					/*生产者*/
void *consumer_f (void *arg);					/*消费者*/
int buffer_has_item=0;							/*缓冲区计数值*/
pthread_mutex_t mutex;							/*互斥区*/
int running =1 ;								/*线程运行控制*/
int main (void)
{
	pthread_t consumer_t;						/*消费者线程参数*/
	pthread_t producter_t;						/*生产者线程参数*/
	
	pthread_mutex_init (&mutex,NULL);			/*初始化互斥*/
	
	pthread_create(&producter_t, NULL,(void*)producter_f, NULL );														            /*建立生产者线程*/
	pthread_create(&consumer_t, NULL, (void *)consumer_f, NULL);														            /*建立消费者线程*/
	usleep(1);									/*等待，线程创建完毕*/
	running =0;									/*设置线程退出值*/
	pthread_join(consumer_t,NULL);				/*等待消费者线程退出*/
	pthread_join(producter_t,NULL);			    /*等待生产者线程退出*/
	pthread_mutex_destroy(&mutex);				/*销毁互斥*/
	
	return 0;
}
void *producter_f (void *arg)					/*生产者线程程序*/
{
	while(running)								/*没有设置退出值*/
	{	
		pthread_mutex_lock (&mutex);			/*进入互斥区*/
		buffer_has_item++;						/*增加计数值*/
		printf("生产，总数量:%d\n",buffer_has_item); 	/*打印信息*/
		pthread_mutex_unlock(&mutex);			/*离开互斥区*/
	}
}
void *consumer_f(void *arg)						/*消费者线程程序*/
{
	while(running)								/*没有设置退出值*/
	{
		pthread_mutex_lock(&mutex);				/*进入互斥区*/
		buffer_has_item--;						/*减小计数值*/
		printf("消费，总数量:%d\n",buffer_has_item);	/*打印信息*/
		pthread_mutex_unlock(&mutex);			/*离开互斥区*/
	}
}
```

输出

```
生产，总数量:1
消费，总数量:0
```

上例中声明了一个线程互斥变量`mutex`,在线程函数`consumer_f()`和`producter_f()`中，用线程互斥锁函数`pthread_mutex_lock()`和`pthread_mutex_ublock()`来保护对公共变量`buffer_has_item`的访问。

## 线程中使用信号量

下面是一个使用信号量的例子。在`mutex`的例子中，使用了一个全局变量来计数，在这个例子中，使用信号量来做同样的工作，其中一个线程增加信号量来模仿生产者，另一个线程获得信号量来模仿消费者。

```c
/*
* sem.c
* 线程实例
*/
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <semaphore.h>
void *producter_f (void *arg);					/*生产者线程函数*/
void *consumer_f (void *arg);					/*消费者线程函数*/
sem_t sem;
int running =1 ;
int main (void)
{
	pthread_t consumer_t;						/*消费者线程参数*/
	pthread_t producter_t;						/*生产者线程参数*/
	
	sem_init (&sem, 0, 16);						/*信号量初始化*/
	
	pthread_create(&producter_t, NULL,(void*)producter_f, NULL ); 														            /*建立生产者线程*/
	pthread_create(&consumer_t, NULL, (void *)consumer_f, NULL); 														            /*建立消费者线程*/
	sleep(1);									/*等待*/
	running =0;									/*设置线程退出*/
	pthread_join(consumer_t,NULL);				/*等待消费者线程退出*/
	pthread_join(producter_t,NULL);			    /*等待生产者线程退出*/
	sem_destroy(&sem);							/*销毁信号量*/
	
	return 0;
}
void *producter_f (void *arg)					/*生产者处理程序代码*/
{
	int semval=0;								/*信号量的初始值为0*/
	while(running)								/*运行状态为可运行*/
	{
		usleep(1);								/*等待*/
		sem_post (&sem);						/*信号量增加*/
		sem_getvalue(&sem,&semval);				/*获得信号量的值*/
		printf("生产，总数量:%d\n",semval);		/*打印信息*/
	}
}
void *consumer_f(void *arg)						/*消费者处理程序代码*/
{
	int semval=0;								/*信号量的初始值为0*/
	while(running)								/*运行状态为可运行*/
	{
		usleep(1);								/*等待*/
		sem_wait(&sem);							/*等待信号量*/
		sem_getvalue(&sem,&semval);				/*获得信号量的值*/
		printf("消费，总数量:%d\n",semval);		/*打印信息*/
	}
}
```

输出

```
...
生产，总数量:56
生产，总数量:57
消费，总数量:56
消费，总数量:55
生产，总数量:56
消费，总数量:55
生产，总数量:56
生产，总数量:57
消费，总数量:56
消费，总数量:55
生产，总数量:56
生产，总数量:57
消费，总数量:56
消费，总数量:55
生产，总数量:56
...
```

从执行结果可以看出，以上程序建立的各个线程间存在竞争关系。而数值并未按产生一个消耗一个的顺序显示出来，而是以交叉的方式进行，有的时候产生多个再消耗多个。造成这种现象的原因是信号量的产生和消耗是对`CPU`竞争的结果。